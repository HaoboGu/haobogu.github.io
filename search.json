[{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1G5411C7mu\nRust + RTOS æ¦‚å†µ åœ¨Rustä¸­ï¼ŒRTOSåˆ†ä¸ºä¸¤ç±»ï¼š\nåŸºäºC bindingsçš„RTOS zephyr: https://github.com/tylerwhall/zephyr-rust FreeRTOS: https://github.com/lobaro/FreeRTOS-rust Pure Rust åä¼ ç»Ÿçš„RTOS https://github.com/tock/tock https://github.com/oxidecomputer/hubris å¼‚æ­¥è¿è¡Œæ—¶ ğŸ‘ https://github.com/embassy-rs/embassy https://github.com/rtic-rs/rtic Rustå¼‚æ­¥ç¼–ç¨‹ ç®€ä»‹ async ç¼–ç¨‹å…¥é—¨ - Rustè¯­è¨€åœ£ç»(Rust Course)\nå¼‚æ­¥è¿è¡Œæ—¶ embassy-rs Embassy\nç¤ºä¾‹ä»£ç ï¼ˆç‚¹ç¯ + buttonï¼‰ main.rs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #![no_std] #![no_main] use defmt::*; use embassy_executor::Spawner; use embassy_stm32::{ exti::ExtiInput, gpio::{AnyPin, Input, Level, Output, Pin, Pull}, }; use embassy_time::Timer; use {defmt_rtt as _, panic_probe as _}; // Declare async tasks #[embassy_executor::task] async fn blink(pin: AnyPin) { let mut led = Output::new(pin, Level::Low, embassy_stm32::gpio::Speed::High); loop { // Timekeeping is globally available, no need to mess with hardware timers. led.set_high(); Timer::after_millis(150).await; led.set_low(); Timer::after_millis(150).await; } } // Main is itself an async task as well. #[embassy_executor::main] async fn main(spawner: Spawner) { // Initialize the embassy-stm32 HAL. let p = embassy_stm32::init(Default::default()); // Spawned tasks run in the background, concurrently. spawner.spawn(blink(p.PE3.degrade())).unwrap(); let mut button = ExtiInput::new(Input::new(p.PC13, Pull::Down), p.EXTI13); loop { // Asynchronously wait for GPIO events, allowing other tasks // to run, or the core to sleep. button.wait_for_rising_edge().await; info!(\"Button pressed!\"); button.wait_for_falling_edge().await; info!(\"Button released!\"); } } build.rs:\n1 2 3 4 5 fn main() { println!(\"cargo:rustc-link-arg-bins=--nmagic\"); println!(\"cargo:rustc-link-arg-bins=-Tlink.x\"); println!(\"cargo:rustc-link-arg-bins=-Tdefmt.x\"); } .cargo/config.toml\n1 2 3 4 5 6 7 8 [target.thumbv7em-none-eabihf] runner = \"probe-rs run --chip STM32H7B0VBTx\" [build] target = \"thumbv7em-none-eabihf\" [env] DEFMT_LOG = \"info\" Cargo.toml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 [package] edition = \"2021\" name = \"embassy-stm32h7-examples\" version = \"0.1.0\" license = \"MIT OR Apache-2.0\" [dependencies] embassy-stm32 = { version = \"0.1.0\", features = [\"defmt\", \"stm32h7b0vb\", \"time-driver-any\", \"exti\", \"memory-x\", \"unstable-pac\", \"chrono\"] } embassy-executor = { version = \"0.5.0\", features = [\"task-arena-size-32768\", \"arch-cortex-m\", \"executor-thread\", \"defmt\", \"integrated-timers\"] } embassy-time = { version = \"0.3.0\", features = [\"defmt\", \"defmt-timestamp-uptime\", \"tick-hz-32_768\"] } defmt = \"0.3\" defmt-rtt = \"0.4\" cortex-m = { version = \"0.7.6\", features = [\"inline-asm\", \"critical-section-single-core\"] } cortex-m-rt = \"0.7.0\" panic-probe = { version = \"0.3\", features = [\"print-defmt\"] } # cargo build/run [profile.dev] codegen-units = 1 debug = 2 debug-assertions = true # \u003c- incremental = false opt-level = 3 # \u003c- overflow-checks = true # \u003c- # cargo build/run --release [profile.release] codegen-units = 1 debug = 2 debug-assertions = false # \u003c- incremental = false lto = 'fat' opt-level = 3 # \u003c- overflow-checks = false # \u003c- ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ7ï¼‰- RTOSæ¦‚å†µ","uri":"/posts/keyboard/7-%E5%BC%82%E6%AD%A5rust-rtos/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1pb4y1A72W\nå®‰è£…å·¥å…· cargo-binutil https://github.com/rust-embedded/cargo-binutils\n1 2 cargo install cargo-binutils rustup component add llvm-tools cargo-bloat 1 cargo install cargo-bloat ä½¿ç”¨ --release é»˜è®¤cargo buildæ˜¯debugæ¨¡å¼ï¼Œdebugä¿¡æ¯ä¼šå ç”¨å¤§é‡å›ºä»¶å†…å®¹ã€‚æ‰“åŒ…ç”Ÿäº§éœ€è¦ä½¿ç”¨ --releaseã€‚\n1 cargo build --release ä¸‹é¢çš„æ‰€æœ‰å‘½ä»¤ï¼Œéƒ½å¯ä»¥åŠ ä¸Š --releaseã€‚å¦‚æœä¸åŠ ï¼Œé»˜è®¤éƒ½æ˜¯å¯¹debugæ¨¡å¼ä¸‹çš„å›ºä»¶æ‰§è¡Œç›¸å…³å‘½ä»¤ã€‚\næŸ¥çœ‹å›ºä»¶å¤§å° é»˜è®¤ç”Ÿæˆçš„å›ºä»¶æ˜¯ elf æ–‡ä»¶ï¼Œå…¶å¤§å°ä¸èƒ½çœŸå®åœ°åæ˜ å›ºä»¶å¤§å°ã€‚\næŸ¥çœ‹å›ºä»¶/text/data/bssæ®µçš„å¤§å° 1 cargo size æŸ¥çœ‹æ¯ä¸ªsectionçš„å¤§å° 1 2 3 4 cargo size -- -A # åå…­è¿›åˆ¶å±•ç¤º cargo size -- -A -x é…ç½® Cargo.toml æ–‡æ¡£ï¼šhttps://doc.rust-lang.org/cargo/reference/profiles.html#profiles\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [profile.dev] codegen-units = 1 # better optimizations debug = true opt-level = 1 overflow-checks = true lto = false panic = 'unwind' [profile.release] codegen-units = 1 # better optimizations debug = true # no overhead for bare-metal opt-level = \"z\" # optimize for binary size opt-level = \"s\" # overflow-checks = false lto = \"fat åˆ†æå›ºä»¶å¤§å° 1 cargo bloat --release ä½¿ç”¨ nm åˆ†æ\n1 cargo nm --release -- --print-size --size-sort ç¼–è¯‘ç”Ÿæˆ .bin æ–‡ä»¶ ä¸‹é¢çš„å‘½ä»¤ä¼šè‡ªåŠ¨é‡æ–°ç¼–è¯‘å·¥ç¨‹ï¼Œå¹¶ä¸”ç”Ÿæˆ .bin æ–‡ä»¶\n1 cargo objcopy --release -- -O binary rust-embedded-demo.bin åœ¨tasks.jsoné‡Œé¢é…ç½®å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 { \"label\": \"build .bin firmware\", \"type\": \"shell\", \"command\": \"cargo objcopy --release -- -O binary \\\"${workspaceFolder}/target/release/rust-embedded-demo.bin\\\"\", \"problemMatcher\": [ \"$rustc\" ], \"group\": { \"kind\": \"build\", }, }, æ³¨æ„ï¼šbin æ— æ³•è°ƒè¯•ã€‚æœ€å¥½ elf/bin æ–‡ä»¶éƒ½ç”Ÿæˆå‡ºæ¥\n","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ6ï¼‰- ä¼˜åŒ–å›ºä»¶ä½“ç§¯","uri":"/posts/keyboard/6%E4%BC%98%E5%8C%96%E5%9B%BA%E4%BB%B6%E4%BD%93%E7%A7%AF/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1nN41177ct\nç›¸å…³é“¾æ¥ embedded-hal æ–‡æ¡£ï¼šhttps://docs.rs/embedded-hal/latest/embedded_hal embedded-hal ä»£ç ä»“åº“ï¼šhttps://github.com/rust-embedded/embedded-hal ç¤ºä¾‹ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #![no_main] #![no_std] mod rtt_logger; use cortex_m_rt::entry; use log::{debug, error, info, warn}; use panic_rtt_target as _; use stm32h7xx_hal::{ hal::digital::v2::{InputPin, OutputPin}, pac, prelude::*, }; fn control_led\u003cIn: InputPin\u003cError = E\u003e, Out: OutputPin\u003cError = E\u003e, E\u003e( input_pin: \u0026In, led_pin: \u0026mut Out, ) -\u003e Result\u003c(), E\u003e { if input_pin.is_high()? { info!(\"high\"); led_pin.set_high()?; } else { info!(\"low\"); led_pin.set_low()?; } Ok(()) } #[entry] fn main() -\u003e ! { rtt_logger::init(log::LevelFilter::Debug); // è·å–cortexæ ¸å¿ƒå¤–è®¾å’Œstm32h7çš„æ‰€æœ‰å¤–è®¾ let cp = cortex_m::Peripherals::take().unwrap(); let dp = pac::Peripherals::take().unwrap(); // Power è®¾ç½® let pwr = dp.PWR.constrain(); let pwrcfg = pwr.freeze(); // åˆå§‹åŒ–RCC let rcc = dp.RCC.constrain(); let ccdr = rcc.sys_ck(200.MHz()).freeze(pwrcfg, \u0026dp.SYSCFG); // è®¾ç½®LEDå¯¹åº”çš„GPIO let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE); let mut led = gpioe.pe3.into_push_pull_output(); let gpioc = dp.GPIOC.split(ccdr.peripheral.GPIOC); let key = gpioc.pc13.into_pull_down_input(); // cortex-må·²ç»å®ç°å¥½äº†delayå‡½æ•°ï¼Œç›´æ¥æ‹¿åˆ°ï¼Œä¸‹é¢ä½¿ç”¨ let mut delay = cp.SYST.delay(ccdr.clocks); loop { // ç‚¹ç¯ control_led(\u0026key, \u0026mut led).unwrap(); // å»¶æ—¶50ms delay.delay_ms(50_u16); } } ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ5ï¼‰- embedded-hal \u0026 gpioç‚¹ç¯","uri":"/posts/keyboard/5embedded-hal-gpio/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV14N4y1U7XE\nå¿…é€‰æ’ä»¶ rust analyzer cortex debug VSCodeé…ç½® .vscode/tasks.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { /* * This is the default cargo build task, * but we need to provide a label for it, * so we can invoke it from the debug launcher. */ \"label\": \"Cargo Build (debug)\", \"type\": \"process\", \"command\": \"cargo\", \"args\": [\"build\"], \"problemMatcher\": [ \"$rustc\" ], \"group\": { \"kind\": \"build\", } }, { \"label\": \"Cargo Build (release)\", \"type\": \"process\", \"command\": \"cargo\", \"args\": [\"build\", \"--release\"], \"problemMatcher\": [ \"$rustc\" ], \"group\": \"build\" }, { \"label\": \"Flash\", \"type\": \"shell\", \"command\": \"openocd -f ${workspaceFolder}/openocd.cfg -c \\\"program target/thumbv7em-none-eabihf/debug/rust-embedded-demo preverify verify reset exit\\\"\", \"dependsOn\": [ \"Cargo Build (debug)\" ], \"group\": \"build\" }, { \"label\": \"Cargo Clean\", \"type\": \"process\", \"command\": \"cargo\", \"args\": [\"clean\"], \"problemMatcher\": [], \"group\": \"build\" }, ] } .vscode/launch.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { /* * Requires the Rust Language Server (rust-analyzer) and Cortex-Debug extensions * https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer * https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug */ \"version\": \"0.2.0\", \"configurations\": [ { /* Configuration for the STM32F303 Discovery board */ \"type\": \"cortex-debug\", \"request\": \"launch\", \"name\": \"Debug (OpenOCD)\", \"servertype\": \"openocd\", \"cwd\": \"${workspaceRoot}\", \"preLaunchTask\": \"Flash\", \"runToEntryPoint\": \"main\", \"executable\": \"./target/thumbv7em-none-eabihf/debug/rust-embedded-demo\", \"svdFile\": \"${workspaceRoot}/STM32H7B0x.svd\", \"configFiles\": [ \"${workspaceRoot}/openocd.cfg\" ], \"rttConfig\": { \"enabled\": true, \"address\": \"auto\", \"clearSearch\": false, \"polling_interval\": 20, \"rtt_start_retry\": 2000, \"decoders\": [ { \"label\": \"RTT channel 0\", \"port\": 0, \"type\": \"console\" } ] }, } ] } å·¥ç¨‹é…ç½® Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 [package] authors = [\"Haobo Gu \u003chaobogu@outlook.com\u003e\"] edition = \"2018\" readme = \"README.md\" name = \"rust-embedded-demo\" version = \"0.1.0\" [dependencies] cortex-m = \"0.7.7\" cortex-m-rt = \"0.7.3\" panic-rtt-target = { version = \"0.1.2\", features = [\"cortex-m\"] } rtt-target = \"0.4.0\" stm32h7xx-hal = { version = \"0.15.1\", features = [\"rt\", \"stm32h7b0\"] } log = \"0.4.20\" # Uncomment for the panic example. # panic-itm = \"0.4.1\" # Uncomment for the allocator example. # alloc-cortex-m = \"0.4.0\" # Uncomment for the device example. # Update `memory.x`, set target to `thumbv7em-none-eabihf` in `.cargo/config`, # and then use `cargo build --examples device` to build it. # [dependencies.stm32f3] # features = [\"stm32f303\", \"rt\"] # version = \"0.7.1\" # this lets you use `cargo fix`! [[bin]] name = \"rust-embedded-demo\" test = false bench = false [profile.release] codegen-units = 1 # better optimizations debug = true # symbols are nice and they don't increase the size on Flash lto = true # better optimizations ä»£ç  main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #![no_main] #![no_std] mod rtt_logger; use cortex_m_rt::entry; use log::{info, warn, error}; use panic_rtt_target as _; use stm32h7xx_hal::{pac, prelude::*}; #[entry] fn main() -\u003e ! { rtt_logger::init(log::LevelFilter::Debug); // è·å–cortexæ ¸å¿ƒå¤–è®¾å’Œstm32h7çš„æ‰€æœ‰å¤–è®¾ let cp = cortex_m::Peripherals::take().unwrap(); let dp = pac::Peripherals::take().unwrap(); // Power è®¾ç½® let pwr = dp.PWR.constrain(); let pwrcfg = pwr.freeze(); // åˆå§‹åŒ–RCC let rcc = dp.RCC.constrain(); let ccdr = rcc.sys_ck(200.MHz()).freeze(pwrcfg, \u0026dp.SYSCFG); // è®¾ç½®LEDå¯¹åº”çš„GPIO let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE); let mut led = gpioe.pe3.into_push_pull_output(); // cortex-må·²ç»å®ç°å¥½äº†delayå‡½æ•°ï¼Œç›´æ¥æ‹¿åˆ°ï¼Œä¸‹é¢ä½¿ç”¨ let mut delay = cp.SYST.delay(ccdr.clocks); let mut cnt: u32 = 0; loop { // ç‚¹ç¯ if cnt == 1 { info!(\"current cnt: {}\", cnt); } else if cnt == 2 { warn!(\"current cnt: {}\", cnt); } else if cnt == 3 { error!(\"current cnt: {}\", cnt); } else if cnt \u003e 100000 { panic!(\"panicked!\") } else { debug!(\"current cnt: {}\", cnt); } cnt += 1; led.toggle(); // å»¶æ—¶500ms delay.delay_ms(500_u16); } } rtt_logger.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 use panic_rtt_target as _; use log::{Level, LevelFilter, Metadata, Record}; use rtt_target::{rprintln, rtt_init_print}; pub struct Logger { level: Level, } static LOGGER: Logger = Logger { level: Level::Info }; pub fn init(level: LevelFilter) { rtt_init_print!(); log::set_logger(\u0026LOGGER) .map(|()| log::set_max_level(level)) .unwrap(); } impl log::Log for Logger { fn enabled(\u0026self, metadata: \u0026Metadata) -\u003e bool { metadata.level() \u003c= self.level } fn log(\u0026self, record: \u0026Record) { let prefix = match record.level() { Level::Error =\u003e \"\\x1B[1;31m\", Level::Warn =\u003e \"\\x1B[1;33m\", Level::Info =\u003e \"\\x1B[1;32m\", Level::Debug =\u003e \"\\x1B[1;30m\", Level::Trace =\u003e \"\\x1B[2;30m\", }; rprintln!(\"{}{} - {}\\x1B[0m\", prefix, record.level(), record.args()); } fn flush(\u0026self) {} } ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ4ï¼‰- VSCodeå¼€å‘ç¯å¢ƒé…ç½®","uri":"/posts/keyboard/4%E6%8A%8Avscode%E6%89%93%E9%80%A0%E6%88%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%9A%84%E5%88%A9%E5%99%A8/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1g94y1V75c\nRuståµŒå…¥å¼å·¥ä½œç»„ https://github.com/rust-embedded/wg\nè½¯ä»¶ç”Ÿæ€ å­¦ä¹ è·¯å¾„ RuståŸºç¡€/åµŒå…¥å¼åŸºç¡€ RuståµŒå…¥å¼å®˜æ–¹bookï¼š è‹±æ–‡ï¼šhttps://docs.rust-embedded.org/book/intro/index.html ä¸­æ–‡ï¼šhttps://xxchang.github.io/book/ é€‰æ‹©MCUï¼Œåœ¨https://crates.io/ä¸Šæœç´¢å¯¹åº”HALåº“ï¼Œhttps://docs.rs/ä¸Šé¢æµè§ˆå¯¹åº”æ–‡æ¡£ Githubä¸Šé¢æŸ¥çœ‹HALåº“çš„æºä»£ç ï¼Œé˜…è¯»å¯¹åº”examples å®è·µ ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ3ï¼‰- åµŒå…¥å¼ç”Ÿæ€ç¯å¢ƒ \u0026 å­¦ä¹ è·¯å¾„","uri":"/posts/keyboard/3rust%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1jC4y1H7k8\nä»æ¨¡æ¿åˆ›å»ºRuståµŒå…¥å¼å·¥ç¨‹ 1 2 cargo install cargo-generate cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart ä¿®æ”¹Cargo.tomlï¼Œæ·»åŠ  hal ä¾èµ– 1 2 3 4 cortex-m = \"0.7.7\" cortex-m-rt = \"0.7.3\" panic-halt = \"0.2.0\" stm32h7xx-hal = { version = \"0.15.0\", features = [\"stm32h7b0\", \"rt\"] } ä¿®æ”¹.cargo/config.toml 1 2 3 4 5 6 7 8 9 [build] # Pick ONE of these default compilation targets # target = \"thumbv6m-none-eabi\" # Cortex-M0 and Cortex-M0+ # target = \"thumbv7m-none-eabi\" # Cortex-M3 # target = \"thumbv7em-none-eabi\" # Cortex-M4 and Cortex-M7 (no FPU) target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU) # target = \"thumbv8m.base-none-eabi\" # Cortex-M23 # target = \"thumbv8m.main-none-eabi\" # Cortex-M33 (no FPU) # target = \"thumbv8m.main-none-eabihf\" # Cortex-M33 (with FPU) ä¿®æ”¹main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #![no_main] #![no_std] use cortex_m_rt::entry; use panic_halt as _; use stm32h7xx_hal::{pac, prelude::*}; #[entry] fn main() -\u003e ! { // è·å–cortexæ ¸å¿ƒå¤–è®¾å’Œstm32h7çš„æ‰€æœ‰å¤–è®¾ let cp = cortex_m::Peripherals::take().unwrap(); let dp = pac::Peripherals::take().unwrap(); // Power è®¾ç½® let pwr = dp.PWR.constrain(); let pwrcfg = pwr.freeze(); // åˆå§‹åŒ–RCC let rcc = dp.RCC.constrain(); let ccdr = rcc.sys_ck(200.MHz()).freeze(pwrcfg, \u0026dp.SYSCFG); // è®¾ç½®LEDå¯¹åº”çš„GPIO let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE); let mut led = gpioe.pe3.into_push_pull_output(); // cortex-må·²ç»å®ç°å¥½äº†delayå‡½æ•°ï¼Œç›´æ¥æ‹¿åˆ°ï¼Œä¸‹é¢ä½¿ç”¨ let mut delay = cp.SYST.delay(ccdr.clocks); loop { // ç‚¹ç¯ led.toggle(); // å»¶æ—¶500ms delay.delay_ms(500_u16); } } æ„å»º 1 cargo build çƒ§å½• é¦–å…ˆä¿®æ”¹openocd.cfg\n1 2 3 source [find interface/cmsis-dap.cfg] source [find target/stm32h7x.cfg] 1 openocd -f openocd.cfg -c \"program target/thumbv7em-none-eabihf/debug/cargo-embedded-demo preverify verify reset exit 0x08000000\" ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ2ï¼‰- ç‚¹äº®å¼€å‘æ¿","uri":"/posts/keyboard/2%E4%BD%BF%E7%94%A8rust%E7%82%B9%E4%BA%AE%E5%BC%80%E5%8F%91%E6%9D%BF/"},{"categories":null,"content":" Bç«™è§†é¢‘æ•™ç¨‹é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV19c411Z7YF/\nå‰è¨€ ä½¿ç”¨Rustå¼€å‘åµŒå…¥å¼è½¯ä»¶çš„ä¼˜ç‚¹ï¼š\nç°ä»£çš„å¼€å‘ä½“éªŒ æ–¹ä¾¿çš„åŒ…ç®¡ç† ä¸°å¯Œçš„è¯­è¨€ç‰¹æ€§ï¼šIteratorã€async/awaitã€trait å¸¸è§MCUéƒ½æœ‰ç°æˆçš„HALå¯ç”¨ è¯´æ˜ æœ¬æ•™ç¨‹å‡è®¾ä½ å·²ç»å¯¹Rustæœ‰äº†åˆæ­¥çš„äº†è§£ï¼Œç†Ÿæ‚‰Rustçš„ç›¸å…³è¯­æ³•ã€é…ç½®ï¼›å¹¶ä¸”äº†è§£åµŒå…¥å¼ç¼–ç¨‹ï¼Œç†Ÿæ‚‰gccç³»åˆ—å¼€æºå·¥å…·é“¾\nâ—ï¸ ç°é˜¶æ®µï¼Œé™¤éä½ ä¸ªäººå…·æœ‰è¶…å¼ºçš„èƒ½åŠ›ï¼Œå¦åˆ™ï¼ŒåµŒå…¥å¼é¢†åŸŸçš„ç”Ÿäº§é¡¹ç›®ï¼Œè¯·ä¼˜å…ˆè€ƒè™‘ C\nç¯å¢ƒé…ç½® å®‰è£…Rust https://rustup.rs/\nå®‰è£…MCUå¯¹åº”çš„Target è‹±æ–‡ï¼šhttps://docs.rust-embedded.org/book/intro/install.html ä¸­æ–‡ï¼šhttps://xxchang.github.io/book/intro/install.html\n1 rustup target add thumbv7em-none-eabihf å®‰è£…OpenOCD MAC 1 brew install openocd Windows https://github.com/xpack-dev-tools/openocd-xpack/releases\nå®‰è£…VSCodeæ’ä»¶ rust-analyzer cortex-debug å¯é€‰ å®‰è£… probe-rs https://probe.rs/docs/getting-started/installation/\n1 cargo install probe-rs --features cli VSCodeæ’ä»¶ï¼š\nDebugger for probe-rs ","description":"","tags":["rust"],"title":"RuståµŒå…¥å¼æ•™ç¨‹ï¼ˆ1ï¼‰- å‰è¨€\u0026ç¯å¢ƒé…ç½®","uri":"/posts/keyboard/1%E5%89%8D%E8%A8%80-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Why? Rustä½œä¸ºä¸€é—¨æ–°å…´è¯­è¨€ï¼Œå…¶å®‰å…¨ã€å¯é ã€è¿è¡Œæ•ˆç‡é«˜ç­‰ç‰¹ç‚¹è®©å®ƒæˆä¸ºä¸€é—¨éå¸¸é€‚åˆåµŒå…¥å¼å¼€å‘çš„è¯­è¨€ã€‚æœ¬æ–‡ä¸»è¦ä»‹ç»å¦‚ä½•æ­å»ºRuståµŒå…¥å¼å¼€å‘ç¯å¢ƒï¼Œç„¶åä½¿ç”¨stm32h7å¼€å‘æ¿ç‚¹ä¸ªç¯ã€‚\nåœ¨åµŒå…¥å¼å¼€å‘é¢†åŸŸï¼ŒCè¯­è¨€çš„åœ°ä½æ˜¯æ— æ³•è¢«æ’¼åŠ¨çš„ï¼ˆè‡³å°‘åœ¨2023å¹´æ˜¯è¿™æ ·ï¼‰ã€‚ç”¨Rustå¼€å‘åµŒå…¥å¼ç›®å‰å°±ä¸¤ä¸ªç›®çš„ï¼š\nç©\næˆ˜æœªæ¥ :)\né€‚ç”¨å¯¹è±¡ å¦‚æœä½ æ²¡æœ‰æ¥è§¦è¿‡åµŒå…¥å¼ç¼–ç¨‹ï¼Œæˆ–è€…å®Œå…¨ä¸æ‡‚gccç³»åˆ—çš„å¼€æºå·¥å…·é“¾ï¼Œæˆ–è€…å®Œå…¨æ²¡æœ‰æ¥è§¦è¿‡Rustï¼Œé‚£ä¹ˆå»ºè®®å…ˆäº†è§£ä¸€ä¸‹ç›¸å…³çš„èƒŒæ™¯çŸ¥è¯†ã€‚\nOKï¼ŒLet's GO!\næ­å»ºRustå¼€å‘ç¯å¢ƒ å®‰è£…Rust é¦–å…ˆç¬¬ä¸€æ­¥æ˜¯å®‰è£…Rustçš„å¼€å‘ç¯å¢ƒã€‚Rustå¼€å‘ç¯å¢ƒçš„å®‰è£…éå¸¸ç®€å•ï¼Œå‚è€ƒhttps://rustup.rs/ï¼Œä¸€æ¡å‘½ä»¤å³å¯ï¼š\n1 curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh å®‰è£…ä¹‹åï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æŸ¥çœ‹å½“å‰çš„Rustç‰ˆæœ¬ï¼š\n1 2 3 cargo --version rustup --version rustc --version è¿™é‡Œï¼Œå‡ ä¸ªå·¥å…·ç®€å•äº†è§£ä¸€ä¸‹ï¼š\ncargoï¼šæ˜¯Rustçš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨ï¼Œå®‰è£…ã€é…ç½®ä¸‰æ–¹åŒ…ã€é¡¹ç›®æ„å»ºä½ éƒ½éœ€è¦ç”¨åˆ°ä»– rustcï¼šRustç¼–è¯‘å™¨ï¼Œç›¸å½“äºgcc rustupï¼šRustå·¥å…·é“¾ç®¡ç†å·¥å…·ï¼Œæ¯”å¦‚æ›´æ–°Rustç‰ˆæœ¬ã€æ·»åŠ targetç­‰ï¼Œéƒ½å¯ä»¥ä½¿ç”¨rustup é»˜è®¤æƒ…å†µä¸‹ï¼Œå®‰è£…å®ŒRustä¹‹åï¼Œç¼–è¯‘çš„ç›®æ ‡æ¶æ„éƒ½æ˜¯æœ¬æœºçš„æ¶æ„ã€‚ç”±äºæˆ‘ä»¬æ˜¯åµŒå…¥å¼å¼€å‘ï¼Œå› æ­¤éœ€è¦äº¤å‰ç¼–è¯‘åˆ°MCUå¯¹åº”çš„æ¶æ„ï¼Œä»¥stm32h7ä¸ºä¾‹ï¼Œå®ƒæ˜¯ARM Cortex-mç³»åˆ—çš„MCUï¼Œå…¶å¯¹åº”çš„targetæ˜¯ï¼šthumbv7em-none-eabihfã€‚å¯¹äºcortex-mç³»åˆ—çš„MCUæ¥è¯´ï¼Œæ¯ç§æ ¸å¿ƒå¯¹åº”çš„targetå¯ä»¥å‚è€ƒï¼šhttps://logiase.github.io/The-Embedded-Rust-Book-CN/intro/install.htmlã€‚\næˆ‘ä»¬ä½¿ç”¨rustupæ¥æ·»åŠ å¯¹åº”çš„äº¤å‰ç¼–è¯‘æ”¯æŒï¼š\n1 rustup target add thumbv7em-none-eabihf è¿è¡Œå®Œè¿™ä¸ªå‘½ä»¤ä¹‹åï¼Œä½ æœ¬åœ°çš„Rustå·²ç»å…·å¤‡äº†ç¼–è¯‘å¯¹åº”MCUç¨‹åºçš„èƒ½åŠ›ã€‚\nå®‰è£…åµŒå…¥å¼ç›¸å…³å·¥å…·é“¾ ä½¿ç”¨Rustå¼€å‘åµŒå…¥å¼ä»£ç ï¼Œè¿˜éœ€è¦ä¸€ç³»åˆ—å…¶ä»–çš„å·¥å…·é“¾ï¼Œæ¯”å¦‚openocdã€gdbç­‰ç­‰ã€‚è¿™äº›å·¥å…·çš„å®‰è£…å’Œä½¿ç”¨Cè¯­è¨€æ—¶å¹¶æ²¡æœ‰å¤ªå¤§çš„åŒºåˆ«ï¼ŒåŒæ ·å¯ä»¥å‚è€ƒï¼šhttps://logiase.github.io/The-Embedded-Rust-Book-CN/intro/install.htmlï¼Œå·¦ä¾§é€‰æ‹©ä½ å½“å‰çš„PCå¹³å°ï¼ŒæŒ‰ç…§è¯´æ˜å®‰è£…å³å¯ã€‚æˆ‘ä½¿ç”¨çš„æ˜¯MacOSï¼Œå®‰è£…ç›¸å…³å·¥å…·éå¸¸ç®€å•ï¼Œä½¿ç”¨homebrewå®‰è£…å³å¯ï¼š\n1 2 3 4 5 6 7 8 $ # GDB $ brew install armmbed/formulae/arm-none-eabi-gcc $ # OpenOCD $ brew install openocd $ # QEMU $ brew install qemu é…ç½®IDE æˆ‘ä»¬ä½¿ç”¨VSCodeæ¥å¼€å‘Rustã€‚VSCodeçš„å®‰è£…å°±ä¸å†åºŸè¯äº†ï¼Œè¿™é‡Œç€é‡è®²ä¸€ä¸‹éœ€è¦å®‰è£…çš„æ’ä»¶ï¼š\nrust-analyzerï¼šä½¿ç”¨VSCodeå¼€å‘Rustå¿…å¤‡ cortex-debugï¼šè°ƒè¯•ã€debugåµŒå…¥å¼ç¨‹åº cratesï¼šæå‡ç¼–è¾‘Cargo.tomlçš„ä½“éªŒï¼Œè¾…åŠ©åŒ…ç®¡ç† ç›´æ¥VSCodeæ’ä»¶å¸‚åœºæœç´¢å®‰è£…å³å¯ã€‚\nä¸€äº›èƒŒæ™¯çŸ¥è¯† åœ¨é…ç½®å®Œå¼€å‘ç¯å¢ƒä¹‹åï¼Œæˆ‘ä»¬ç¼“ä¸€ç¼“ï¼Œç®€å•äº†è§£ä¸€ä¸‹ä½¿ç”¨Rustå¼€å‘åµŒå…¥å¼å·¥ç¨‹çš„ä¸€äº›èƒŒæ™¯çŸ¥è¯†ã€‚\nå’ŒCè¯­è¨€ä¸åŒï¼ŒRustå®˜æ–¹æä¾›äº†ä¸€å¥—æ ‡å‡†çš„ç¡¬ä»¶æŠ½è±¡å±‚embedded-halï¼Œå‡ ä¹æ‰€æœ‰çš„MCUå‚å®¶éƒ½ä¼šåŸºäºè¿™å¥—halæ¥å¼€å‘è‡ªå·±çš„sdkã€‚ å„ä¸ªå‚å•†çš„ç›¸å…³SDKå‘½åéƒ½éµå¾ªxxx-rsçš„æ–¹å¼ï¼Œæ¯”å¦‚stm32å°±æ˜¯stm32-rsï¼ŒESPæ˜¯esp-rsï¼Œrp2040æ˜¯rp-rsã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦æ‰¾ç›¸å…³çš„SDKï¼Œå°±å»å¯¹åº”çš„githubç»„ä¸‹é¢å»æ‰¾å°±å¥½äº†ã€‚ åœ¨æ­£å¼å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šç›´æ¥å’Œembedded-halæ‰“äº¤é“ï¼Œè€Œæ˜¯ä½¿ç”¨å„ä¸ªå‚å®¶MCUå¯¹åº”çš„ä¸Šå±‚halå®ç°ã€‚æˆ‘ä»¬ä½¿ç”¨çš„MCUæ˜¯stm32h7b0ï¼Œå› æ­¤ï¼Œç›´æ¥å»stm32-rsä¸‹é¢æœç´¢stm32h7ï¼Œå°±èƒ½çœ‹åˆ°å¯¹åº”çš„halåº“stm32h7xx-haläº†ã€‚å½“ç„¶ä¹Ÿå¯ä»¥å»crates.ioæœç´¢ï¼Œä¸€æ ·çš„ã€‚ä½¿ç”¨å¯¹åº”çš„halåº“ä¹Ÿéå¸¸ç®€å•ï¼Œåœ¨Cargo.tomlçš„[dependencies]ä¸‹é¢æ·»åŠ ä¸€è¡Œ 1 stm32h7xx-hal = { version = \"0.14.0\", features = [\"stm32h7b0\", \"rt\", \"log-rtt\"] } å³å¯ã€‚ä¸Šé¢çš„é…ç½®è¯´æ˜æˆ‘ä»¬ä½¿ç”¨çš„halåº“ç‰ˆæœ¬æ˜¯0.14.0ï¼Œæˆ‘ä»¬çš„èŠ¯ç‰‡æ˜¯stm32h7b0ï¼Œå¹¶ä¸”å¼€å¯äº†log-rttç‰¹æ€§ã€‚featuresä¸­çš„rtä»£è¡¨ç€ runtimeï¼Œä¸€èˆ¬éƒ½é»˜è®¤åŠ ä¸Šã€‚\nåˆ›å»ºRuståµŒå…¥å¼å·¥ç¨‹ åœ¨äº†è§£äº†ç›¸å…³èƒŒæ™¯çŸ¥è¯†ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥å»åˆ›å»ºRuståµŒå…¥å¼å·¥ç¨‹äº†ã€‚\næ–¹æ³•1 ç›´æ¥ä½¿ç”¨å®˜æ–¹æ¨¡æ¿åˆ›å»ºï¼Œä¸€æ¡å‘½ä»¤å³å¯ï¼š\n1 2 # ä½¿ç”¨ rust å®˜æ–¹çš„ cortex-m-quickstart ä½œä¸ºæˆ‘ä»¬çš„é¡¹ç›®æ¨¡æ¿ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart æ–¹æ³•2 ä¸Šé¢çš„åˆ›å»ºæ–¹å¼ä¼šé»˜è®¤åˆ›å»ºä¸€ä¸ªQEMUæ¨¡æ‹Ÿå™¨å·¥ç¨‹ï¼Œå¦‚æœä½ å¯¹RuståµŒå…¥å¼å¼€å‘ä¸ç†Ÿæ‚‰ï¼ŒæŠŠè¿™ä¸ªå·¥ç¨‹æ”¹æˆä½ çš„ç›®æ ‡æ¿çš„ç¨‹åºå¯èƒ½ä¼šæœ‰äº›éº»çƒ¦ã€‚æ‰€ä»¥ä¸‹é¢æˆ‘ä»¬å°±ä»0å¼€å§‹ï¼Œä¸€æ­¥ä¸€æ­¥åœ°æ­å»ºæ•´ä¸ªRuståµŒå…¥å¼å·¥ç¨‹ï¼Œåœ¨èµ°å®Œæ•´ä¸ªæµç¨‹ä¹‹åï¼Œä½ å°±å¯ä»¥äº†è§£æ¯ä¸€ä¸ªæ–‡ä»¶çš„å…·ä½“åŠŸèƒ½ï¼Œåé¢ç”¨é¡¹ç›®æ¨¡æ¿ä¸€é”®åˆ›å»ºå·¥ç¨‹æ”¹æ”¹å°±è¡Œäº†ã€‚ä¸‹é¢è¯¦ç»†æŒ‰æ­¥éª¤ä»‹ç»ï¼š\n1. åˆ›å»ºç©ºçš„Rustå·¥ç¨‹ è¿™ä¸€æ­¥éå¸¸ç®€å•ï¼Œä½¿ç”¨cargoåˆ›å»ºå³å¯\n1 cargo new project-name --bin --edition 2021 --binè¡¨ç¤ºåˆ›å»ºçš„æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºçš„å·¥ç¨‹ï¼ˆè€Œä¸æ˜¯ä¸€ä¸ªåº“ï¼‰ï¼Œ--editionè¡¨ç¤ºä½¿ç”¨2021æ ‡å‡†ï¼ˆä¹Ÿæ˜¯æœ€æ–°ç‰ˆæœ¬ï¼‰ã€‚ä½¿ç”¨VSCodeæ‰“å¼€å·¥ç¨‹ï¼Œé»˜è®¤æ˜¯ä¸€ä¸ªæœ¬æœºçš„HelloWorldå·¥ç¨‹ï¼Œå‘½ä»¤è¡Œè¿è¡Œcargo runï¼Œè¿è¡Œã€‚\n2. é…ç½®.cargo/config.toml cargo newé»˜è®¤ç”Ÿæˆçš„å·¥ç¨‹çš„targetæ˜¯æœ¬æœºçš„æ¶æ„ï¼Œæˆ‘ä»¬éœ€è¦æŠŠtargetæ”¹æˆæˆ‘ä»¬çš„ç›®æ ‡MCUã€‚\nVSCodeæ ¹ç›®å½•ä¸‹åˆ›å»º.cargo/config.tomlæ–‡ä»¶ï¼Œå¹¶ä¸”å¡«å…¥ä»¥ä¸‹çš„å†…å®¹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [target.thumbv7m-none-eabi] # uncomment this to make `cargo run` execute programs on QEMU # runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel\" [target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))'] # uncomment ONE of these three option to make `cargo run` start a GDB session # which option to pick depends on your system runner = \"arm-none-eabi-gdb -q -x openocd.gdb\" # runner = \"gdb-multiarch -q -x openocd.gdb\" # runner = \"gdb -q -x openocd.gdb\" rustflags = [ # Previously, the linker arguments --nmagic and -Tlink.x were set here. # They are now set by build.rs instead. The linker argument can still # only be set here, if a custom linker is needed. # By default, the LLD linker is used, which is shipped with the Rust # toolchain. If you run into problems with LLD, you can switch to the # GNU linker by uncommenting this line: # \"-C\", \"linker=arm-none-eabi-ld\", # If you need to link to pre-compiled C libraries provided by a C toolchain # use GCC as the linker by uncommenting the three lines below: # \"-C\", \"linker=arm-none-eabi-gcc\", # \"-C\", \"link-arg=-Wl,-Tlink.x\", # \"-C\", \"link-arg=-nostartfiles\", ] [build] # Pick ONE of these default compilation targets # target = \"thumbv6m-none-eabi\" # Cortex-M0 and Cortex-M0+ # target = \"thumbv7m-none-eabi\" # Cortex-M3 # target = \"thumbv7em-none-eabi\" # Cortex-M4 and Cortex-M7 (no FPU) target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU) # target = \"thumbv8m.base-none-eabi\" # Cortex-M23 # target = \"thumbv8m.main-none-eabi\" # Cortex-M33 (no FPU) # target = \"thumbv8m.main-none-eabihf\" # Cortex-M33 (with FPU) æ¯ä¸€ä¸ªé€‰é¡¹æ³¨é‡Šé‡Œé¢å·²ç»è¯´çš„å¾ˆæ˜ç™½äº†ï¼Œæ³¨æ„æ ¸å¿ƒæ˜¯[build]ä¸‹çš„targetï¼Œè¿™é‡Œå°±é…ç½®äº†ä½¿ç”¨cargo buildæ„å»ºå·¥ç¨‹çš„æ—¶å€™ï¼Œé»˜è®¤çš„targetã€‚\n3. ä½¿ç”¨rust-toolchain.tomlé…ç½®é»˜è®¤å·¥å…·é“¾ åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨æœ€æ–°çš„rustçš„featureï¼Œè¿™äº›featureå¾€å¾€åªåœ¨nightlyç‰ˆæœ¬çš„rustä¸­ç”Ÿæ•ˆã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åœ¨é¡¹ç›®çš„æ ¹ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªrust-toolchain.tomlæ–‡ä»¶ï¼Œæ¥é…ç½®å½“å‰é¡¹ç›®ä½¿ç”¨çš„Rustå·¥å…·é“¾ï¼š\n1 2 3 [toolchain] channel = \"nightly\" components = [ \"rust-src\", \"rustfmt\", \"llvm-tools\" ] è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº†nightlyç‰ˆæœ¬çš„Rustï¼ŒåŒæ—¶æ¿€æ´»äº†ä¸‹é¢ä¸‰ä¸ªcomponentã€‚\n4. åˆ›å»ºbuild.rsæ„å»ºè„šæœ¬ build.rsæ˜¯Rustçš„ä¸€ä¸ªç‰¹æ®Šæ–‡ä»¶ï¼Œå®ƒä¸»è¦ç”¨äºé…ç½®æ„å»ºçš„æµç¨‹å’Œç›¸å…³çš„å‚æ•°ã€‚å¯¹æ¯”gccï¼Œå¯ä»¥ç†è§£æˆCFLAGSã€compile optionsè¿™äº›ç©æ„éƒ½å¯ä»¥åœ¨è¿™é‡Œé…ç½®ã€‚å…¶åŠŸèƒ½å¯ä»¥å‚è€ƒï¼šhttps://doc.rust-lang.org/cargo/reference/build-scripts.htmlã€‚\nåŒæ—¶ï¼Œå¦‚æœä½ è¯»çš„æ¯”è¾ƒä»”ç»†ï¼Œå¯ä»¥å‘ç°åœ¨ä¸Šé¢çš„.cargo/config.tomlä¸­ï¼Œæœ‰ä¸€ä¸ªrustflagså­—æ®µï¼Œä¹Ÿå¯ä»¥é…ç½®ç›¸å…³çš„é€‰é¡¹ã€‚è¿™ä¸¤ä¸ªåœ°æ–¹çš„é…ç½®éƒ½å¯ä»¥ç”Ÿæ•ˆã€‚\né’ˆå¯¹cortex-mçš„é»˜è®¤build.rså¦‚ä¸‹ï¼Œæš‚æ—¶å¯ä»¥ç›´æ¥å¤åˆ¶ä¸€ä»½åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //! This build script copies the `memory.x` file from the crate root into //! a directory where the linker can always find it at build time. //! For many projects this is optional, as the linker always searches the //! project root directory -- wherever `Cargo.toml` is. However, if you //! are using a workspace or have a more complicated build setup, this //! build script becomes required. Additionally, by requesting that //! Cargo re-run the build script whenever `memory.x` is changed, //! updating `memory.x` ensures a rebuild of the application with the //! new memory settings. //! //! The build script also sets the linker flags to tell it which link script to use. use std::env; use std::fs::File; use std::io::Write; use std::path::PathBuf; fn main() { // Put `memory.x` in our output directory and ensure it's // on the linker search path. let out = \u0026PathBuf::from(env::var_os(\"OUT_DIR\").unwrap()); File::create(out.join(\"memory.x\")) .unwrap() .write_all(include_bytes!(\"memory.x\")) .unwrap(); println!(\"cargo:rustc-link-search={}\", out.display()); // By default, Cargo will re-run a build script whenever // any file in the project changes. By specifying `memory.x` // here, we ensure the build script is only re-run when // `memory.x` is changed. println!(\"cargo:rerun-if-changed=memory.x\"); // Specify linker arguments. // `--nmagic` is required if memory section addresses are not aligned to 0x10000, // for example the FLASH and RAM sections in your `memory.x`. // See https://github.com/rust-embedded/cortex-m-quickstart/pull/95 println!(\"cargo:rustc-link-arg=--nmagic\"); // Set the linker script to the one provided by cortex-m-rt. println!(\"cargo:rustc-link-arg=-Tlink.x\"); } 5. åˆ›å»ºé“¾æ¥è„šæœ¬memory.x Rustå’ŒCè¯­è¨€ä¸€æ ·ï¼Œåœ¨ç¼–è¯‘ä¹‹åéƒ½éœ€è¦ä¸€ä¸ªé“¾æ¥è„šæœ¬æŠŠæ‰€æœ‰çš„.oæ–‡ä»¶é“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¿™ä¸ªé“¾æ¥è„šæœ¬å°±æ˜¯memory.xã€‚Rustçš„é“¾æ¥è„šæœ¬å’Œgccçš„ldæ–‡ä»¶ä¸€æ¨¡ä¸€æ ·ã€‚å¦‚æœä½ ä¸æƒ³è‡ªå·±å†™ï¼Œå¯ä»¥ä»è‡ªå·±ä¹‹å‰çš„gccå·¥ç¨‹ä¸­ç›´æ¥æŠŠldæ–‡ä»¶çš„å†…å®¹å¤åˆ¶è¿‡æ¥ï¼Œæˆ–è€…ç›´æ¥å‚è€ƒä½ å¼€å‘æ¿èŠ¯ç‰‡å¯¹åº”çš„halåº“çš„é»˜è®¤é“¾æ¥è„šæœ¬ã€‚æ¯”å¦‚æˆ‘ä½¿ç”¨çš„stm32h7ï¼Œé‚£ä¹ˆå°±åœ¨è¿™ä¸ªä»£ç åº“é‡Œé¢æ‰¾ï¼šhttps://github.com/stm32-rs/stm32h7xx-halã€‚\n6. é…ç½®Cargo.toml Kï¼Œç°åœ¨ä¸€ä¸ªåŸºç¡€çš„RuståµŒå…¥å¼å¼€å‘ç¯å¢ƒå·²ç»æ­å»ºå®Œæˆäº†ã€‚æ•´ä¸ªå·¥ç¨‹çš„ç»“æ„å¤§æ¦‚é•¿è¿™æ ·å­ï¼š\n1 2 3 4 5 6 7 .cargo - config.toml src - main.rs build.rs Cargo.toml rust-toolchain.toml åœ¨ä¸Šé¢è¿™äº›å¤–å›´çš„ä¸œè¥¿é…ç½®å¥½äº†ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥é…ç½®Cargo.tomläº†ã€‚é€šè¿‡Cargoä½¿ç”¨ä¸‰æ–¹åŒ…éå¸¸ç®€å•ï¼Œåœ¨Cargo.tomlçš„[dependencies]ä¸‹é¢ï¼ŒæŠŠä½ æƒ³è¦ç”¨çš„ä¸‰æ–¹åŒ…åŠ ä¸Šï¼Œå°±å¯ä»¥äº†ï¼š\n1 2 3 4 5 [dependencies] cortex-m = \"0.7.7\" cortex-m-rt = \"0.7.3\" stm32h7xx-hal = {version = \"0.14.0\", features = [\"stm32h7b0\", \"rt\", \"log-rtt\"]} panic-halt = \"0.2.0\" ä½œä¸ºæœ€åŸºç¡€çš„ç¨‹åºï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸Šé¢å››ä¸ªcrateï¼Œcortex-mç”¨æ¥æ“ä½œcortex-mæ ¸å¿ƒï¼Œcortex-m-rtæ˜¯ARM Cortex-mæ ¸çš„è¿è¡Œæ—¶ï¼Œstm32h7xx-halæ˜¯æˆ‘ä»¬ç”¨çš„èŠ¯ç‰‡çš„halåº“ï¼Œpanic-haltå¯ä»¥ç†è§£æˆæ˜¯hardfaultå¤„ç†ç¨‹åºï¼Œä¼šç›´æ¥haltæš‚åœç¨‹åºã€‚å¦‚æœä¸åŠ è¿™ä¸ªï¼Œå°±éœ€è¦æ‰‹åŠ¨å®ç°hardfaultå¤„ç†ä»£ç ã€‚\n7. ä¿®æ”¹main.rs åœ¨é…ç½®å®Œä¸‰æ–¹åŒ…ä¹‹åï¼Œå°±å¯ä»¥ä¿®æ”¹æˆ‘ä»¬çš„ä¸»ç¨‹åºmain.rsäº†ã€‚ä¸‹é¢å…ˆæŠŠä¸»ç¨‹åºç²˜è´´è¿‡æ¥ï¼Œåé¢é€è¡Œè®²è§£ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 #![no_main] #![no_std] use panic_halt as _; use cortex_m_rt::entry; #[entry] fn main() -\u003e ! { loop { panic!(\"hello world!\"); } } é¦–å…ˆæ˜¯ä¸¤ä¸ªå£°æ˜#![no_main]å’Œ#![no_std]ï¼Œè¿™ä¸¤å¥è¯è¯´æ˜æˆ‘ä»¬çš„rustç¨‹åºæ²¡æœ‰é»˜è®¤çš„mainå‡½æ•°ï¼Œä¹Ÿä¸ä½¿ç”¨stdåº“ã€‚Rustä¸­é»˜è®¤çš„mainå‡½æ•°æ˜¯stdæ ‡å‡†åº“ä¸­çš„å‡½æ•°ï¼Œç”±äºæˆ‘ä»¬çš„targetæ˜¯åµŒå…¥å¼MCUï¼Œå› æ­¤æˆ‘ä»¬é»˜è®¤ä¸ä½¿ç”¨stdæ ‡å‡†åº“ï¼Œé»˜è®¤çš„mainå‡½æ•°ä¹Ÿä¸ç”¨äº†ã€‚\nä¸‹é¢ä¸€è¡Œuse panic_halt as _;è¡¨ç¤ºæˆ‘ä»¬ä½¿ç”¨panic-haltåŒ…æä¾›çš„é”™è¯¯å¤„ç†ã€‚\nä¸Šé¢è¯´æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨çš„æ ‡å‡†åº“çš„mainå‡½æ•°ï¼Œé‚£æˆ‘ä»¬çš„ç¨‹åºå…¥å£åœ¨å“ªé‡Œå‘¢ï¼Ÿçœ‹ä¸‹é¢ä¸€è¡Œuse cortex_m_rt::entryï¼Œæ„æ€å°±æ˜¯æˆ‘ä»¬ä¼šä½¿ç”¨cortex-m-rtåŒ…æä¾›çš„ä¸»å‡½æ•°å…¥å£ï¼Œå¹¶ä¸”åœ¨å¯¹åº”çš„å‡½æ•°å…¥å£ç”¨#[entry]æ ‡è¯†ã€‚ä¸‹é¢å°±æ˜¯æˆ‘ä»¬çš„ä¸»å‡½æ•°äº†ï¼Œæˆ‘åœ¨ä¸»å‡½æ•°é‡Œé¢å†™äº†ä¸€ä¸ªå¾ªç¯ï¼Œå¹¶ä¸”è°ƒç”¨äº†panic!ï¼Œè®©ç¨‹åºpanicï¼ŒåŒæ—¶è¾“å‡ºhello worldã€‚\n8. ç¼–è¯‘ï¼ åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬æ•´ä¸ªRustçš„æœ€ç®€å•çš„åµŒå…¥å¼å·¥ç¨‹å°±å·²ç»æ­å»ºå®Œæ¯•äº†ã€‚æ¥ä¸‹æ¥ï¼Œå°±ç¼–è¯‘æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªRuståµŒå…¥å¼ç¨‹åºï¼š\n1 2 # ç¼–è¯‘ç¨‹åº cargo build å› ä¸ºæˆ‘ä»¬å·²ç»åœ¨.cargo/config.tomlé‡Œé¢é…ç½®å¥½äº†targetï¼Œæ‰€ä»¥cargo buildå‘½ä»¤çš„é»˜è®¤targetå°±ä¼šæ˜¯æˆ‘ä»¬çš„MCUã€‚å¦‚æœä¸€åˆ‡æ­£å¸¸çš„è¯ï¼Œå°±å¯ä»¥åœ¨target/thumbv7em-none-eabihf/debugç›®å½•ä¸‹çœ‹åˆ°ä½ çš„å›ºä»¶äº†ï¼éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›ºä»¶çš„æ–‡ä»¶åå’ŒCargo.tomlä¸­çš„nameå®Œå…¨ä¸€è‡´ï¼š\n9. Hello Worldç¨‹åº åˆ°ä¸Šä¸€æ­¥ä¸ºæ­¢ï¼Œä½ å·²ç»å¯ä»¥ä½¿ç”¨å†™å‡ºå¹¶ä¸”ç¼–è¯‘ç¬¬ä¸€ä¸ªå›ºä»¶ç¨‹åºäº†ã€‚ä½†æ˜¯è¿™ä¸ªç¨‹åºä¼šç›´æ¥panicã€‚ä¸‹é¢æˆ‘ä»¬å°±å†å†™ä¸€äº›ä»£ç ï¼Œå®Œæˆç¬¬ä¸€ä¸ªHello Worldç¨‹åºï¼Œå¹¶ä¸”é€šè¿‡RTTæ‰“å°å‡ºæ¥ã€‚\né¦–å…ˆï¼Œåœ¨Cargo.tomlä¸­æ·»åŠ RTTç›¸å…³ä¾èµ–ï¼š\n1 2 3 rtt-target = \"0.4.0\" panic-rtt-target = { version = \"0.1.2\", features = [\"cortex-m\"] } log = \"0.4.19\" ç¬¬ä¸€ä¸ªrtt-targetè®©MCUå¯ä»¥å®ç°RTTè¾“å‡ºï¼Œç¬¬äºŒä¸ªpanic-rtt-targetç”¨æ¥æ›¿ä»£panic-haltï¼Œä¹Ÿå°±æ˜¯åœ¨panicçš„æ—¶å€™ï¼Œé€šè¿‡rtt-targetæ¥è¾“å‡ºç›¸å…³ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ç›´æ¥åœæ­¢MCUè¿è¡Œã€‚ç¬¬ä¸‰ä¸ªæ˜¯Rustçš„logåŒ…ï¼Œæä¾›äº†loggingç›¸å…³çš„traitã€‚\nç„¶åï¼Œä¿®æ”¹main.rsä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #![no_main] #![no_std] use cortex_m_rt::entry; use panic_rtt_target as _; use rtt_target::{rprintln, rtt_init_print}; use stm32h7xx_hal::{pac, prelude::*}; #[entry] fn main() -\u003e ! { // åˆå§‹åŒ–RTT rtt_init_print!(); // è·å–cortexæ ¸å¿ƒå¤–è®¾å’Œstm32h7çš„æ‰€æœ‰å¤–è®¾ let cp = cortex_m::Peripherals::take().unwrap(); let dp = pac::Peripherals::take().unwrap(); // Power è®¾ç½® let pwr = dp.PWR.constrain(); let pwrcfg = pwr.freeze(); // åˆå§‹åŒ–RCC let rcc = dp.RCC.constrain(); let ccdr = rcc.sys_ck(200.MHz()).freeze(pwrcfg, \u0026dp.SYSCFG); // è®¾ç½®LEDå¯¹åº”çš„GPIO let gpioe = dp.GPIOE.split(ccdr.peripheral.GPIOE); let mut led = gpioe.pe3.into_push_pull_output(); // cortex-må·²ç»å®ç°å¥½äº†delayå‡½æ•°ï¼Œç›´æ¥æ‹¿åˆ°ï¼Œä¸‹é¢ä½¿ç”¨ let mut delay = cp.SYST.delay(ccdr.clocks); loop { // ç‚¹ç¯å¹¶ä¸”è¾“å‡ºRTTæ—¥å¿— led.toggle(); rprintln!(\"Hello World!\"); // å»¶æ—¶500ms delay.delay_ms(500_u16); } } ç®€å•è§£é‡Šä¸€ä¸‹mainå‡½æ•°ã€‚é¦–å…ˆï¼Œä½¿ç”¨rtt_init_print!()åˆå§‹åŒ–RTTåŠŸèƒ½ã€‚ç„¶åï¼Œé€šè¿‡cortex_må’Œstm32h7xxçš„PACï¼Œè·å–cortexæ ¸çš„å¤–è®¾å¯¹è±¡è¿˜æœ‰stm32h7çš„å¤–è®¾å¯¹è±¡ã€‚åé¢å°±æ˜¯åˆå§‹åŒ–PWRå’ŒRCCï¼Œå¹¶ä¸”è®¾ç½®ä¸»é¢‘ä¸º200MHZã€‚æ³¨æ„åœ¨è¿™é‡Œï¼Œæ¯ä¸€ä¸ªè®¾ç½®æœ€åéƒ½éœ€è¦è°ƒç”¨freezeå‡½æ•°ï¼Œè¡¨ç¤ºæŠŠæ‰€æœ‰çš„è®¾ç½®å†™å…¥å¯¹åº”å¯„å­˜å™¨ã€‚å¦‚æœä½ çŸ¥é“builderæ¨¡å¼ï¼Œé‚£ä½ åº”è¯¥å¯¹è¿™ç§æ“ä½œå¾ˆç†Ÿæ‚‰ã€‚\næ¥ç€ï¼Œå°±ä»MCUå¤–è®¾ä¸­æ‹¿åˆ°GPIOï¼Œå¹¶ä¸”è®¾ç½®LEDå¯¹åº”çš„GPIOçŠ¶æ€ã€‚æœ€åï¼Œåœ¨ä¸»å¾ªç¯é‡Œé¢ç‚¹ç¯å¹¶ä¸”ä½¿ç”¨RTTæ‰“å°ã€‚\nè¿è¡Œcargo buildï¼Œç¼–è¯‘ä¸€åˆ‡OKã€‚\nDebug RuståµŒå…¥å¼ç¨‹åº ç¼–è¯‘å¥½äº†ç¬¬ä¸€ä¸ªå›ºä»¶ä¹‹åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯çƒ§å½• \u0026 è°ƒè¯•äº†ã€‚å®è¯å®è¯´ï¼Œçƒ§å½•å’Œè°ƒè¯•å’ŒRustæœ¬èº«å…³ç³»ä¸å¤ªå¤§ï¼Œä½¿ç”¨çš„è¿˜æ˜¯openocd é‚£ä¸€å¥—ã€‚è¿™é‡Œå°±ä¸»è¦å†™ä¸€ä¸‹å¦‚ä½•åœ¨VSCodeä¸‹é¢è°ƒè¯•RuståµŒå…¥å¼ç¨‹åºã€‚\né¦–å…ˆï¼Œè¿˜æ˜¯å®‰è£…cortex-debugæ’ä»¶ï¼Œå¹¶ä¸”é…ç½®.vscode/launch.jsonã€‚å…·ä½“å¯ä»¥å‚è€ƒæˆ‘ä¹‹å‰çš„blogï¼šä½¿ç”¨OpenOCD+VSCodeä¸€é”®çƒ§å½•Boot+Appåˆ°å†…ç½®+å¤–ç½®flashçš„VSCodeé…ç½®éƒ¨åˆ†å³å¯ã€‚è¿™é‡Œæˆ‘ä¹Ÿè´´ä¸€ä¸‹æˆ‘ä½¿ç”¨çš„launch.jsonï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Cortex Debug\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"${workspaceFolder}/target/thumbv7em-none-eabihf/debug/ä½ çš„å›ºä»¶åç§°\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"servertype\": \"openocd\", \"showDevDebugOutput\": \"parsed\", \"runToEntryPoint\": \"main\", \"device\": \"stlink\", \"preLaunchTask\": \"flash\", \"configFiles\": [ \"openocd.cfg\" ], \"svdFile\": \"STM32H7B0x.svd\", \"rttConfig\": { \"enabled\": true, \"address\": \"auto\", \"clearSearch\": false, \"polling_interval\": 20, \"rtt_start_retry\": 2000, \"decoders\": [ { \"label\": \"RTT channel 0\", \"port\": 0, \"type\": \"console\" } ] }, } ] } éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œexecutableéœ€è¦æ”¹æˆä½ çš„å›ºä»¶è·¯å¾„ï¼Œç„¶åé…ç½®å¥½å¯¹åº”çš„openocd.cfgå’Œsvdæ–‡ä»¶å³å¯ã€‚\nå¦å¤–ï¼Œè¿™é‡Œåªæ˜¯å¯åŠ¨è°ƒè¯•ï¼Œæˆ‘é…ç½®äº†ä¸€ä¸ªpreLaunchTaskï¼Œä¼šåœ¨æ¯ä¸€æ¬¡è°ƒè¯•ä¹‹å‰è‡ªåŠ¨çƒ§å½•å›ºä»¶ã€‚è¿™ä¸ªtaskæ˜¯é…ç½®åœ¨.vscode/tasks.jsonä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Cargo Build (debug)\", \"type\": \"process\", \"command\": \"cargo\", \"args\": [\"build\"], \"problemMatcher\": [ \"$rustc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"flash\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"openocd -f openocd.cfg -c \\\"program target/thumbv7em-none-eabihf/debug/ä½ çš„å›ºä»¶åç§° preverify verify reset exit\\\"\", \"dependsOn\": [ \"Cargo Build (debug)\" ], \"dependsOrder\": \"sequence\" }, ] } éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„çƒ§å½•çš„openocd commandï¼ŒåŒæ ·éœ€è¦æŠŠå›ºä»¶è·¯å¾„æ”¹æˆä½ è‡ªå·±çš„ã€‚\né…ç½®å®Œè¿™ä¸¤ä¸ªjsonæ–‡ä»¶ä¹‹åï¼Œç‚¹å‡»F5ï¼ŒVSCodeå°±ä¼šè‡ªåŠ¨ç¼–è¯‘ã€çƒ§å½•å›ºä»¶ã€å¼€å¯è°ƒè¯•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè°ƒè¯•çš„æ—¶å€™ä¼šé¦–å…ˆåœåœ¨ç¨‹åºå…¥å£å¤„ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»è¿è¡Œï¼š\nç‚¹å‡»è¿è¡Œä¹‹åï¼Œå°±å¯ä»¥çœ‹åˆ°ç‚¹ç¯æˆåŠŸï¼Œå¹¶ä¸”åœ¨ä¸‹é¢ç»ˆç«¯Tabçš„RTT Channelä¸­ï¼Œå¯ä»¥çœ‹åˆ°MCUå‘è¿‡æ¥çš„å®æ—¶æ—¥å¿—äº†ï¼š\nåˆ°ç°åœ¨ä¸ºæ­¢ï¼Œç»ˆäºä½¿ç”¨Ruståœ¨stm32ä¸Šé¢ç‚¹ç¯æˆåŠŸäº†ï¼Œå®Œç»“æ’’èŠ±ğŸ‰\n","description":"","tags":["keyboard","embedded"],"title":"ä½¿ç”¨Rustå¼€å‘STM32åµŒå…¥å¼ç¨‹åºå…¥é—¨æ•™ç¨‹","uri":"/posts/keyboard/rust-embedded-tutorial/"},{"categories":null,"content":"Learn Tauri Tauri is a desktop application framework which has a Rust core and can be used with any frontend framework. It's similar with Electron, but tauri uses system's built-in web render, so the application created by tauri is much smaller than Electron.\nInstallation Tauri can be used with any frontend frameworks. We'll use vite in this article. If you don't have a project, use the following to create one:\n1 2 cargo install create-tauri-app cargo create-tauri-app Another thing you need to do is to install tauri cli tool to cargo or npm:\n1 2 3 cargo install tauri-cli # OR npm install --save-dev @tauri-apps/cli Then, you can use cargo or npm command like:\n1 2 3 cargo tauri dev # OR npm run tauri dev tauri-api npm package is also needed for calling Rust APIs in frontend:\n1 npm install @tauri-apps/api Vue é¡¹ç›®ç»“æ„\npublic: ä¸ä¼šè¢«ç¼–è¯‘çš„èµ„æºæ–‡ä»¶ src/assets: èµ„æºæ–‡ä»¶ï¼Œä¼šè¢«ç¼–è¯‘ src/components: ç»„ä»¶ src/App.vue: å…¥å£æ–‡ä»¶ SFC å•æ–‡ä»¶ç»„ä»¶ ä¸€ä¸ªæ–‡ä»¶å°±æ˜¯ä¸€ä¸ªç»„ä»¶ï¼Œä¸€èˆ¬åˆ†å±‚å‡ ä¸ªéƒ¨åˆ†ï¼š\nscript: setupåªèƒ½æœ‰ä¸€ä¸ªï¼Œå…¶ä»–çš„scriptå¯ä»¥æœ‰å¤šä¸ª template: æ¨¡æ¿ï¼Œåªèƒ½æœ‰ä¸€ä¸ª style: css vue æ¨¡æ¿è¯­æ³• åœ¨\u003cscript setup\u003eé‡Œé¢å®šä¹‰ä¸€ä¸ªå˜é‡vï¼Œç„¶åå°±å¯ä»¥åœ¨\u003ctemplate\u003eé‡Œé¢ä½¿ç”¨{{ v }}ç”¨è¿™ä¸ªå˜é‡äº†ã€‚è¿™æ˜¯æœ€ç®€å•çš„vueçš„æ¨¡æ¿è¯­æ³•ï¼š\n1 2 3 4 5 6 7 8 9 \u003ctemplate\u003e \u003cdiv\u003e {{ v }} \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e const v:number = 1; \u003c/script\u003e vue æŒ‡ä»¤ vueæä¾›çš„è¯­æ³•ç³–æŒ‡ä»¤ã€‚æ¯”å¦‚ï¼Œv-textï¼šç›´æ¥æ˜¾ç¤ºtextã€‚ä½¿ç”¨æ–¹å¼ï¼š\n1 2 3 4 5 6 7 8 \u003ctemplate\u003e \u003cdiv v-text=\"v\"\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup lang=\"ts\"\u003e const v:string = \"str\"; \u003c/script\u003e æ¯ç§vueæŒ‡ä»¤ï¼Œéƒ½æœ‰å…¶ç”¨æ³•ã€‚\nv-on åœ¨æŸäº‹ä»¶å‘ç”Ÿçš„æ—¶å€™ï¼Œè§¦å‘\n1 \u003cbutton v-on:click='callback'\u003e v-onæœ‰ä¸€ä¸ªç®€å†™ï¼Œä½¿ç”¨@ä»£æ›¿v-onï¼š\n1 \u003cbutton @click='callback'\u003e v-bind ç»‘å®šå±æ€§ï¼Œç®€å†™æ˜¯:\n1 \u003cdiv :id=\"my_id\"\u003e v-model ä¸€èˆ¬æ˜¯ç»‘å®šè¡¨å•å…ƒç´ ï¼Œæ¯”å¦‚è¾“å…¥ã€ç”¨æˆ·é€‰æ‹©ç­‰\n1 \u003cinput v-model=\"a\" type=\"text\"\u003e æ³¨æ„ï¼Œè¿™ç§å˜é‡éœ€è¦ç”¨ ref() å£°æ˜ï¼Œæ‰èƒ½è®©å¯¹åº”çš„å˜é‡å˜æˆå“åº”å¼çš„ï¼Œå¦åˆ™å˜é‡ä¸ä¼šè‡ªåŠ¨æ›´æ–°\n","description":"","tags":["rust"],"title":"Learn Tauri","uri":"/posts/engineering/tauri/"},{"categories":null,"content":"ä¸€ç›´ä»¥æ¥ï¼Œæˆ‘éƒ½ç”¨çš„æ˜¯openocd + vscodeæ¥å¼€å‘stm32ï¼Œç›¸æ¯”ä¼ ç»Ÿçš„KEIL MDKï¼ŒVSCodeæ— è®ºæ˜¯å„ç§æ’ä»¶ï¼ˆCopilotï¼ï¼‰è¿˜æ˜¯äººæ€§åŒ–æ–¹é¢éƒ½æ›´èƒœä¸€ç­¹ã€‚ç”¨ä¹ æƒ¯ä¹‹åï¼Œä¸è®ºæ˜¯Pythonè¿˜æ˜¯Rustè¿˜æ˜¯Cï¼Œæ‰€æœ‰çš„è¯­è¨€éƒ½åœ¨ä¸€ä¸ªåœ°æ–¹å¼€å‘ï¼ŒçœŸçš„å¾ˆçˆ½ã€‚åœ¨å¼€å‘stm32çš„æ—¶å€™ï¼Œç”±äºå¼•å…¥äº†RTOSï¼Œæ‰€ä»¥ä»…ä»…æ˜¯æ–­ç‚¹å•æ­¥è°ƒè¯•æ˜¾å¾—æœ‰äº›ä¸å¤Ÿç”¨äº†ï¼Œå°±æƒ³ç€å¯ä¸å¯ä»¥åƒå…¶ä»–é«˜çº§è¯­è¨€ä¸€æ ·ï¼Œç”µè„‘ç«¯å‘½ä»¤è¡Œä¸­å®æ—¶æ‰“å°æ—¥å¿—ã€‚å‡ ç•ªæœç´¢ä¸‹æ¥ï¼Œå‘ç°VSCodeä¸Šé¢çš„è¿™å¥—å¼€æºå·¥å…·é“¾ï¼ˆOpenOCD + CortexDebugï¼‰å·²ç»æŠŠè¿™ä¸ªäº‹æƒ…åšäº†ï¼å…ˆå±•ç¤ºä¸€ä¸‹æ•ˆæœï¼š\nå•æ­¥è°ƒè¯• + å½©è‰²æ—¥å¿—ï¼Œç›´æ¥IDEå†…å‘½ä»¤è¡Œå±•ç¤ºï¼Œå…¨é½ï¼Œä¸”ä¸éœ€è¦é¢å¤–ç¡¬ä»¶ï¼Œä¸€ä¸ªstlinkè¶³å¤Ÿã€‚çœŸçš„å¾ˆæ–¹ä¾¿ã€‚ä¸‹é¢å°±ç®€å•ä»‹ç»ä¸€ä¸‹å¦‚ä½•å®ç°ã€‚\nå®‰è£…RTT é¦–å…ˆæ˜¯è¦ä»SEGGERç½‘ç«™ä¸Šé¢ä¸‹è½½JLinkå…¨å®¶æ¡¶ï¼Œå¹¶ä¸”æŠŠRTTç›¸å…³ä»£ç å¤åˆ¶åˆ°å·¥ç¨‹ä¸‹é¢ï¼Œåœ¨makefileä¸­æ·»åŠ å¯¹åº”çš„æ–‡ä»¶ã€‚å‚è§ï¼šhttps://zhuanlan.zhihu.com/p/163771273 è¿™ç¯‡æ–‡ç« ã€‚å…¶ä¸­ï¼Œå¦‚æœä½ è¦ä½¿ç”¨stlinkï¼Œé‚£ä¹ˆç¯å¢ƒå˜é‡ä¹Ÿä¸ç”¨é…ç½®ï¼Œåªéœ€è¦å¤åˆ¶RTTæºç å³å¯ã€‚ç„¶åï¼Œæ·»åŠ logæ–‡ä»¶ï¼ŒåŒæ ·æ˜¯ä»ä¸Šé¢çš„æ–‡ç« ä¸­å¤åˆ¶å¾—åˆ°ï¼Œæ„Ÿè°¢æ–‡ç« ä½œè€…ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /* * Author: Jayant Tang * Email: jayant97@foxmail.com */ #ifndef _LOG_H_ #define _LOH_H_ #include \"SEGGER_RTT.h\" #define LOG_DEBUG 1 #if LOG_DEBUG #define LOG_PROTO(type,color,format,...) \\ SEGGER_RTT_printf(0,\" %s%s\"format\"\\r\\n%s\", \\ color, \\ type, \\ ##__VA_ARGS__, \\ RTT_CTRL_RESET) /* æ¸…å±*/ #define LOG_CLEAR() SEGGER_RTT_WriteString(0, \" \"RTT_CTRL_CLEAR) /* æ— é¢œè‰²æ—¥å¿—è¾“å‡º */ #define LOG(format,...) LOG_PROTO(\"\",\"\",format,##__VA_ARGS__) /* æœ‰é¢œè‰²æ ¼å¼æ—¥å¿—è¾“å‡º */ #define LOGI(format,...) LOG_PROTO(\"INFO: \", RTT_CTRL_TEXT_BRIGHT_GREEN , format, ##__VA_ARGS__) #define LOGW(format,...) LOG_PROTO(\"WARN: \", RTT_CTRL_TEXT_BRIGHT_YELLOW, format, ##__VA_ARGS__) #define LOGE(format,...) LOG_PROTO(\"ERROR: \", RTT_CTRL_TEXT_BRIGHT_RED , format, ##__VA_ARGS__) #else #define LOG_CLEAR() #define LOG #define LOGI #define LOGW #define LOGE #endif #endif // !_LOG_H_ é…ç½®Cortex-Debug OpenOCDåŸç”Ÿæ˜¯æ”¯æŒRTTçš„ï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹éœ€è¦å»ä¿®æ”¹openocd.cfgæ¥é…ç½®RTTã€‚ä¸è¿‡åœ¨VSCodeé‡Œé¢ï¼ŒCortex-Debugæ’ä»¶å·²ç»å¸®ä½ é…ç½®å¥½äº†ä¸€åˆ‡ï¼ˆå½“ç„¶åº•å±‚è¿˜æ˜¯ä½¿ç”¨çš„OpenOCDçš„èƒ½åŠ›ï¼‰ï¼æœ¬æ¥Cortex-Debugä¹Ÿæ˜¯åœ¨VSCodeä¸‹è°ƒè¯•stm32å¿…è£…çš„è½¯ä»¶ï¼Œæ‰€ä»¥è¯´æˆ‘ä»¬å®é™…ä¸Šåªéœ€è¦æ”¹æ”¹é…ç½®å°±å¯ä»¥ä½¿ç”¨RTTäº†ã€‚\nå…·ä½“Cortex-Debugçš„é…ç½®å¯ä»¥å‚è§æˆ‘ä¹‹å‰çš„æ–‡ç« ï¼šhttps://haobogu.github.io/posts/keyboard/openocd-ospi-flash/ ä¸­çš„launch.jsoné…ç½®ç¯èŠ‚ã€‚\nåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨åŸæœ¬çš„launch.jsonä¸­ï¼Œå¢åŠ å¦‚ä¸‹é…ç½®ï¼š\nç„¶åï¼ŒæŒ‰F5çƒ§å½•ä»£ç å¹¶å¯åŠ¨è°ƒè¯•ã€‚ä½ å°±ä¼šåœ¨ä¸‹é¢çš„ç»ˆç«¯é¡µé¢ä¸Šçœ‹åˆ°æ–°å¢äº†ä¸€ä¸ªçª—å£ï¼š\nè¿™é‡Œå°±æ˜¯RTTæ—¥å¿—æ˜¾ç¤ºçš„åœ°æ–¹ã€‚è¿™æ ·ï¼Œä¸ç®¡æ˜¯å•æ­¥è°ƒè¯•è¿˜æ˜¯å½©è‰²æ—¥å¿—æ˜¾ç¤ºï¼Œåœ¨ä¸€ä¸ªåœ°æ–¹å…¨é½ã€‚Cortex-Debugç”šè‡³è¿˜æ”¯æŒRTTçš„å…¶ä»–ç‰¹æ€§ï¼Œæ¯”å¦‚Graphï¼š\næ›´å¤šçš„ä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥å‚è€ƒCortex-Debugçš„WIKIï¼šhttps://github.com/Marus/cortex-debug/wiki/SEGGER-RTT-support\n","description":"","tags":["keyboard","embedded"],"title":"ä½¿ç”¨VSCode + RTTæ–¹ä¾¿åœ°è°ƒè¯•STM32","uri":"/posts/keyboard/rtt/"},{"categories":null,"content":"RTOS ä»€ä¹ˆæ˜¯RTOS RTOSæŒ‡å®æ—¶æ“ä½œç³»ç»Ÿï¼ˆReal-Time Operation Systemï¼‰ã€‚æ˜¯å¹¿æ³›ç”¨åœ¨åµŒå…¥å¼ä¸­çš„æ“ä½œç³»ç»Ÿï¼Œå…¶ä¸»è¦çš„ç‰¹å¾æ˜¯åŸºäºä¼˜å…ˆçº§çš„ä»»åŠ¡æ‰§è¡Œï¼Œä»¥åŠå¿«é€Ÿã€å®æ—¶çš„å“åº”ã€‚\nAzure RTOS Azure RTOSçš„å‰èº«æ˜¯ThreadXï¼Œæ˜¯å¾®è½¯æ”¶è´­å¹¶ä¸”å¼€æºçš„ä¸€ä¸ªRTOSã€‚Azure RTOSåŒ…å«ä¸€æ•´å¥—çš„åµŒå…¥å¼ç³»ç»Ÿï¼Œå®ç°äº†å…¨å®¶æ¡¶å¼çš„åµŒå…¥å¼RTOSè§£å†³æ–¹æ¡ˆã€‚Azure RTOSä¸»è¦åŒ…æ‹¬å¦‚ä¸‹ç»„ä»¶ï¼š\nThreadX: é«˜æ€§èƒ½å®æ—¶æ“ä½œç³»ç»Ÿ NetX: åµŒå…¥å¼ç½‘ç»œåè®®æ ˆ FileX: åµŒå…¥å¼FATæ–‡ä»¶ç³»ç»Ÿ LevelX: NAND å’Œ NOR é—ªå­˜ç£¨æŸå‡è¡¡ GuiX: åµŒå…¥å¼å›¾å½¢åº“ USBX: åµŒå…¥å¼USBåè®®æ ˆ TraceX: åŸºäºä¸»æœºçš„åµŒå…¥å¼åˆ†æå·¥å…· RTOSæœ‰å¾ˆå¤šï¼Œä¸ºä»€ä¹ˆæˆ‘ä¼šé€‰æ‹©Azure RTOSä½œä¸ºæˆ‘å­¦ä¹ ä½¿ç”¨çš„å¯¹è±¡å‘¢ï¼ŸåŸå› ä¸»è¦æœ‰å¦‚ä¸‹ä¸‰ç‚¹ï¼š\næˆ‘ä¸»è¦ä½¿ç”¨STM32ï¼ŒSTå®˜æ–¹æ”¯æŒæ¯”è¾ƒå¥½çš„RTOSåªæœ‰FreeRTOSå’ŒAzureRTOSï¼ˆThreadXï¼‰ ThreadXçš„è®¾è®¡å¾ˆæ£’ï¼Œä»£ç å†™å¾—éå¸¸å¥½ï¼Œä¸”éå¸¸è§„èŒƒã€‚å¦‚æ‰€æœ‰ThreadXç›¸å…³çš„å‡½æ•°éƒ½æ˜¯tx_å¼€å¤´ï¼Œæ›´åŠ ç¬¦åˆæˆ‘çš„ä»£ç å®¡ç¾ å®˜æ–¹æä¾›å®Œå–„çš„ä¸­æ–‡æ–‡æ¡£ æä¾›äº†ä»æ–‡ä»¶ç³»ç»Ÿã€USBåˆ°ç½‘ç»œåè®®æ ˆçš„å…¨å®¶æ¡¶ï¼Œå¹¶ä¸”å…¨éƒ½å¯ä»¥ä½¿ç”¨CubeMXç”Ÿæˆå’Œé…ç½® å½“ç„¶ï¼Œå…¶ä»–RTOSå¦‚FreeRTOSä¹Ÿæ˜¯éå¸¸å¥½çš„é€‰æ‹©ï¼Œé€‰è‡ªå·±å–œæ¬¢çš„å°±è¡Œï¼Œä¸€é€šç™¾é€šã€‚\næˆ‘ä»¬ä¸»è¦ä¼šç”¨åˆ°ThreadXã€FileXã€LevelXã€USBXç­‰ï¼Œä¸‹é¢æˆ‘ä»¬ä¼šä»Azure RTOSçš„æ ¸å¿ƒï¼ŒThreadXï¼Œå¼€å§‹è®²èµ·ã€‚\nThreadX ä¸­æ–‡æ–‡æ¡£ï¼šhttps://learn.microsoft.com/zh-cn/azure/rtos/threadx\nä¸‹é¢æˆ‘ä»¬ä¼šå­¦ä¹ æ•´ä¸ªThreadXçš„ä¸­æ–‡æ–‡æ¡£ã€‚æ–‡æ¡£ä¸»è¦æœ‰6ä¸ªç« èŠ‚ï¼Œåˆ†åˆ«æ˜¯ï¼š\nç¬¬ 1 ç«  - ç®€è¦æ¦‚è¿° Azure RTOS ThreadX åŠå…¶ä¸å®æ—¶åµŒå…¥å¼å¼€å‘çš„å…³ç³»\nç¬¬ 2 ç«  - ä»‹ç»åœ¨åº”ç”¨ç¨‹åºä¸­å®‰è£…å’Œä½¿ç”¨ Azure RTOS ThreadX çš„åŸºæœ¬æ­¥éª¤ï¼ˆå¼€ç®±å³ç”¨ï¼‰\nç¬¬ 3 ç«  - è¯¦ç»†ä»‹ç» Azure RTOS ThreadXï¼ˆé«˜æ€§èƒ½å®æ—¶å†…æ ¸ï¼‰çš„åŠŸèƒ½æ“ä½œ\nç¬¬ 4 ç«  - è¯¦ç»†ä»‹ç»å¦‚ä½•å°†åº”ç”¨ç¨‹åºçš„æ¥å£åº”ç”¨åˆ° Azure RTOS ThreadX\nç¬¬ 5 ç«  - ä»‹ç»å¦‚ä½•ç¼–å†™ Azure RTOS ThreadX åº”ç”¨ç¨‹åºçš„ I/O é©±åŠ¨ç¨‹åº\nç¬¬ 6 ç«  - ä»‹ç»éšæ¯ä¸ª Azure RTOS ThreadX å¤„ç†å™¨æ”¯æŒåŒ…ä¸€èµ·æä¾›çš„æ¼”ç¤ºåº”ç”¨ç¨‹åº\nThreadXç®€ä»‹ é¦–å…ˆäº†è§£ä¸€äº›åŸºç¡€æ¦‚å¿µã€‚\né¦–å…ˆæ˜¯å®æ—¶è½¯ä»¶çš„æ¦‚å¿µã€‚å®æ—¶è½¯ä»¶å®é™…ä¸Šå°±æ˜¯éœ€è¦å®æ—¶åœ°å’Œå¤–éƒ¨è¿›è¡Œäº¤äº’çš„è½¯ä»¶ï¼Œå¤§å¤šæ•°åµŒå…¥å¼è½¯ä»¶éƒ½å±äºå®æ—¶è½¯ä»¶ã€‚åœ¨å‡ºç°RTOSä¹‹å‰ï¼Œå¤§å¤šæ•°å®æ—¶è½¯ä»¶éƒ½æ˜¯ä½¿ç”¨C mainå‡½æ•°å†…éƒ¨çš„ä¸»å¾ªç¯æ¥åˆ†é…å„ä¸ªä»»åŠ¡çš„å¤„ç†æ—¶é—´ï¼ˆç°åœ¨åœ¨ä¸€äº›ç®€å•çš„ç¨‹åºä¸­ä»ç„¶æ˜¯è¿™ä¹ˆåšçš„ï¼‰ã€‚è¿™ä¹ˆåšçš„é—®é¢˜åœ¨äºç”±äºæ¯ä¸ªäº‹ä»¶çš„å“åº”æ—¶é—´ä¸ä¸€ï¼Œå¯¹äºå¤§å‹æˆ–è€…å¤æ‚çš„ç¨‹åºï¼Œå…¶æ—¶åºç‰¹æ€§å°±ä¼šå‘ç”Ÿå˜åŒ–ï¼Œæ•´ä¸ªç¨‹åºå°±ä¼šå˜å¾—ä¸ç¨³å®šã€éš¾ä»¥ç»´æŠ¤ã€‚\nè€ŒRTOSçš„å¼•å…¥å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒåŸºäºä¼˜å…ˆçº§çš„å“åº”æ–¹å¼å¯ä»¥è®©é‡è¦çš„å¤–éƒ¨äº‹ä»¶å¤„ç†å˜å¾—ç¡®å®šå’Œå¿«é€Ÿã€‚å½“ç„¶ï¼Œç°ä»£æ“ä½œç³»ç»ŸåŸºäºè¿›ç¨‹å’Œçº¿ç¨‹çš„è°ƒåº¦æ–¹å¼æ˜¯å®æ—¶æ“ä½œç³»ç»Ÿçš„è¿›ä¸€æ­¥å»¶ä¼¸ï¼Œä¸è¿‡å¯¹äºåµŒå…¥å¼ç³»ç»Ÿï¼Œä¸€èˆ¬æ¥è¯´RTOSå·²ç»è¶³å¤Ÿç”¨äº†ã€‚\nç¬¬äºŒæ˜¯çº¿ç¨‹çš„æ¦‚å¿µã€‚ç”±äºåœ¨ThreadXä¸­ï¼Œå¹¶æ²¡æœ‰å¤æ‚çš„çº¿ç¨‹ã€è¿›ç¨‹ä¹‹åˆ†ï¼Œå› æ­¤ä¸ºäº†é¿å…æ··æ·†ï¼ŒThreadXç»Ÿä¸€ä½¿ç”¨â€œçº¿ç¨‹â€æ¥æè¿°ä¸€é¡¹ç¨‹åºä»»åŠ¡ã€‚\nå®‰è£…ThreadX æœ‰ä¸¤ç§æ–¹å¼ï¼š\nç›´æ¥å…‹éš†æºç  CubeMX æˆ‘ä»¬ä¸»è¦æ˜¯ä½¿ç”¨CubeMXçš„æ–¹å¼ã€‚å‚è§ä¸‹é¢çš„æ–‡ç« ï¼šhttps://blog.csdn.net/wallace89/article/details/114941859ã€‚å¤§å¤šæ•°çš„é…ç½®ä¿æŒé»˜è®¤å³å¯ï¼Œå”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒTX_TIMER_TICKS_PER_SECONDéœ€è¦æ”¹ä¸º1000ï¼Œå³ç³»ç»ŸTickçš„æ—¶é—´ä¸º1msï¼Œè¿™ä¹Ÿæ˜¯å¤§å¤šæ•°RTOSçš„é»˜è®¤è®¾ç½®ã€‚ç„¶åMemory Poolå¤§å°ï¼Œå³å †æ ˆå¤§å°è®¾ç½®å¤§ä¸€äº›å°±å¯ä»¥äº†ã€‚\nåœ¨è®¾ç½®äº†FileXå’ŒUSBXä¹‹åï¼Œç”Ÿæˆçš„ä»£ç ä¼šæŠŠCubeMXè‡ªå¸¦çš„FatFSå’ŒUSBç”Ÿæˆçš„ä»£ç è¦†ç›–æ‰ï¼Œè¯´æ˜åœ¨ThreadXç³»ç»Ÿä¸­ï¼Œä¼šç”±FileXå’ŒUSBXæ›¿ä»£å¯¹åº”çš„æ¨¡å—ã€‚æ³¨æ„å¯èƒ½éœ€è¦é‡æ–°ç§»æ¤ä¸€ä¸‹å¯¹åº”çš„æ¥å£ã€‚\nç¬¬ä¸€ä¸ªThreadXç¨‹åº åœ¨ä½¿ç”¨CubeMXç”Ÿæˆäº†ThreadXä»£ç ä¹‹åï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹main.c:\nå¯ä»¥çœ‹åˆ°CubeMXåœ¨ä¸»å¾ªç¯ä¹‹å‰å¢åŠ äº†ä¸€ä¸ªMX_ThreadX_Init()ï¼Œå¹¶ä¸”å¢åŠ äº†ä¸€å¥æç¤ºï¼Œè¯´MX_ThreadX_Init()åé¢çš„ä»£ç æ°¸è¿œä¸ä¼šæ‰§è¡Œã€‚è¿™å°±è¯´æ˜ä»MX_ThreadX_Init()è¿™ä¸ªå‡½æ•°ï¼Œç³»ç»Ÿå°±è¿›å…¥äº†ThreadXçš„å®æ—¶æ“ä½œç³»ç»Ÿä¸­ã€‚ç‚¹è¿›MX_ThreadX_Init()çœ‹çœ‹ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief MX_ThreadX_Init * @param None * @retval None */ void MX_ThreadX_Init(void) { /* USER CODE BEGIN Before_Kernel_Start */ /* USER CODE END Before_Kernel_Start */ tx_kernel_enter(); /* USER CODE BEGIN Kernel_Start_Error */ /* USER CODE å¯ä»¥çœ‹åˆ°å®é™…ä¸Šï¼Œåªè°ƒç”¨äº†ä¸€ä¸ªThreadXçš„å‡½æ•°tx_kernel_enter()ï¼Œè¿™å°±æ˜¯ThreadXçš„å…¥å£ã€‚è¿™ä¸ªå‡½æ•°ç›¸å½“äºæ˜¯è£¸æœºç¨‹åºçš„ä¸»å¾ªç¯ï¼Œå®ƒæ°¸è¿œä¸ä¼šè¿”å›ã€‚\nOKï¼Œæˆ‘ä»¬ç°åœ¨çŸ¥é“äº†ThreadXçš„å…¥å£åœ¨å“ªé‡Œã€‚é‚£ä¹ˆä¸‹ä¸€æ­¥å°±æ˜¯åˆå§‹åŒ–ç³»ç»Ÿèµ„æºã€‚æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨tx_application_defineæ¥åˆå§‹åŒ–ä½ çš„ç¬¬ä¸€ä¸ªçº¿ç¨‹ã€‚æœç´¢tx_application_defineï¼Œå¯ä»¥å‘ç°è¿™ä¸ªå‡½æ•°è¢«ç”Ÿæˆåœ¨äº†AZURE_RTOS\\App\\app_azure_rtos.cæ–‡ä»¶ä¸‹ã€‚è¿™ä¸ªæ–‡ä»¶éå¸¸é•¿ï¼Œç®€å•æ¥è¯´å°±æ˜¯æ ¹æ®åœ¨CubeMXé‡Œé¢è®¾ç½®çš„Azure Applicationçš„è®¾ç½®ï¼Œæ¥åˆå§‹åŒ–å¯¹åº”çš„èµ„æºï¼š\nç„¶ååœ¨èµ„æºåˆ›å»ºå®Œæˆä¹‹åï¼Œä½ å°±å¯ä»¥åœ¨å¯¹åº”çš„åŒºåŸŸæ·»åŠ ä½ è‡ªå·±çš„å®æ—¶ä»»åŠ¡ä»£ç äº†ã€‚å¦‚ä¸‹å›¾æ¡†èµ·æ¥çš„å°±æ˜¯ThreadXæ ¸å¿ƒçš„çº¿ç¨‹ä»£ç å’ŒFileXçš„çº¿ç¨‹ä»£ç ã€‚\nâ€‹\tä¸€èˆ¬å¯ä»¥ä½¿ç”¨tx_thread_createæ¥åˆ›å»ºã€‚ä¸‹é¢è¿™æ®µä»£ç å°±æ˜¯å®˜æ–¹æ–‡æ¡£é‡Œé¢çš„æœ€æœ€ç®€å•çš„å•çº¿ç¨‹åˆ›å»ºä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \"tx_api.h\" unsigned long my_thread_counter = 0; TX_THREAD my_thread; main( ) { /* Enter the ThreadX kernel. */ tx_kernel_enter( ); } void tx_application_define(void *first_unused_memory) { /* Create my_thread! */ tx_thread_create(\u0026my_thread, \"My Thread\", my_thread_entry, 0x1234, first_unused_memory, 1024, 3, 3, TX_NO_TIME_SLICE, TX_AUTO_START); } void my_thread_entry(ULONG thread_input) { /* Enter into a forever loop. */ while(1) { /* Increment thread counter. */ my_thread_counter++; /* Sleep for 1 tick. */ tx_thread_sleep(1); } } å¯ä»¥çœ‹åˆ°æ•´ä¸ªçš„æ¡†æ¶å’ŒCubeMXç”Ÿæˆçš„å®é™…ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œå…¥å£å°±æ˜¯main -\u003e tx_kernel_enterï¼Œç„¶ååˆå§‹åŒ–å°±æ˜¯tx_application_defineï¼Œç„¶åé‡Œé¢å®šä¹‰äº†ä¸€ä¸ªçº¿ç¨‹my_thread_entryã€‚è¿™ä¸ªçº¿ç¨‹ä¼šå¢åŠ è®¡æ•°å™¨ -\u003e ä¼‘çœ 1Tickï¼Œå°±è¿™æ ·ä¸€ç›´æ— é™å¾ªç¯ä¸‹å»ã€‚\nå½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œç„¶åæ‰§è¡Œå®Œæ¯•ä¹‹åå°±é€€å‡ºï¼Œè¿™ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚\nåŸºç¡€é…ç½® ThreadXä¸­æœ‰å¾ˆå¤šé…ç½®é¡¹ï¼Œè¿™äº›é…ç½®é¡¹éƒ½å®šä¹‰åœ¨Core/Inc/tx_user.hä¸­ï¼Œåªæœ‰å½“å®šä¹‰äº†TX_INCLUDE_USER_DEFINE_FILEåè¿™ä¸ªæ–‡ä»¶é‡Œé¢çš„è®¾ç½®æ‰ä¼šç”Ÿæ•ˆã€‚ä¸è¿‡ä¸ç”¨æ‹…å¿ƒï¼ŒCubeMXå·²ç»å¸®æˆ‘ä»¬è®¾ç½®å¥½äº†ã€‚å…·ä½“éƒ½æœ‰å“ªäº›è®¾ç½®ï¼Œè¿™é‡Œçœ‹æ–‡æ¡£å§ï¼Œä¹Ÿæ²¡ä»€ä¹ˆæ·å¾„ï¼Œå”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯å¯ä»¥åœ¨CubeMXé‡Œé¢å®šä¹‰çš„å°½é‡åœ¨CubeMXé‡Œé¢å®šä¹‰ï¼Œå¦åˆ™é‡æ–°ç”Ÿæˆä»£ç å¯èƒ½ä¼šæŠŠåŸå…ˆçš„è®¾ç½®è¦†ç›–æ‰ã€‚\nThreadXçš„å†…æ ¸ç»„ä»¶ ThreadXåº”ç”¨ç¨‹åºåŒ…å«å››ç§ç±»å‹çš„ç¨‹åºæ‰§è¡Œï¼š\nåˆå§‹åŒ– çº¿ç¨‹æ‰§è¡Œ ä¸­æ–­æœåŠ¡ç¨‹åºï¼ˆInterrupt Service Routineï¼ŒISRï¼‰ åº”ç”¨ç¨‹åºè®¡æ—¶å™¨ è¿™å››ç±»ç¨‹åºçš„æ‰§è¡Œå¦‚ä¸‹å›¾ï¼š\nä¸‹é¢ç®€å•ä»‹ç»ä¸€ä¸‹è¿™å››ç±»ç¨‹åºã€‚\nåˆå§‹åŒ–\nå°±æ˜¯åˆå§‹åŒ–\nçº¿ç¨‹æ‰§è¡Œ\nåœ¨åˆå§‹åŒ–å®Œæ¯•ä¹‹åï¼ŒThreadXå°±ä¼šè¿›å…¥çº¿ç¨‹è®¡åˆ’å¾ªç¯ï¼Œç®€å•æ¥è¯´å°±æ˜¯\næŸ¥æ‰¾readyçš„æœ€é«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹ æŠŠæ§åˆ¶æƒè½¬äº¤ç»™è¯¥çº¿ç¨‹ æ‰§è¡Œå®Œæ¯•ï¼ˆæˆ–è€…æ›´é«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹Readyï¼‰ æ‰§è¡Œæƒäº¤å›çº¿ç¨‹è®¡åˆ’å¾ªç¯ ç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ä¸ªæœ€é«˜ä¼˜å…ˆçº§çš„çº¿ç¨‹ è¿™æ ·ä¸€ä¸ªæ— é™å¾ªç¯çš„è¿‡ç¨‹ã€‚\nä¸­æ–­æœåŠ¡ç¨‹åºï¼ˆISRï¼‰\nä¸­æ–­æ˜¯å®æ—¶ç³»ç»Ÿçš„åŸºç¡€ã€‚åœ¨æ£€æµ‹åˆ°æ›´é«˜ä¼˜å…ˆçº§çš„ä¸­æ–­æ—¶ï¼Œç³»ç»Ÿä¼šæŠŠå½“å‰ç¨‹åºçš„æ‰§è¡Œä¿¡æ¯ä¿å­˜åœ¨å †æ ˆä¸Šï¼Œç„¶åå»æ‰§è¡Œä¸­æ–­æœåŠ¡ç¨‹åºã€‚\nåº”ç”¨ç¨‹åºè®¡æ—¶å™¨\nå’Œä¸­æ–­æœåŠ¡ç¨‹åºç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºå…¶ç¡¬ä»¶å®ç°æ˜¯å¯¹ç¨‹åºéšè—çš„ï¼Œé€šå¸¸è¢«ç”¨æ¥æ‰§è¡Œè¶…æ—¶ã€å®šæ—¶ä»»åŠ¡æˆ–è€…ç›‘è§†å™¨æœåŠ¡ã€‚æ­¤å¤–ï¼Œåº”ç”¨ç¨‹åºè®¡æ—¶å™¨æ— æ³•ç›¸äº’ä¸­æ–­ï¼Œè¿™ä¸€ç‚¹ä¹Ÿå’ŒISRä¸åŒã€‚\nè¿™å°±æ˜¯ThreadXä¸­å®šä¹‰çš„å››ç±»ä¸»è¦ç¨‹åºã€‚æ¯ä¸€ç±»ç¨‹åºçš„è¯¦ç»†è®²è§£ï¼Œå¯ä»¥å‚è€ƒè¿™é‡Œçš„æ–‡æ¡£ã€‚\nThreadXçš„è®¾å¤‡é©±åŠ¨ç¨‹åº USBX USBXæ˜¯Azure RTOSæä¾›çš„é«˜æ€§èƒ½USBä¸»æœºå’Œè®¾å¤‡çš„åµŒå…¥å¼å †æ ˆï¼Œå…¶ç‰¹ç‚¹æ˜¯\nå†…å­˜å ç”¨å° å’ŒThreadXã€FileXç­‰Azure RTOSä½“ç³»å®Œç¾é€‚é…å’Œé›†æˆ æ”¯æŒç»å¤§å¤šæ•°MCUï¼Œä»¥åŠç»å¤§å¤šæ•°USBè®¾å¤‡å’Œä¸»æœºç±»åˆ« æä¾›ç›´è§‚ä¸”ä¸€è‡´çš„APIï¼Œéµå¾ªåŠ¨è¯ - åè¯çš„å‘½åçº¦å®šï¼Œæ‰€æœ‰APIå‡å¸¦æœ‰ux_å‰ç¼€ æ‰€æœ‰é˜»å¡APIéƒ½å¸¦æœ‰å¯é€‰çš„è¶…æ—¶ é€šè¿‡äº†å„ç§è®¤è¯ ä¸‹é¢å°±ä»‹ç»ä¸€ä¸‹USBXçš„åŠŸèƒ½ï¼Œä»¥åŠä½¿ç”¨\nUSBXåŠŸèƒ½ USBX åŒæ—¶æ”¯æŒä¸»æœºç«¯å’Œè®¾å¤‡ç«¯ã€‚ æ¯ä¸€ç«¯éƒ½ç”±ä¸‰ä¸ªå±‚ç»„æˆã€‚\næ§åˆ¶å™¨å±‚ å †æ ˆå±‚ ç±»å±‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\nUSBXå®‰è£… Cubeå·²ç»æŠŠUSBXæ‰€éœ€è¦çš„æ–‡ä»¶ç”Ÿæˆåœ¨äº†USBXç›®å½•ä¸‹ï¼Œåœ¨ä»£ç ä¸­åªéœ€è¦æŒ‰éœ€å¼•å…¥ux_api.hæˆ–è€…ux_port.hå³å¯ã€‚\næ­¤å¤–ï¼Œè¦æƒ³åœ¨é¡¹ç›®ä¸­ä½¿ç”¨USBXè¿˜éœ€è¦å¦‚ä¸‹æ­¥éª¤ï¼š\nåœ¨tx_application_defineçš„å¼€å¤´æ·»åŠ ux_system_initializeï¼Œå®ŒæˆUSBèµ„æºçš„åˆå§‹åŒ– ux_system_initializeè¿™ä¸ªå‡½æ•°å®šä¹‰äº†USBXçš„å†…å­˜æ± ï¼Œå…·ä½“ä½¿ç”¨å¯ä»¥çœ‹åç»­ç« èŠ‚ æ·»åŠ å¯¹ux_host_stack_initializeçš„è°ƒç”¨ åˆå§‹åŒ–æ‰€éœ€çš„ USBX ç±»ï¼ˆä¸»æœºå’Œ/æˆ–è®¾å¤‡ç±»ï¼‰ åˆå§‹åŒ–ç³»ç»Ÿä¸­å¯ç”¨çš„è®¾å¤‡æ§åˆ¶å™¨ ï¼ˆoptionalï¼‰ä¿®æ”¹ tx_low_level_initialize.c æ–‡ä»¶ï¼Œä»¥æ·»åŠ ä½çº§åˆ«ç¡¬ä»¶åˆå§‹åŒ–å’Œä¸­æ–­å‘é‡è·¯ç”±åœ°å€ USBXçš„é…ç½® å’ŒThreadXç±»ä¼¼ï¼ŒUSBXçš„æ‰€æœ‰é…ç½®éƒ½åœ¨ux_user.hæ–‡ä»¶ä¸­ã€‚å¯ä»¥æŒ‰ç…§è¿™é‡Œçš„æ–‡æ¡£ä¿®æ”¹ç›¸åº”é…ç½®ã€‚ä¿®æ”¹ä¹‹å‰æ³¨æ„æ£€æŸ¥CubeMXã€‚\nUSBXçš„åˆå§‹åŒ– åˆå§‹åŒ– \u0026 ååˆå§‹åŒ– é¦–å…ˆæ˜¯USBXçš„åˆå§‹åŒ–ã€‚ç”±äºUSBXæœ‰è‡ªå·±çš„å†…å­˜ç®¡ç†å™¨ï¼Œå› æ­¤å¯ä»¥ä¸ºUSBXå•ç‹¬ç”³è¯·å†…å­˜æ± ï¼Œè¿™ä¸ªæ­¥éª¤å¿…é¡»åœ¨åˆå§‹åŒ–ä¸»æœºæˆ–è€…è®¾å¤‡ç«¯ä¹‹å‰å®Œæˆã€‚ä¸‹é¢æ˜¯åˆå§‹åŒ–å†…å­˜æ± çš„ä¾‹å­ï¼š\n1 2 // USBX å†…å­˜èµ„æºåˆå§‹åŒ–ä¸º128Kçš„æ™®é€šå†…å­˜ï¼Œæ— ç¼“å­˜å®‰å…¨å†…å­˜æ±  ux_system_initialize(memory_pointer,(128*1024),UX_NULL,0); æ³¨æ„ï¼šå½“å¸¸è§„å†…å­˜ä¸æ˜¯ç¼“å­˜å®‰å…¨çš„ï¼Œä¸”MCUéœ€è¦ä½¿ç”¨DMAæ—¶ï¼Œéœ€è¦å®šä¹‰ç¼“å­˜å®‰å…¨å†…å­˜æ± ã€‚åœ¨ä¸å®šä¹‰ç¼“å­˜å®‰å…¨å†…å­˜æ± æ—¶ï¼ŒUSBXä¼šä½¿ç”¨æ™®é€šå†…å­˜æ± ä»£æ›¿ã€‚\nè¦æƒ³ç»ˆæ­¢ä½¿ç”¨USBXï¼ˆååˆå§‹åŒ–ï¼‰ï¼Œåˆ™éœ€è¦é¦–å…ˆä¿è¯æ‰€æœ‰çš„USBç±»å’Œæ§åˆ¶å™¨èµ„æºå·²ç»ç»ˆæ­¢ï¼Œç„¶åæ‰§è¡Œux_system_uninitialize();å³å¯ã€‚\nUSBXçš„è®¾å¤‡å †æ ˆï¼ˆDevice Stackï¼‰ å¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œä¸»è¦æ˜¯ä½¿ç”¨è®¾å¤‡å †æ ˆï¼Œå³è®©æˆ‘ä»¬çš„MCUæˆä¸ºä¸€ä¸ªUSBè®¾å¤‡ã€‚USBXçš„è®¾å¤‡å †æ ˆçš„ç»“æ„å¯ä»¥å‚è€ƒä¸‹å›¾ï¼š\nç®€å•ç†è§£ï¼Œå¯ä»¥æŠŠæ•´ä¸ªUSBXçš„è®¾å¤‡å †æ ˆåˆ’åˆ†ä¸º4ä¸ªéƒ¨åˆ†ï¼ˆ3å±‚ï¼Œä¸Šé¢å·²ç»ä»‹ç»è¿‡ï¼‰ï¼š\næœ€ä¸Šå±‚æ˜¯è®¾å¤‡ç±»ï¼ˆDevice Classesï¼‰ ä¸­é—´å±‚æ˜¯è®¾å¤‡å †æ ˆï¼ˆDevice Stackï¼‰ åº•å±‚æ˜¯è®¾å¤‡æ§åˆ¶å™¨ï¼ˆDevice Controllerï¼‰ ä¸­é—´è¿˜æœ‰ä¸€ä¸ªæ˜¯VBUSæ§åˆ¶å™¨ ä¸‹é¢ä¼šå…ˆè®²ä¸€ä¸‹åˆå§‹åŒ–å’Œæ¥å£è°ƒç”¨ï¼Œç„¶åç®€å•ä»‹ç»ä¸€ä¸‹\nåˆå§‹åŒ–è®¾å¤‡å †æ ˆ è¦æƒ³ä½¿ç”¨USBXçš„è®¾å¤‡å †æ ˆï¼Œéœ€è¦åœ¨è°ƒç”¨ux_system_initializeåˆå§‹åŒ–å®Œæ¯•å†…å­˜æ± ä¹‹åï¼Œè°ƒç”¨ux_device_stack_initializeæ¥åˆå§‹åŒ–è®¾å¤‡å †æ ˆæ‰€ä½¿ç”¨çš„æ‰€æœ‰èµ„æºã€‚ç„¶åï¼Œå°±å¯ä»¥ä½¿ç”¨ux_device_stack_class_registerå»æ³¨å†Œå¯¹åº”æ˜¯USBè®¾å¤‡ç±»ã€‚è¿˜éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒUSBè®¾å¤‡æ§åˆ¶å™¨ï¼ˆå³Device Controllerï¼‰ï¼Œéœ€è¦å•ç‹¬åˆå§‹åŒ–ã€‚\nè¯´äº†è¿™ä¹ˆå¤šï¼Œä¸‹é¢ç»™ä¸€ä¸ªåˆå§‹åŒ–çš„checklistï¼š\nUSBXå†…å­˜æ± ï¼šux_system_initialize USBè®¾å¤‡å †æ ˆï¼šux_device_stack_initialize æ³¨å†ŒUSBè®¾å¤‡ç±»åˆ°è®¾å¤‡å †æ ˆï¼šux_device_stack_class_register USBè®¾å¤‡æ§åˆ¶å™¨ï¼šux_dcd_controller_initialize(è¿™ä¸ªå‡½æ•°ä¼¼ä¹å·²depreciatedï¼ŒæŸ¥æ‰¾ux_dcd_*è·å–æœ€æ–°æ›´æ–°) ä¸‹é¢æ˜¯ä¸€ä¸ªDemoï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // USBXå†…å­˜æ± åˆå§‹åŒ– ux_system_initialize(memory_pointer,(128*1024), 0, 0); // è®¾å¤‡å †æ ˆåˆå§‹åŒ– status = ux_device_stack_initialize(\u0026device_framework_high_speed, DEVICE_FRAMEWORK_LENGTH_HIGH_SPEED, \u0026device_framework_full_speed, DEVICE_FRAMEWORK_LENGTH_FULL_SPEED, \u0026string_framework, STRING_FRAMEWORK_LENGTH, \u0026language_id_framework, LANGUAGE_ID_FRAMEWORK_LENGTH, UX_NULL); // å­˜å‚¨è®¾å¤‡ç±»çš„åˆå§‹åŒ–å‚æ•° /* Store the number of LUN in this device storage instance: single LUN. */ storage_parameter.ux_slave_class_storage_parameter_number_lun = 1; /* Initialize the storage class parameters for reading/writing to the Flash Disk. */ storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_last_lba = 0x1e6bfe; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_block_length = 512; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_type = 0; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_removable_flag = 0x80; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_read = tx_demo_thread_flash_media_read; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_write = tx_demo_thread_flash_media_write; storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_status = tx_demo_thread_flash_media_status; // æ³¨å†Œä¸Šé¢çš„å­˜å‚¨è®¾å¤‡ç±»åˆ°interface 0 status = ux_device_stack_class_register(ux_system_slave_class_storage_name ux_device_class_storage_entry, ux_device_class_storage_thread,0, (VOID *)\u0026storage_parameter); // åˆå§‹åŒ–è®¾å¤‡æ§åˆ¶å™¨ status = ux_dcd_controller_initialize(0x7BB00000, 0, 0xB7A00000); åº”ç”¨å±‚çš„æ¥å£è°ƒç”¨ USBXçš„æ¥å£åˆ†ä¸ºä¸¤å±‚ï¼š\nUSB Device Stack APIï¼šè´Ÿè´£æ³¨å†Œ USBX è®¾å¤‡ç»„ä»¶ï¼ˆä¾‹å¦‚ç±»å’Œè®¾å¤‡æ¡†æ¶ï¼‰ã€‚ USB Device Class APIï¼šè¿™äº›APIéšç€å…·ä½“çš„USBè®¾å¤‡ç±»çš„ä¸åŒè€Œä¸åŒï¼Œæ¯”å¦‚MSC/HIDç­‰ã€‚ å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œåªéœ€è¦è°ƒç”¨Class APIå³å¯ï¼Œå¹¶ä¸éœ€è¦è°ƒç”¨Stack APIã€‚\nUSBçš„è®¾å¤‡æ¡†æ¶ è®¾å¤‡æ¡†æ¶ä¸»è¦æ˜¯ç”¨æ¥å®šä¹‰USBè®¾å¤‡ï¼Œåˆ†æˆ4ä¸ªéƒ¨åˆ†ï¼š\nè®¾å¤‡æè¿°ç¬¦ï¼š é…ç½®æè¿°ç¬¦ æ¥å£æè¿°ç¬¦ ç»ˆç»“ç‚¹æè¿°ç¬¦ è¿™äº›éƒ½éµå¾ªUSBåè®®ã€‚å®šä¹‰æ–¹å¼æ˜¯è¿™æ ·çš„ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #define DEVICE_FRAMEWORK_LENGTH_HIGH_SPEED 60 UCHAR device_framework_high_speed[] = { /* Device descriptor */ 0x12, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x0a, 0x07, 0x25, 0x40, 0x01, 0x00, 0x01, 0x02, 0x03, 0x01, /* Device qualifier descriptor */ 0x0a, 0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, /* Configuration descriptor */ 0x09, 0x02, 0x20, 0x00, 0x01, 0x01, 0x00, 0xc0, 0x32, /* Interface descriptor */ 0x09, 0x04, 0x00, 0x00, 0x02, 0x08, 0x06, 0x50, 0x00, /* Endpoint descriptor (Bulk Out) */ 0x07, 0x05, 0x01, 0x02, 0x00, 0x02, 0x00, /* Endpoint descriptor (Bulk In) */ 0x07, 0x05, 0x82, 0x02, 0x00, 0x02, 0x00 }; FileX Azure FileXæ˜¯ä¸€ä¸ªFATæ ¼å¼çš„æ–‡ä»¶ç®¡ç†ç³»ç»Ÿï¼Œæ”¯æŒå„ç§è®¾å¤‡ã€å„ç§FATæ ¼å¼å’ŒexFATæ‹“å±•æ ¼å¼ï¼Œå¹¶ä¸”é’ˆå¯¹æ€§åœ°åšäº†å¾ˆå¤šä¼˜åŒ–ã€‚\nFileXçš„å®‰è£… å’Œä¸Šé¢ThreadXã€USBXçš„å®‰è£…ä¸€æ ·ï¼Œè¦å®‰è£…FileXåªéœ€è¦åœ¨CubeMXä¸­å¼€å¯å¯¹åº”çš„åŠŸèƒ½ï¼Œå¹¶è®¾ç½®ç›¸å…³å‚æ•°å³å¯ã€‚FileXçš„ç›¸å…³æ–‡ä»¶åŸºæœ¬éƒ½æ˜¯fx_ä¸ºå¼€å¤´ï¼Œå’Œä¸Šé¢ThreadX/USBXç±»ä¼¼ï¼Œä¸»è¦å¼•å…¥çš„å¤´æ–‡ä»¶æ˜¯fx_api.hå’Œfx_port.hã€‚\néœ€è¦é¢å¤–æ³¨æ„çš„æ˜¯ï¼ŒFileXä¾èµ–ThreadXçš„è®¡æ—¶å™¨ï¼ˆtimerï¼‰å’Œä¿¡å·é‡ï¼ˆsemaphoresï¼‰åŠŸèƒ½ã€‚\nè¦æƒ³åœ¨é¡¹ç›®ä¸­ä½¿ç”¨FileXï¼Œè¿˜éœ€è¦å¦‚ä¸‹é…ç½®ï¼š\ninclude fx_api.hæ–‡ä»¶ åœ¨tx_application_define æˆ–åº”ç”¨ç¨‹åºçº¿ç¨‹ä¸­è°ƒç”¨ fx_system_initializeï¼Œæ¥åˆå§‹åŒ–FileXæ–‡ä»¶ç³»ç»Ÿ ç„¶åä½¿ç”¨ fx_media_open æ¥æ·»åŠ æ–‡ä»¶ç³»ç»ŸFileXåª’ä½“ï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»åœ¨åº”ç”¨ç¨‹åºçº¿ç¨‹ä¸­è°ƒç”¨ ç¼–è¯‘ä»£ç  FileXçš„é…ç½®é¡¹ é…ç½®é¡¹åœ¨è¿™é‡Œã€‚æ³¨æ„ä½¿ç”¨CubeMXé…ç½®ã€‚æ•´ä¸ªAzure RTOSçš„é…ç½®éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œå‚è€ƒä¸Šé¢å…¶ä»–æ¨¡å—çš„é…ç½®å³å¯ã€‚\nFileXçš„åŠŸèƒ½ç»„ä»¶ FileXçš„æ–‡ä»¶ç³»ç»Ÿ \u0026 FATæ–‡ä»¶ç³»ç»ŸåŸºç¡€ FileXä¼šæŠŠç‰©ç†çš„å­˜å‚¨çœ‹ä½œæ˜¯ä¸€ä¸ªé€»è¾‘æ‰‡åŒºçš„æ•°ç»„ï¼Œè‡³äºæ‰‡åŒºå’Œåº•å±‚ç‰©ç†çš„æ˜ å°„éœ€è¦åœ¨I/Oé©±åŠ¨ç¨‹åºä¸­æ¥åšï¼Œè¿™äº›é©±åŠ¨ç¨‹åºåœ¨è°ƒç”¨fx_media_opençš„æ—¶å€™è¢«åˆå§‹åŒ–ã€‚åœ¨FileXä¸­ï¼Œåº•å±‚ç‰©ç†å­˜å‚¨è¢«ç§°ä¸ºä»‹è´¨ï¼ˆmediaï¼‰ã€‚\nFAT12/16/32çš„ä»‹è´¨çš„é€»è¾‘æ‰‡åŒºå¸ƒå±€ä¸€èˆ¬é•¿è¿™æ ·ï¼š\nå¯ä»¥çœ‹åˆ°ï¼š\né€»è¾‘æ‰‡åŒºçš„èµ·å§‹IDä¸º1ï¼Œæ‰‡åŒº1æŒ‡å‘çš„æ˜¯ä¿ç•™æ‰‡åŒºï¼ˆreserved sectorï¼‰ ç¬¬0æ‰‡åŒºä¸ºå¯åŠ¨æ‰‡åŒº ä¸è¿‡ï¼Œå½“ä»‹è´¨æœ‰éšè—æ‰‡åŒºçš„æ—¶å€™ï¼Œè¿™äº›éšè—æ‰‡åŒºä¼šåœ¨å¯åŠ¨æ‰‡åŒºä¹‹å‰ï¼Œå› æ­¤å¯åŠ¨æ‰‡åŒºçš„åç§»é‡å¿…é¡»è¦è€ƒè™‘æ˜¯å¦æœ‰éšè—æ‰‡åŒº ä½œä¸ºåŒºåˆ†ï¼ŒexFATçš„é€»è¾‘æ‰‡åŒºé•¿è¿™æ ·ï¼š\nåœ¨exFATä¸­ï¼Œ å¯åŠ¨å—å’Œ FAT åŒºåŸŸå±äºç³»ç»ŸåŒºåŸŸã€‚ å…¶ä½™ç¾¤é›†å±äºç”¨æˆ·åŒºåŸŸã€‚åŒæ—¶ï¼Œä½œä¸ºå¯¹FAT12/16/32çš„å…¼å®¹ï¼ŒexFATä¸­çš„0x0B å’Œ 0x40 ä¹‹é—´çš„åŒºåŸŸï¼ˆå…¶ä¸­åŒ…å« FAT12/16/32 ä¸­çš„å„ç§ä»‹è´¨å‚æ•°ï¼‰åœ¨ exFAT ä¸­æ ‡è®°ä¸ºâ€œä¿ç•™â€ï¼Œå¿…é¡»å…¨éƒ½ç½®ä¸º0ã€‚\nFAT12/16/32ä»¥åŠexFATçš„å¯åŠ¨è®°å½•ï¼Œå¯ä»¥å‚è€ƒæ–‡æ¡£ä¸­çš„è¯¦ç»†è¯´æ˜ï¼šhttps://learn.microsoft.com/zh-cn/azure/rtos/filex/chapter3ï¼Œè¿™é‡Œä¸å†ä¸€ä¸€ä»‹ç»ã€‚\nFileX çš„ I/O é©±åŠ¨ç¨‹åº FileXæ”¯æŒå¤šä»‹è´¨ï¼ˆmediaï¼‰ï¼Œæ¯ä¸€ä¸ªFileXçš„ä»‹è´¨å®ä¾‹éƒ½æœ‰å…¶å¯¹åº”çš„å”¯ä¸€çš„I/Oçš„é©±åŠ¨ç¨‹åºã€‚åœ¨FileXä¸­ï¼ŒFX_MEDIAç»“æ„å®šä¹‰äº†ç®¡ç†å¯¹åº”çš„å­˜å‚¨ä»‹è´¨æ‰€éœ€è¦çš„ä¸€åˆ‡ã€‚ç”¨æˆ·éœ€è¦åšçš„ï¼Œå°±æ˜¯ä¸ºFileXçš„I/Oé©±åŠ¨ç¨‹åºï¼Œå†™ä¸€ä¸ªå‡½æ•°ä½œä¸ºæ•´ä¸ªé©±åŠ¨çš„å…¥å£ï¼š\n1 void my_driver_entry(FX_MEDIA *media_ptr); è¿™ä¸ªå‡½æ•°çš„å”¯ä¸€ä¸€ä¸ªå‚æ•°æ˜¯FX_MEDIAï¼Œå®ƒä¼šæ ¹æ®FX_MEDIAä¸­çš„è¯·æ±‚fx_media_driver_requestå’Œå…·ä½“çš„å‚æ•°ï¼Œæ¥åˆ¤æ–­å½“å‰è¦åšçš„äº‹æƒ…ï¼Œç„¶åè°ƒç”¨å¯¹åº”çš„å‡½æ•°/ç¡¬ä»¶æ¥å£ã€‚åœ¨è¿™é‡Œå¯ä»¥çœ‹åˆ°å¸¸ç”¨çš„fx_media_driver_requestçš„å€¼ï¼Œä»¥åŠå¯¹åº”è¯·æ±‚ä¼šç”¨åˆ°çš„å‚æ•°ï¼šhttps://learn.microsoft.com/zh-cn/azure/rtos/filex/chapter5#io-driver-requestsã€‚\nmy_driver_entryå¯ä»¥ç†è§£æˆæ˜¯å¯¹ç¡¬ä»¶å­˜å‚¨é©±åŠ¨ç¨‹åºçš„ä¸€ä¸ªç»Ÿä¸€å…¥å£ï¼Œåœ¨è¿™é‡Œå»åˆ†å‘ä¸åŒçš„ç¡¬ä»¶I/Oè¯·æ±‚ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨CubeMXç”Ÿæˆçš„LevelX + FileXä»£ç ä¸­ï¼Œå…¥å£å‡½æ•°åä¸ºï¼šfx_stm32_levelx_nor_driver\nè¿™é‡Œæ˜¯ä¸€ä¸ªé’ˆå¯¹RAMçš„Driver fx_ram_driver.cï¼Œä½œä¸ºå‚è€ƒã€‚\nFileXçš„å®¹é”™æ¨¡å— FileXåŒ…å«äº†ä¸€ä¸ªå®¹é”™æ¨¡å—ï¼Œç”¨äºåœ¨æ–‡ä»¶å†™å…¥è¿‡ç¨‹ä¸­ä»‹è´¨æ–­ç”µæˆ–è€…å¼¹å‡ºæ—¶çš„å®¹é”™ã€‚è¿™ä¸ªæ¨¡å—ä¸æ˜¯é»˜è®¤å¼€å¯çš„ï¼Œå¦‚æœæƒ³è¦å¼€å¯ï¼Œéœ€è¦åœ¨å®šä¹‰äº†FX_ENABLE_FAULT_TOLERANTçš„æƒ…å†µä¸‹ï¼Œç”ŸæˆFileXã€‚è¿™æ ·ï¼Œåœ¨è°ƒç”¨fx_media_openåˆå§‹åŒ–FileXä¹‹åï¼ŒFileXä¼šè‡ªåŠ¨è°ƒç”¨fx_fault_tolerant_enableä»è€Œå¯åŠ¨å®¹é”™æœåŠ¡ã€‚\nå®¹é”™æ¨¡å—ä¼šå¼€å¯å®¹é”™æ—¥å¿—ï¼Œå®¹é”™æ—¥å¿—ä¼šåœ¨ä»‹è´¨ä¸­å ç”¨ä¸€ä¸ªclusterçš„å¤§å°ã€‚å®¹é”™æ—¥å¿—é‡Œé¢ä¼šè®°å½•æ–‡ä»¶æ“ä½œï¼Œå½“æ“ä½œè¢«å¼‚å¸¸ç»ˆæ­¢çš„æ—¶å€™ï¼Œæ—¥å¿—å°±å¯ä»¥æŠŠå½“å‰æ“ä½œè®°å½•ä¸‹æ¥ï¼Œåé¢å†åˆå§‹åŒ–FileXä¹‹åå°±ä¼šæ ¹æ®å®¹é”™æ—¥å¿—æ¥å®Œæˆä¸Šæ¬¡ä¸­æ–­çš„æ“ä½œã€‚å½“æ‰€æœ‰æ•°æ®éƒ½æˆåŠŸå†™å…¥å¹¶ä¸”æäº¤åˆ°ä»‹è´¨ä¹‹åï¼ŒFileXä¼šåˆ é™¤å½“å‰çš„æ—¥å¿—æ¡ç›®æ–‡ä»¶æ›´æ–°æ“ä½œå®Œæˆã€‚\nLevelX LevelXæ˜¯Azure RTOSæä¾›çš„ç”¨äºNANDå’ŒNORé—ªå­˜çš„ç£¨æŸå‡è¡¡å·¥å…·ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒLevelXä¸ä¾èµ–FileXï¼Œä½†æ˜¯ä¼šä¾èµ–ThreadXã€‚\nLevelXçš„å®‰è£… å’Œä¸Šé¢åŸºæœ¬ä¸€æ ·ï¼Œä¸å†èµ˜è¿°ã€‚ç”Ÿæˆçš„æ–‡ä»¶ä¸­ï¼Œapiéƒ½åœ¨lx_api.hä¸­ã€‚æ­¤å¤–ï¼ŒLevelXç”Ÿæˆçš„æ–‡ä»¶å¯ä»¥åˆ†æˆä¸¤ç±»ï¼Œlx_nand_xxxxxå’Œlx_nor_xxxxxï¼Œåˆ†åˆ«ç”¨äºNAND Flashå’ŒNOR Flashçš„ç£¨æŸå‡è¡¡ã€‚æŒ‰éœ€å–ç”¨å³å¯ã€‚\nåœ¨å®˜æ–¹åº“é‡Œé¢ï¼Œè¿˜æœ‰LevelXç»“åˆFileXçš„ç¤ºä¾‹ï¼Œåœ¨è¿™äº›æ–‡ä»¶ä¸­\n# nand flash demo_filex_nand_flash.c fx_nand_flash_simulated_driver.c lx_nand_flash_simulator.c # nor flash demo_filex_nor_flash.c fx_nor_flash_simulated_driver.c lx_nor_flash_simulator.c LevelXçš„é…ç½®é€‰é¡¹ åŒä¸Šï¼Œè§ï¼šhttps://learn.microsoft.com/zh-cn/azure/rtos/levelx/chapter2#configuration-options\nLevelXå¯¹NOR Flashçš„æ”¯æŒ æˆ‘ä»¬ä¸»è¦ä¼šä½¿ç”¨NOR Flashï¼Œå› æ­¤ä¸»è¦çœ‹ä¸€ä¸‹LevelXå¯¹NOR Flashçš„æ”¯æŒå°±å¥½ã€‚LevelXåœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨lx_nor_flash_openï¼Œè¿™ä¸ªå‡½æ•°ä¼šæŠŠNOR Flashçš„é©±åŠ¨ç¨‹åºæŒ‡å®šç»™LevelXã€‚NOR Flashçš„é©±åŠ¨å‡½æ•°å¦‚ä¸‹ï¼š\n1 INT nor_driver_initialize(LX_NOR_FLASH *instance); å…¶ä¸­instanceå°±æ˜¯LevelXçš„å®ä¾‹ã€‚åœ¨è¿™ä¸ªé©±åŠ¨å‡½æ•°é‡Œé¢ï¼Œä¼šæŠŠå…·ä½“çš„ç¡¬ä»¶é©±åŠ¨å’ŒLevelXå®ä¾‹å…³è”èµ·æ¥ã€‚æ¯ä¸ªLevelXçš„NOR Flashçš„å®ä¾‹éœ€è¦å®ç°å¦‚ä¸‹å‡ ä¸ªæœåŠ¡ï¼š\nè¯»å–æ‰‡åŒº å†™å…¥æ‰‡åŒº å—æ“¦é™¤ éªŒè¯æ“¦é™¤çš„å— ç³»ç»Ÿé”™è¯¯å¤„ç†ç¨‹åº ä¸Šé¢çš„è¿™äº›æœåŠ¡æ˜¯é€šè¿‡åœ¨ä¸Šé¢çš„åˆå§‹åŒ–å‡½æ•°ä¸­è®¾ç½®LX_NOR_FLASHçš„instanceçš„ç›¸åº”å‡½æ•°æŒ‡é’ˆæ¥è®¾ç½®çš„ï¼Œæ­¤å¤–ï¼Œé©±åŠ¨ç¨‹åºçš„åˆå§‹åŒ–å‡½æ•°è¿˜è´Ÿè´£\næŒ‡å®šFlashçš„åŸºç¡€åœ°å€ æŒ‡å®šå—çš„æ€»æ•°å’Œæ¯ä¸ªå—çš„å­—èŠ‚æ•° RAMç¼“å†²åŒºè®¾ç½® ä¸‹é¢ä»‹ç»ä¸€ä¸‹éœ€è¦åœ¨é©±åŠ¨ç¨‹åºä¸­å®ç°çš„æœåŠ¡ã€‚\nè¯»å–æ‰‡åŒº é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯è¯»å–NOR Flashä¸­çš„ç‰¹å®šæ‰‡åŒºã€‚å¦‚æœæˆåŠŸï¼Œè¿”å›LX_SUCCESSã€‚å¤±è´¥åˆ™è¿”å›LX_ERRORã€‚å…¶åŸå‹å‡½æ•°ä¸ºï¼š\n1 2 3 4 INT nor_driver_read_sector( ULONG *flash_address, ULONG *destination, ULONG words); å…¶ä¸­ï¼Œflash_addresså°±æ˜¯è¯»å–çš„é€»è¾‘æ‰‡åŒºçš„åœ°å€ï¼Œdestinationæ˜¯è¯»å‡ºæ¥çš„æ•°æ®ä½ç½®ï¼Œè€Œwordsåˆ™æ˜¯è¯»å–å¤§å°ï¼ˆ32ä½å­—èŠ‚çš„æ•°é‡ï¼‰ã€‚\nå†™å…¥æ‰‡åŒº å’Œè¯»å–ç±»ä¼¼ï¼Œå¦‚æœæˆåŠŸï¼Œè¿”å›LX_SUCCESSã€‚å¤±è´¥åˆ™è¿”å›LX_ERRORã€‚åŸå‹å‡½æ•°ä¸ºï¼š\n1 2 3 4 INT nor_driver_write_sector( ULONG *flash_address, ULONG *source, ULONG words); flash_addressä¸ºå†™å…¥é€»è¾‘æ‰‡åŒºçš„åœ°å€ï¼Œsourceä¸ºæ•°æ®ï¼Œwordsä¸ºå†™å…¥çš„å¤§å°ã€‚\næ³¨æ„ï¼Œåœ¨å†™å…¥æ—¶ï¼Œéœ€è¦è‡ªè¡Œåˆ¤æ–­å†™å…¥æ˜¯å¦æˆåŠŸã€‚è¿™ä¸ªæ­¥éª¤å¯ä»¥é€šè¿‡è¯»å–å›å†™å…¥å€¼å¹¶æ ¡éªŒå®ç°ã€‚\nå—æ“¦é™¤ è´Ÿè´£æ“¦é™¤æŒ‡å®šçš„å—ï¼ˆBlockï¼‰ã€‚å¦‚æœæˆåŠŸï¼Œè¿”å›LX_SUCCESSã€‚å¤±è´¥åˆ™è¿”å›LX_ERRORã€‚åŸå‹å‡½æ•°ä¸ºï¼š\n1 2 INT nor_driver_block_erase(ULONG block, ULONG erase_count); blockå°±æ˜¯è¦æ“¦é™¤çš„å—ï¼Œè€Œerase_countåˆ™ä¸»è¦ç”¨äºè¯Šæ–­\néªŒè¯æ“¦é™¤çš„å— LevelXéœ€è¦éªŒè¯å¯¹åº”çš„å—æ˜¯å¦å·²ç»æˆåŠŸæ“¦é™¤ï¼Œå¦‚æœå·²è¢«æ“¦é™¤ï¼Œåˆ™è¿”å›LX_SUCCESSï¼Œå¦åˆ™è¿”å›LX_ERRORã€‚å‡½æ•°åŸå‹å¦‚ä¸‹ï¼š\n1 INT nor_driver_block_erased_verify(ULONG block); blockå°±æ˜¯è¦éªŒè¯çš„å—ã€‚\né©±åŠ¨ç¨‹åºç³»ç»Ÿé”™è¯¯ è¿™ä¸ªå‡½æ•°è´Ÿè´£å¤„ç†é©±åŠ¨ç¨‹åºå‘ç”Ÿçš„é”™è¯¯ï¼Œå‡½æ•°åŸå‹å…¥ä¸‹ï¼š\n1 INT nor_driver_system_error(UINT error_code); error_codeè¡¨ç¤ºå‘ç”Ÿçš„é”™è¯¯ç ã€‚\nNORçš„æ¨¡æ‹Ÿé©±åŠ¨ç¨‹åº LevelXæä¾›äº†ä½¿ç”¨RAMæ¥æ¨¡æ‹ŸNORé—ªå­˜çš„é©±åŠ¨ç¨‹åºï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªé©±åŠ¨ç¨‹åºä¼šæä¾›8ä¸ªé—ªå­˜å—ï¼ˆBlockï¼‰ï¼Œæ¯ä¸ªå—æœ‰16ä¸ªæ‰‡åŒºï¼ˆSectorï¼‰ï¼Œæ¯ä¸ªæ‰‡åŒº512å­—èŠ‚ã€‚è¿™ä¸ªæ¨¡æ‹Ÿé©±åŠ¨ç¨‹åºåœ¨lx_nor_flash_simulator.cä¸­å®šä¹‰ï¼Œå¯ä»¥ä½œä¸ºè‡ªå®šä¹‰é©±åŠ¨ç¨‹åºçš„å¾ˆå¥½çš„å‚è€ƒã€‚å…¶åˆå§‹åŒ–å‡½æ•°ä¸ºlx_nor_flash_simulator_initializeã€‚\nFileXé›†æˆ fx_nor_flash_simulated_driver.cæ–‡ä»¶æä¾›äº†NORæ¨¡æ‹Ÿ + FileXçš„é›†æˆé©±åŠ¨ç¨‹åºï¼Œå¯ä»¥ä½œä¸ºå¾ˆå¥½çš„å‚è€ƒã€‚\nå¦å¤–ï¼Œå®˜æ–¹é—®é¢˜è¿˜æœ‰å¦‚ä¸‹æç¤ºï¼Œå¯ä»¥ç”¨æ¥æå‡è¯»å†™æ•ˆç‡ï¼š\nFileX NOR é—ªå­˜æ ¼å¼åº”è¯¥æ˜¯å°äº NOR é—ªå­˜æä¾›çš„æ‰‡åŒºçš„ä¸€ä¸ªå®Œæ•´å—å¤§å°ã€‚ è¿™å°†æœ‰åŠ©äºç¡®ä¿åœ¨æŸè€—å‡è¡¡å¤„ç†æœŸé—´è·å¾—æœ€ä½³æ€§èƒ½ã€‚ åœ¨ LevelX æŸè€—å‡è¡¡ç®—æ³•ä¸­æé«˜å†™å…¥æ€§èƒ½çš„å…¶ä»–æŠ€å·§åŒ…å«ï¼š\nç¡®ä¿æ‰€æœ‰å†™å…¥å¤§å°éƒ½æ°å¥½æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªç¾¤é›†ï¼ˆclusterï¼‰ï¼Œå¹¶ä¸”åœ¨ç¡®åˆ‡çš„ç¾¤é›†è¾¹ç•Œä¸Šå¯åŠ¨ã€‚ é€šè¿‡ FileX çš„API fx_file_allocate ç±»æ‰§è¡Œå¤§æ–‡ä»¶å†™å…¥æ“ä½œä¹‹å‰ï¼Œè¯·å…ˆé¢„åˆ†é…ç¾¤é›†ã€‚ å®šæœŸä½¿ç”¨ lx_nor_flash_defragment é‡Šæ”¾å°½å¯èƒ½å¤šçš„ NOR å—ï¼Œä»è€Œæé«˜å†™å…¥æ€§èƒ½ã€‚ ç¡®ä¿å·²å¯ç”¨ FileX é©±åŠ¨ç¨‹åºä»¥æ¥æ”¶é‡Šæ”¾æ‰‡åŒºä¿¡æ¯ï¼Œå¹¶é€šè¿‡è°ƒç”¨ lx_nor_flash_sector_release åœ¨é©±åŠ¨ç¨‹åºä¸­å¤„ç†å¯¹é©±åŠ¨ç¨‹åºå‘å‡ºçš„é‡Šæ”¾æ‰‡åŒºçš„è¯·æ±‚ã€‚ CubeMXçš„å‘ åœ¨ä½¿ç”¨CubeMXç”ŸæˆThreadXå·¥ç¨‹çš„æ—¶å€™ï¼Œéœ€è¦æ³¨æ„å¦‚ä¸‹å‡ ä¸ªå‘ï¼š\nç”Ÿæˆçš„ThreadXï¼Œé»˜è®¤çš„portingæ˜¯IARï¼Œå³ä½¿åœ¨CubeMXä¸­é€‰æ‹©makefileï¼Œä¹Ÿä¸€æ ·ã€‚å› æ­¤ï¼Œéœ€è¦å»å®˜æ–¹åº“ï¼ŒæŠŠport/cortex_m7/gnuç›®å½•ä¸‹çš„å†…å®¹å¤åˆ¶åˆ°CubeMXå·¥ç¨‹ä¸‹çš„Middlewares/ST/threadx/ports/cortex_m7/gnuã€‚\næŠŠmakefileé‡Œé¢çš„IARç›¸å…³çš„è·¯å¾„å¹²æ‰ï¼Œæ¢æˆgnuçš„\nåœ¨makefileé‡Œé¢æ·»åŠ .Sæ–‡ä»¶ï¼ˆå³ThreadXçš„gnu portingï¼‰ç›¸å…³çš„ç¼–è¯‘é€‰é¡¹ï¼Œä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 # æ·»åŠ æ‰€æœ‰çš„ .S æ–‡ä»¶åˆ° S_SOURCESï¼Œä¸»è¦æ˜¯ gnu portingã€‚ # åˆ«å¿˜è®° tx_initialize_low_level.S è¿™ä¸ªæ–‡ä»¶ã€‚ S_SOURCES = $(wildcard Middlewares/ST/threadx/ports/cortex_m7/gnu/src/*.S) \\ Core/Src/tx_initialize_low_level.S # .. ä¸­é—´çœç•¥ï¼Œä¸‹é¢åˆ°ç”Ÿæˆçš„ OBJECTS çš„åœ°æ–¹ï¼Œæ·»åŠ  .S æ–‡ä»¶å¯¹åº”çš„ OBJECTS OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(sort $(S_SOURCES:.S=.o)))) vpath %.S $(sort $(dir $(sort $(S_SOURCES)))) # .. ç„¶ååˆ°æ„å»ºå‘½ä»¤è¿™è¾¹ï¼Œæ·»åŠ  .S å¯¹åº”çš„æ„å»ºä»»åŠ¡ï¼ˆå‚ç…§ .s å³å¯ï¼‰ $(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR) $(AS) -c $(CFLAGS) $\u003c -o $@ ","description":"","tags":["keyboard","embedded"],"title":"RTOS","uri":"/posts/keyboard/rtos/"},{"categories":null,"content":"ä½¿ç”¨OpenOCD+VSCodeä¸€é”®çƒ§å½•Boot+Appåˆ°å†…ç½®+å¤–ç½®flash èƒŒæ™¯ åœ¨å¼€å‘stm32ç³»åˆ—çš„æ—¶å€™ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ä¼šä½¿ç”¨Windowsç³»ç»Ÿ+MDK/IARæ¥å¼€å‘ã€‚ä¸è¿‡å¯¹äºä¸»åŠ›æ˜¯MacOS+Windowsçš„æˆ‘æ¥è¯´ï¼Œä¸€å¥—å…¼å®¹ä¸¤ä¸ªç³»ç»Ÿçš„å¼€å‘æ–¹æ¡ˆå°±æˆäº†åˆšéœ€ã€‚åœ¨ä¸­æ–‡äº’è”ç½‘ä¸Šé¢ç±»ä¼¼çš„èµ„æ–™éå¸¸ç¨€å°‘ï¼Œä¸è¿‡å®é™…ä¸Šï¼Œä½¿ç”¨gcc+OpenOCDçš„æ–¹æ¡ˆå®é™…ä¸Šå·²ç»éå¸¸æˆç†Ÿäº†ï¼Œåœ¨æ­¤å°±è®°å½•ä¸€ä¸‹æˆ‘çš„æŠ˜è…¾å†ç¨‹ã€‚\næœ€ç»ˆæ•ˆæœ åœ¨è®²å…·ä½“é…ç½®æ­¥éª¤ä¹‹å‰ï¼Œå…ˆçœ‹ä¸€ä¸‹æœ€ç»ˆçš„æ•ˆæœï¼š\nVSCodeä¸­ï¼Œshift+cmd+bï¼Œé€‰æ‹©flash merged firmwareï¼Œç„¶åVSCodeä¼šå¸®ä½ æŠŠæå®šä»¥ä¸‹æ‰€æœ‰ï¼š\nè‡ªåŠ¨ç¼–è¯‘App+Bootloaderä¸¤ä¸ªå·¥ç¨‹ ä½¿ç”¨srec_catåˆå¹¶bootloader.hexå’Œapplication.hexï¼ˆåŒæ—¶å…¼å®¹MacOSå’ŒWindowsï¼‰ æŠŠbootloader.hexçƒ§å†™åˆ°stm32å†…ç½®Flashï¼ŒæŠŠapplication.hexçƒ§å†™åˆ°å¤–ç½®OSPI Flash ä¸€é”®æå®Œï¼Œç›¸å½“çˆ½ï¼š\nå¦‚æœä½ é€‰æ‹©flash bootloaderæˆ–è€…flash applicationï¼Œä¹Ÿä¸€æ ·ï¼ŒVSCodeä¼šé¦–å…ˆç¼–è¯‘å¯¹åº”çš„hexï¼Œç„¶åè‡ªåŠ¨çƒ§å½•åˆ°å¯¹åº”Flashã€‚\nDebug æŒ‰F5å°±å¯ä»¥å¼€å§‹debugï¼Œå¦‚æœé»˜è®¤é…ç½®çš„æ˜¯Debug Bootloaderï¼Œé‚£ä¹ˆä¼šå…ˆç¼–è¯‘çƒ§å½•bootloaderï¼Œç„¶åå¼€å§‹debugï¼›Debug Applicationä¹Ÿä¸€æ ·ã€‚ä¸”VSCodeä¼šè‡ªåŠ¨åœ°åœ¨bootloaderå’Œapplicationä¹‹é—´è·³è½¬ï¼š\nå¼€å‘ç¯å¢ƒé…ç½® é¦–å…ˆï¼Œå¼€å‘ç¯å¢ƒçš„é…ç½®å¯ä»¥å‚è€ƒè¿™é‡Œï¼šhttps://haobogu.github.io/posts/keyboard/develop-stm32-using-vscode/ã€‚éœ€è¦æ³¨æ„çš„æ˜¯æˆ‘ä»¬éœ€è¦é€‰æ‹©gcc+makefileçš„æ–¹æ¡ˆè€Œä¸æ˜¯PlatformIOã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœä½ æƒ³è¦å®‰è£…æœ€æ–°ç‰ˆçš„OpenOCDï¼Œåœ¨Macä¸Šé¢å¯ä»¥ç›´æ¥ä½¿ç”¨\nbrew install openocd --HEAD å¦å¤–ï¼Œè¿˜éœ€è¦ä½¿ç”¨homebrewå®‰è£…srecordå¤‡ç”¨ï¼š\nbrew install srecord åœ¨Windowsä¸‹ï¼Œè¿™ä¸¤è€…éƒ½éœ€è¦æ‰‹åŠ¨å®‰è£…ï¼Œsrecordéœ€è¦ä¸€ä¸ªsrec_cat.exeã€‚\nåˆ›å»ºå·¥ç¨‹ ç”±äºæˆ‘ä»¬çš„å·¥ç¨‹æ˜¯App + Bootloaderå½¢å¼çš„ï¼Œå› æ­¤éœ€è¦åœ¨æ ¹ç›®å½•ä¸‹åˆ›å»ºä¸¤ä¸ªå·¥ç¨‹ã€‚åˆ›å»ºå®Œä¹‹åï¼Œå¯ä»¥æŠŠæ‰“åŒ…ç¼–è¯‘éƒ½åŠ åˆ°VSCodeçš„taské‡Œã€‚ç„¶åï¼Œç›´æ¥ä½¿ç”¨shift+cmd+bå¿«æ·é”®å°±å¯ä»¥é€‰æ‹©ä»»åŠ¡ï¼š\nä¸‹é¢æ˜¯ä¸€ä¸ªæˆ‘çš„task.jsonï¼Œä¾›å‚è€ƒ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"make bootloader\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd bootloader \u0026\u0026 make all -j 16\", \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [ \"relative\", \"${workspaceFolder}/application\" ], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } } }, { \"label\": \"make application\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd application \u0026\u0026 make all -j 16\", \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [ \"relative\", \"${workspaceFolder}/application\" ], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } }, }, { \"label\": \"make all\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd application \u0026\u0026 make all -j 16 \u0026\u0026 cd ../bootloader \u0026\u0026 make all -j 16\" }, { \"label\": \"make clean\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd bootloader \u0026\u0026 make clean \u0026\u0026 cd ../application \u0026\u0026 make clean\" }, { \"label\": \"flash bootloader\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd bootloader \u0026\u0026 openocd -f openocd.cfg -c \\\"program build/bootloader.elf preverify verify reset exit\\\"\", \"dependsOn\": [ \"make bootloader\" ], \"dependsOrder\": \"sequence\" }, { \"label\": \"flash application\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"cd application \u0026\u0026 openocd -f openocd.cfg -c \\\"program build/application.hex preverify verify reset exit 0x00000000\\\"\", \"dependsOn\": [ \"make application\" ], \"dependsOrder\": \"sequence\" }, { \"label\": \"flash merged firmware\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"openocd -f bootloader/openocd.cfg -c \\\"program firmware.hex preverify verify reset exit\\\"\", \"dependsOn\": [ \"make all\", \"merge hex\" ], \"dependsOrder\": \"sequence\" }, { \"label\": \"merge hex\", \"group\": \"none\", \"type\": \"shell\", \"command\": \"resources/srec_cat.exe\", \"args\": [ \"bootloader/build/bootloader.hex\", \"-Intel\", \"application/build/application.hex\", \"-Intel\", \"-o\", \"firmware.hex\", \"-Intel\" ], \"osx\":{ // needs `brew install srecord` \"command\": \"srec_cat\", \"args\": [ \"bootloader/build/bootloader.hex\", \"-Intel\", \"application/build/application.hex\", \"-Intel\", \"-o\", \"firmware.hex\", \"-Intel\" ] }, \"problemMatcher\": [] } ] } Debug Debugçš„é…ç½®ä¹Ÿç±»ä¼¼ï¼Œåªä¸è¿‡æ˜¯é…ç½®launch.jsonï¼Œå…·ä½“å¯ä»¥å‚è€ƒä¸Šé¢ç¯å¢ƒé…ç½®çš„æ–‡ç« ã€‚ä¸‹é¢æ˜¯æˆ‘çš„launch.jsonï¼Œä¾›å‚è€ƒï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 { // ä½¿ç”¨ IntelliSense äº†è§£ç›¸å…³å±æ€§ã€‚ // æ‚¬åœä»¥æŸ¥çœ‹ç°æœ‰å±æ€§çš„æè¿°ã€‚ // æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug Bootloader\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"bootloader/build/bootloader.elf\", \"loadFiles\": [ \"bootloader/build/bootloader.elf\", \"application/build/application.elf\" ], \"symbolFiles\": [ { \"file\": \"bootloader/build/bootloader.elf\", }, { \"file\": \"application/build/application.elf\" } ], \"request\": \"launch\", \"type\": \"cortex-debug\", \"runToEntryPoint\": \"main\", \"servertype\": \"openocd\", \"showDevDebugOutput\": \"parsed\", \"configFiles\": [ \"bootloader/openocd.cfg\" ], \"svdFile\": \"bootloader/STM32H7B0x.svd\", \"device\": \"stlink\", \"preLaunchTask\": \"flash bootloader\" }, { \"name\": \"Debug Application\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"bootloader/build/bootloader.elf\", \"loadFiles\": [ \"bootloader/build/bootloader.elf\", \"application/build/application.elf\" ], \"symbolFiles\": [ { \"file\": \"bootloader/build/bootloader.elf\", }, { \"file\": \"application/build/application.elf\" } ], \"request\": \"launch\", \"type\": \"cortex-debug\", \"runToEntryPoint\": \"main\", \"servertype\": \"openocd\", \"showDevDebugOutput\": \"parsed\", \"configFiles\": [ \"bootloader/openocd.cfg\" ], \"svdFile\": \"bootloader/STM32H7B0x.svd\", \"device\": \"stlink\", \"preLaunchTask\": \"flash application\" } ] } Linker Scripté…ç½® ç”±äºæˆ‘ä»¬çš„applicationè¿è¡Œåœ¨å¤–ç½®çš„OSPI Flashï¼Œè¦æƒ³è®©OpenOCDé»˜è®¤æŠŠapplicationçƒ§å½•åˆ°OSPI Flashï¼Œéœ€è¦é¦–å…ˆä¿®æ”¹ä¸€ä¸‹Linker Scriptã€‚å…¶å®ä¿®æ”¹ä¹Ÿéå¸¸ç®€å•ï¼Œå°±æ˜¯æŠŠFlashåŒºåŸŸçš„åœ°å€ç”±ä¿®æ”¹åˆ°0x90000000ï¼Œå¤§å°ä¿®æ”¹ä¸º4096Kï¼ˆå³Flashçš„å¤§å°è®¾ç½®ä¸ºäº†4Mï¼Œè¿™ä¸ªå¯ä»¥æ ¹æ®ä½ ä½¿ç”¨çš„spi flashèŠ¯ç‰‡æ¥å®šï¼‰ã€‚\nä¸ºä»€ä¹ˆéœ€è¦æŠŠFlashåŒºåŸŸçš„åœ°å€ä¿®æ”¹åˆ°0x90000000å‘¢ï¼Ÿå…¶å®è¿™ä¸€ç‚¹å’Œä½¿ç”¨MDK/IARå¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼Œç®€å•æ¥è¯´å°±æ˜¯stm32è¦æƒ³åœ¨ç›´æ¥åœ¨OSPIå†…è¿è¡Œï¼ˆå³XIPï¼‰ï¼Œé‚£ä¹ˆOSPIå¿…é¡»è¿è¡Œåœ¨memory mappedæ¨¡å¼ä¸‹ã€‚è€Œmemory mappedæ¨¡å¼ä¸‹çš„é»˜è®¤åœ°å€å°±æ˜¯0x90000000ã€‚\næ³¨æ„è¿™é‡Œæœ‰ä¸ªå‘å°±æ˜¯ï¼Œåœ¨OSPI Flashæ‰“å¼€memory mappedæ¨¡å¼ä¹‹åï¼Œæ­£å¸¸çš„OSPI Flashçš„è¯»å†™é€šä¿¡å°±å…¨éƒ½ä¼šå¤±è´¥ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨é©±åŠ¨é‡Œé¢çš„è¯»å†™æˆ–è€…å…¶ä»–å‡½æ•°ï¼ˆæ¯”å¦‚ReadIDï¼‰ï¼Œé‚£ä¹ˆå¿…é¡»å…³æ‰memory mappedæ¨¡å¼ã€‚\nOpenOCDçš„é…ç½® ä¸‹é¢å°±æ¥åˆ°äº†é‡ç‚¹ï¼Œä¹Ÿæ˜¯æœ€éš¾çš„åœ°æ–¹ï¼šOpenOCDçš„é…ç½®ã€‚\nå¯¹äºå¤§éƒ¨åˆ†ç¨‹åºæ¥è¯´ï¼Œå…¶å®åªéœ€è¦ä½¿ç”¨OpenOCDå®˜æ–¹æä¾›çš„é»˜è®¤é…ç½®å°±è¡Œäº†ã€‚ä½†æ˜¯ï¼Œç”±äºæˆ‘ä»¬è¦åœ¨OSPI Flashä¸Šé¢XIPè¿è¡Œç¨‹åºï¼Œå®˜æ–¹çš„é…ç½®å¤§æ¦‚ç‡æ˜¯ä¸èƒ½ç”¨çš„ï¼Œå°±éœ€è¦æˆ‘ä»¬è‡ªå·±å†™openocd.cfgã€‚\nåœ¨openocd.cfgä¸­ï¼Œå®é™…ä¸Šéœ€è¦åšä»¥ä¸‹å‡ ä»¶äº‹ï¼š\næŒ‡å®šdebuggerï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯stlink æŒ‡å®šèŠ¯ç‰‡ï¼ŒsourceèŠ¯ç‰‡çš„åŸºç¡€é…ç½® é…ç½®æ—¶é’Ÿ é…ç½®GPIO é…ç½®ospi å…¶ä¸­ï¼Œ1å’Œ2éƒ½æ¯”è¾ƒç®€å•ï¼Œä¸å†å±•å¼€ï¼Œå‚è€ƒä¸‹é¢çš„ä»£ç å³å¯ã€‚é‚£ä¸ºä»€ä¹ˆåœ¨OpenOCDä¸­è¿˜éœ€è¦é…ç½®æ—¶é’Ÿã€GPIOå’ŒOSPIå‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºæˆ‘ä»¬æƒ³è¦ç›´æ¥æŠŠapplicationçƒ§å½•åˆ°OSPI Flashï¼Œåœ¨OpenOCDçƒ§å½•çš„è¿‡ç¨‹ä¸­ï¼Œå®ƒéœ€è¦çŸ¥é“ä½ çš„OSPIçš„GPIOé…ç½®ï¼Œä»¥åŠOSPI Flashçš„é…ç½®ï¼Œè¿™æ ·OpenOCDæ‰èƒ½æ­£ç¡®åœ°å’ŒOSPI Flashé€šä¿¡ï¼Œä»è€Œè¿›è¡Œçƒ§å½•ã€‚\n3/4/5çš„é…ç½®ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯é…ç½®stm32çš„å¯„å­˜å™¨ã€‚åœ¨OpenOCDä¸­å¯ä»¥ä½¿ç”¨mwwå’Œmmwå¯¹å¯„å­˜å™¨è¿›è¡Œè®¾ç½®ï¼Œmwwå‘½ä»¤åœ¨OpenOCDæ–‡æ¡£é‡Œé¢å°±æœ‰ï¼Œè€Œmmwæ˜¯OpenOCDé¢å¤–å°è£…çš„ä¸€ä¸ªå‘½ä»¤ï¼Œå…·ä½“é€»è¾‘å¯ä»¥å»OpenOCDçš„scriptsé‡Œé¢æ‰¾åˆ°ã€‚é…ç½®ä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 ã€ # Choose debugger source [find interface/stlink.cfg] # Choose transport interfance transport select hla_swd # Set chip name set CHIPNAME stm32h7b0xx # Enable stmqspi if {![info exists OCTOSPI1]} { set OCTOSPI1 1 set OCTOSPI2 0 } # Use built-in stm32h7 openocd configs source [find target/stm32h7x.cfg] # OCTOSPI initialization proc octospi_init { octo } { global a b mmw 0x58024540 0x000006FF 0\t;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks) mmw 0x58024534 0x00284000 0\t;# RCC_AHB3ENR |= IOMNGREN, OSPI2EN, OSPI1EN (enable clocks) sleep 1\t;# Wait for clock startup mww 0x5200B404 0x03010111\t;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI1 mww 0x5200B408 0x00000000\t;# OCTOSPIM_P2CR: disable Port 2 # AF mapping can be found in datasheet. For h7b0, see DS13196, page 54 # PB02: OCSPI1_CLK, PB06: OCSPI1_NCS, PD11: OCSPI1_IO0, PD12: OCSPI1_IO1, PE2: OCSPI1_IO2, PD13: OCSPI1_IO3 # Generate the GPIO config: perl resources/gpio_gen.pl -c \"PB06:AF10:V, PB02:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PE02:AF09:V\" # mmw command: \"memory modify word, modify only given bits\" # usage: mmw \"address setbits clearbits\" # PB06:AF10:V, PB02:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PE02:AF09:V # Port B: PB06:AF10:V, PB02:AF09:V mmw 0x58020400 0x00002020 0x00001010 ;# MODER mmw 0x58020408 0x00003030 0x00000000 ;# OSPEEDR mmw 0x5802040C 0x00000000 0x00003030 ;# PUPDR mmw 0x58020420 0x0A000900 0x05000600 ;# AFRL # Port D: PD13:AF09:V, PD12:AF09:V, PD11:AF09:V mmw 0x58020C00 0x0A800000 0x05400000 ;# MODER mmw 0x58020C08 0x0FC00000 0x00000000 ;# OSPEEDR mmw 0x58020C0C 0x00000000 0x0FC00000 ;# PUPDR mmw 0x58020C24 0x00999000 0x00666000 ;# AFRH # Port E: PE02:AF09:V mmw 0x58021000 0x00000020 0x00000010 ;# MODER mmw 0x58021008 0x00000030 0x00000000 ;# OSPEEDR mmw 0x5802100C 0x00000000 0x00000030 ;# PUPDR mmw 0x58021020 0x00000900 0x00000600 ;# AFRL # OCTOSPI1: memory-mapped 4-line read mode with 3-byte(24bits) addresses mww 0x52005130 0x00001000\t;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full # Enter Memory mapped mode mww 0x52005000 0x3040000B\t;# OCTOSPI_CR: FMODE=0x11, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0 mww 0x52005008 0x00160100\t;# OCTOSPI_DCR1: MTYP=0x0, FSIZE=0x16=22=2^(22+1), CSHT=0x00, CKMODE=0, DLYBYP=0 mww 0x5200500C 0x00000001\t;# OCTOSPI_DCR2: WRAPSIZE=0x00, PRESCALER=0+1 mww 0x52005108 0x00000008\t;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x8 mww 0x52005100 0x03002303\t;# OCTOSPI_CCR: SIOO=0, DMODE=011, ABMODE=0x0, ADSIZE=10, ADMODE=011, ISIZE=0x0, IMODE=011 mww 0x52005110 0x000000EB\t;# OCTOSPI_IR: INSTR=FastRead, 0xeb sleep 1 flash probe $a\t;# load configuration from CR, TCR, CCR, IR register values } # RCCé…ç½®ï¼Œç„¶åè°ƒç”¨octospi_init $_CHIPNAME.cpu0 configure -event reset-init { global OCTOSPI1 global OCTOSPI2 mmw 0x52002000 0x00000004 0x0000000B\t;# FLASH_ACR: 4 WS for 64MHZ HCLK mmw 0x58024400 0x00000001 0x00000018\t;# RCC_CR: HSIDIV=1, HSI on mww 0x58024418 0x00000040\t;# RCC_CDCFGR1: CDCPRE=1, CDPPRE=2, HPRE=1 mww 0x5802441C 0x00000440\t;# RCC_CDCFGR2: CDPPRE2=2, CDPPRE1=2 mww 0x58024420 0x00000040\t;# RCC_SRDCFGR: SRDPPRE=2 mww 0x58024428 0x00404040\t;# RCC_PLLCKSELR: DIVM3=4, DIVM2=4, DIVM1=4, PLLSRC=HSI mww 0x5802442C 0x01ff0ccc\t;# RCC_PLLCFGR: PLLxRGE=8MHz to 16MHz, PLLxVCOSEL=wide mww 0x58024430 0x01010207\t;# RCC_PLL1DIVR: 64MHz: DIVR1=2, DIVQ1=2, DIVP1=2, DIVN1=8 mww 0x58024438 0x01010207\t;# RCC_PLL2DIVR: 64MHz: DIVR2=2, DIVQ2=2, DIVP2=2, DIVN2=8 mww 0x58024440 0x01010207\t;# RCC_PLL3DIVR: 64MHz: DIVR3=2, DIVQ3=2, DIVP3=2, DIVN3=8 mmw 0x58024400 0x01000000 0\t;# RCC_CR: PLL1ON=1 sleep 1 mmw 0x58024410 0x00000003 0\t;# RCC_CFGR: PLL1 as system clock sleep 1 adapter speed 4000 if { $OCTOSPI1 } { octospi_init 0 } } reset_config none separate é¦–å…ˆçœ‹$_CHIPNAME.cpu0 configure -event reset-initéƒ¨åˆ†ï¼Œè¿™é‡Œæ˜¯æ—¶é’Ÿçš„é…ç½®ã€‚å…·ä½“å“ªä¸€æ¡å‘½ä»¤é…ç½®çš„æ˜¯å“ªä¸ªå¯„å­˜å™¨ï¼Œæ³¨é‡Šé‡Œé¢å·²ç»å¾ˆæ˜ç™½äº†ã€‚è¿™é‡Œæ—¶é’Ÿæœ€å¥½å’ŒBootloaderé‡Œé¢é…ç½®çš„æ—¶é’Ÿä¸€è‡´ï¼Œå¦åˆ™å¯èƒ½å‡ºç°å¥‡æ€ªçš„é—®é¢˜ï¼ˆæ¯”å¦‚OSPI Flashè·å–ä¸åˆ°IDä¹‹ç±»çš„ï¼‰ã€‚\nåœ¨æ—¶é’Ÿé…ç½®å®Œæ¯•ä¹‹åï¼Œä¼šåˆ¤æ–­æ˜¯å¦å¼€å¯äº†OCTOSPI1ï¼Œå¦‚æœå¼€å¯ï¼Œåˆ™ä½¿ç”¨octospi_initå‡½æ•°å¯¹OSPIè¿›è¡Œé…ç½®ã€‚è€ŒOSPIçš„é…ç½®åœ¨ä¸Šé¢proc octospi_init { octo }å‡½æ•°é‡Œã€‚\nç„¶åå°±æ˜¯OSPIçš„å…·ä½“é…ç½®äº†ã€‚OSPIçš„é…ç½®åˆ†ä¸¤æ­¥ï¼ŒGPIOé…ç½®å’ŒOSPIæœ¬èº«çš„å¯„å­˜å™¨é…ç½®ã€‚å¯¹äºGPIOé…ç½®ï¼ŒOpenOCDå®˜æ–¹æä¾›äº†ä¸€ä¸ªperlè„šæœ¬å¯ä»¥ç›´æ¥ç”Ÿæˆå¯¹åº”å¼•è„šçš„GPIOï¼Œperlè„šæœ¬çš„é“¾æ¥åœ¨è¿™é‡Œã€‚å…·ä½“ä½¿ç”¨å¯ä»¥å‚è€ƒæˆ‘ä¸Šé¢å†™çš„æ³¨é‡Šï¼Œéœ€è¦é…ç½®å¥½å¯¹åº”çš„æ¥å£å’ŒAFã€‚è€ŒOSPIé…ç½®æ²¡æœ‰ä»€ä¹ˆæŠ€å·§ï¼Œå°±æ˜¯å¯¹ç…§ç€OSPIçš„å¯„å­˜å™¨ä¸€ä¸ªä¸€ä¸ªåœ°é…ç½®ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„OSPI Flashçš„é…ç½®å¿…é¡»å’ŒBootloaderé‡Œé¢çš„OSPI Flashçš„é…ç½®å®Œå…¨ä¸€è‡´ï¼Œè¿™æ ·çš„è¯åœ¨çƒ§å½•å®ŒBootloaderä¹‹åï¼ŒOpenOCDæ‰èƒ½å¤Ÿæ­£ç¡®åœ°ä½¿ç”¨è¿™ä¸ªé…ç½®å»çƒ§å†™Applicationåˆ°OSPI Flashã€‚æ€»è€Œè¨€ä¹‹ï¼Œåœ¨Cubeé‡Œé¢çš„é…ç½®ã€OpenOCDçš„é…ç½®å’ŒFlashçš„é…ç½®æœ€å¥½éƒ½è¦ä¸€è‡´ï¼Œæ‰ä¸ä¼šå‡ºç°å¥‡æ€ªçš„é—®é¢˜ã€‚\néªŒè¯é…ç½® åœ¨é…ç½®å®Œæ¯•OpenOCDä¹‹åï¼Œå¯ä»¥æ‰‹åŠ¨éªŒè¯ä¸€ä¸‹é…ç½®ã€‚è¿™ä¸€æ­¥éå¸¸é‡è¦ï¼Œé˜²æ­¢åé¢å‡ºé—®é¢˜ä¸çŸ¥é“å»å“ªé‡Œæ’æŸ¥ã€‚é¦–å…ˆè¿›å…¥ä½ çš„applicationæ–‡ä»¶å¤¹ï¼Œç„¶åä½¿ç”¨å‘½ä»¤æ‰“å¼€OpenOCDç›‘å¬4444ç«¯å£ï¼š\n1 openocd -f openocd.cfg ç„¶åï¼Œä½¿ç”¨telnet(windows/linux)æˆ–è€…ncè¿æ¥åˆ°OpenOCDï¼š\n# Windows/Linux telnet localhost 4444 # MacOS nc localhost 4444 è¿æ¥åˆ°ä¹‹åï¼Œå°±å¯ä»¥ä»»æ„è¾“å…¥OpenOCDçš„å‘½ä»¤äº†ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨\n1 flash probe 1 æ¥æŸ¥çœ‹OSPI Flashçš„ä¿¡æ¯ï¼ˆä½ ä¹Ÿå¯ä»¥å°è¯•ä¸€ä¸‹flash probe 0ï¼Œçœ‹çœ‹è¾“å‡ºçš„ä¿¡æ¯ï¼‰ï¼š\n\u003e flash probe 1 flash probe 1 valid SFDP detected flash1 'sfdp' id = 0x333333 size = 8192 KiB flash 'stmqspi' found at 0x90000000 å¯ä»¥çœ‹åˆ°OpenOCDå·²ç»è¯†åˆ«å‡ºäº†åœ¨0x90000000ä½ç½®çš„stmqspiã€‚ç„¶åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨flash info 1æ¥æŸ¥çœ‹Flashçš„è¯¦ç»†ä¿¡æ¯ï¼š\nå¯ä»¥éªŒè¯ä¸€ä¸‹ä¸‹é¢çš„Flashä¿¡æ¯é…ç½®å’Œä½ ä½¿ç”¨çš„Flashçš„DataSheetä¸­çš„é…ç½®æ˜¯å¦ä¸€è‡´ã€‚å¦‚æœä¸€è‡´ï¼Œé‚£ä¹ˆåº”è¯¥æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚\nçœ‹åˆ°è¿™é‡Œï¼Œä½ å¯èƒ½ä¼šæœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯ï¼Œä¸ºä»€ä¹ˆè¿™é‡Œçš„Flashåç§°æ˜¾ç¤ºçš„æ˜¯sfdpï¼Œè€Œå‰é¢çƒ§å½•çš„æ—¶å€™ä¼šæ­£ç¡®æ˜¾ç¤ºFlashçš„åç§°w25q64jvï¼Ÿ\nè¿™é‡ŒåŸç†æˆ‘ä¹Ÿæ²¡æœ‰å¼„æ˜ç™½ï¼Œä½†æ˜¯æˆ‘çŒœæµ‹æ˜¯å› ä¸ºOSPIçš„Memory mappedæ¨¡å¼å·²ç»æ‰“å¼€ï¼Œè¿™æ ·çš„è¯GetIDçš„å‘½ä»¤å°±ä¼šå¤±æ•ˆã€‚ä¸è¿‡è¿™ä¸ªæ—¶å€™ï¼ŒOpenOCDåªéœ€è¦è¯»å–sfdpçš„å¯„å­˜å™¨å°±å¯ä»¥çŸ¥é“ç”¨é‚£äº›å‘½ä»¤æ“ä½œFlashäº†ã€‚\nç¼–è¯‘å·¥ç¨‹ï¼Œåˆå¹¶Hexï¼Œçƒ§å½• ç”±äºæˆ‘ä»¬æ˜¯Bootloader + Applicationä¸¤ä¸ªå·¥ç¨‹ï¼Œåœ¨ç¼–è¯‘çš„æ—¶å€™éœ€è¦ä¸¤ä¸ªå·¥ç¨‹ä¸€èµ·ç¼–è¯‘ï¼Œç¼–è¯‘å‡ºæ¥æ˜¯ä¸¤ä¸ªå›ºä»¶æ–‡ä»¶ã€‚æƒ³è¦å®ç°ä¸€é”®çƒ§å½•ï¼Œæœ‰ä¸¤ä¸ªæ–¹æ¡ˆï¼š\nåˆ†åˆ«çƒ§å½•ä¸¤ä¸ªå›ºä»¶åˆ°å¯¹åº”ä½ç½® æŠŠä¸¤ä¸ªå›ºä»¶åˆå¹¶æˆä¸€ä¸ªçƒ§å½• å…¶å®ä¸¤ä¸ªæ–¹æ¡ˆæ²¡å¤ªå¤§åŒºåˆ«ï¼Œä¸ºäº†åç»­å‘å¸ƒç®€å•ï¼Œæˆ‘é€‰æ‹©äº†æ–¹æ¡ˆ2ã€‚æ–¹æ¡ˆ2æœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯ï¼Œä¸èƒ½ä½¿ç”¨binæ ¼å¼çš„å›ºä»¶ã€‚è¿™æ˜¯å› ä¸ºbinæ ¼å¼åœ¨å†…å­˜ä¸Šæ˜¯è¿ç»­çš„ï¼Œè€Œæˆ‘ä»¬çš„å›ºä»¶å®é™…ä¸Šæ˜¯çƒ§å½•åœ¨ä¸¤ä¸ªä½ç½®ï¼šå†…ç½®Flashï¼ˆ0x08000000)å’ŒOSPI Flashï¼ˆ0x90000000ï¼‰ã€‚å¦‚æœä½¿ç”¨binæ ¼å¼çš„è¯ï¼Œåœ¨åˆå¹¶ä¹‹åï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªå¥½å‡ ä¸ªGçš„è¶…å¤§å›ºä»¶ï¼Œè¿™æ˜¾ç„¶æ˜¯ä¸å¯¹çš„ã€‚æ‰€ä»¥åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨hexæ ¼å¼ï¼Œhexæ ¼å¼åœ¨æ–‡ä»¶å†…æœ‰å­˜å‚¨æ¯ä¸€ä¸ªå—çƒ§å½•çš„å†…å­˜ä½ç½®ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦ä½¿ç”¨ä¸‰æ–¹å·¥å…·æŠŠApplicationå’ŒBootloaderçš„å›ºä»¶åˆå¹¶æˆä¸€ä¸ªï¼Œç„¶ååœ¨çƒ§å½•çš„æ—¶å€™å°±ä¼šè‡ªåŠ¨åœ°æŠŠBootloaderçƒ§å½•åˆ°0x08000000ï¼ŒæŠŠOSPI Flashçƒ§å½•åˆ°0x90000000ã€‚\næˆ‘ä»¬é€‰æ‹©çš„åˆå¹¶å·¥å…·æ˜¯srecordï¼Œä¹Ÿæ˜¯éå¸¸è‘—åçš„hexåˆå¹¶å·¥å…·ï¼Œå…¨å¹³å°éƒ½æœ‰å¯¹åº”ç‰ˆæœ¬ã€‚å®‰è£…ä¸Šé¢å·²ç»è®²è¿‡ï¼Œä¸å†èµ˜è¿°ã€‚æƒ³è¦åˆå¹¶hexï¼Œä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å³å¯ï¼š\n1 srec_cat bootloader.hex -Intel application.hex -Intel -o merged.hex -Intel ä»£ç å®é™…ä¸Šéƒ½å†™åœ¨äº†VSCodeçš„taskä¸­ï¼Œæ‰§è¡Œtaskå°±ä¼šè‡ªåŠ¨å®Œæˆhexçš„åˆå¹¶ã€‚\nçƒ§å½•å°±ç®€å•äº†ï¼š\n1 openocd -f bootloader/openocd.cfg -c \\\"program firmware.hex preverify verify reset exit\\\" è¿™é‡Œéœ€è¦æ³¨æ„çš„æœ‰ä¸¤ç‚¹ï¼š\nä½¿ç”¨çš„æ˜¯bootloaderæ–‡ä»¶å¤¹ä¸‹çš„openocd.cfgï¼Œbootloaderå’Œapplicationçš„openocd.cfgæœ€å¥½ä¿æŒä¸€è‡´ ä½¿ç”¨çš„æ˜¯OpenOCDçš„programå‘½ä»¤ï¼Œè€Œä¸æ˜¯å¾ˆå¸¸è§çš„flash erase_xxxxã€‚programå‘½ä»¤æ˜¯å¯¹flashå‘½ä»¤çš„é¢å¤–ä¸€å±‚å°è£…ï¼Œè¿˜æä¾›äº†é¢„æ ¡éªŒã€çƒ§å†™ä¹‹åçš„æ ¡éªŒã€è‡ªåŠ¨é€€å‡ºé‡å¯ç­‰åŠŸèƒ½ï¼Œå¼ºçƒˆå»ºè®®ä½¿ç”¨ã€‚ ","description":"","tags":["keyboard","stm32","embedding"],"title":"ä½¿ç”¨OpenOCD+VSCodeä¸€é”®çƒ§å½•Boot+Appåˆ°å†…ç½®+å¤–ç½®flash","uri":"/posts/keyboard/openocd-ospi-flash/"},{"categories":null,"content":"OpenOCD OpenOCDæ˜¯ä¸€æ¬¾å¼€æºçš„é’ˆå¯¹åµŒå…¥å¼è®¾å¤‡çš„è°ƒè¯•å™¨ï¼Œå¯ä»¥ç”¨æ¥çƒ§å½•ã€è°ƒè¯•å¾ˆå¤šåµŒå…¥å¼è®¾å¤‡ã€‚\nå®‰è£… åœ¨macä¸Šé¢å®‰è£…OpenOCDéå¸¸ç®€å•ï¼Œä½¿ç”¨brewå®‰è£…å°±å¥½ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œbrewé‡Œé¢é»˜è®¤çš„ç‰ˆæœ¬æ¯”è¾ƒè€æ—§ï¼Œåœ¨å®‰è£…æ—¶æœ€å¥½ä½¿ç”¨:\n1 brew intall openocd --HEAD åœ¨Windowsä¸Šé¢å®‰è£…åˆ™æ›´ä¸ºç®€å•ï¼šå»OpenOCDçš„Githubçš„Releaseé¡µé¢ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„OpenOCDå®‰è£…æ–‡ä»¶å³å¯ã€‚\nOpenOCDå…¥é—¨ OpenOCDå†…ç½®äº†å¯¹å¾ˆå¤šMCUå’Œå¼€å‘æ¿çš„æ”¯æŒï¼Œè¿™äº›éƒ½å¯ä»¥å»${å®‰è£…ç›®å½•}/share/openocd/scriptsä¸‹è·å–ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåªéœ€è¦åœ¨interfaceæ–‡ä»¶å¤¹ä¸‹é¢æ‰¾åˆ°ä½ ä½¿ç”¨çš„debuggerï¼Œç„¶ååœ¨boardæ–‡ä»¶å¤¹ä¸‹é¢æ‰¾åˆ°ä½ æ‰€ä½¿ç”¨çš„æ¿å­æˆ–è€…åœ¨targetç›®å½•ä¸‹æ‰¾åˆ°ä½ ä½¿ç”¨çš„MCUï¼Œå³å¯ä»¥ä¸åšä»»ä½•æ”¹åŠ¨ï¼Œç›´æ¥ä½¿ç”¨OpenOCDè¿›è¡Œçƒ§å½•å’Œè°ƒè¯•ï¼š\n1 openocd -f interface/cmsis-dap.cfg -f target/stm32h7x.cfg è¿™æ˜¯é»˜è®¤é€‰é¡¹ï¼Œä¹Ÿæ˜¯å¤§å¤šæ•°äººçš„ç”¨æ³•ã€‚ä¸è¿‡åœ¨è¿™é‡Œï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦å¯¹OpenOCDçš„çƒ§å½•ã€è°ƒè¯•é€‰é¡¹åšæ›´åŠ æ·±å…¥ç»†è‡´åœ°å®šåˆ¶çš„è¯ï¼Œå°±å¿…é¡»ç†Ÿæ‚‰OpenOCDçš„é…ç½®æ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯-fé€‰é¡¹åé¢çš„æ–‡ä»¶ã€‚OpenOCDè‡ªå¸¦çš„è¿™äº›æ–‡ä»¶æ˜¯å¾ˆå¥½çš„å‚è€ƒï¼Œåé¢æˆ‘ä»¬ä¹Ÿä¼šå‚è€ƒè¿™äº›æ–‡ä»¶ï¼Œé’ˆå¯¹æˆ‘ä»¬è‡ªå·±çš„æ¿å­å†™å‡ºå¯¹åº”çš„é…ç½®æ–‡ä»¶ã€‚\nOpenOCDçš„é…ç½®æ–‡ä»¶ OKï¼Œåˆ°ç°åœ¨ä¸ºæ­¢æˆ‘ä»¬å·²ç»å…¥é—¨äº†OpenOCDï¼Œç°åœ¨å°±è¿›ä¸€æ­¥å­¦ä¹ OpenOCDçš„é…ç½®æ–‡ä»¶ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ˆå³ä¸ä½¿ç”¨-fæŒ‡å®šé…ç½®æ–‡ä»¶æ—¶ï¼‰ï¼ŒOpenOCDä¼šä½¿ç”¨å½“å‰ç›®å½•ä¸‹çš„openocd.cfgæ–‡ä»¶ä½œä¸ºé…ç½®æ–‡ä»¶ã€‚\nåœ¨å†™æˆ‘ä»¬è‡ªå·±çš„é…ç½®æ–‡ä»¶æ—¶ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥å¤ç”¨scripts ç›®å½•ä¸‹çš„é…ç½®æ–‡ä»¶ï¼Œåƒè¿™æ ·ï¼š\n# å¼•ç”¨stlink.cfg source [find interface/stlink.cfg] å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½ æ‰€ä½¿ç”¨çš„debuggerçš„é…ç½®æ–‡ä»¶éƒ½ä¼šéšOpenOCDæä¾›ï¼Œå¼•ç”¨å³å¯ã€‚\nä¸‹é¢ï¼Œé’ˆå¯¹æˆ‘ä»¬ä½¿ç”¨çš„debuggerï¼Œéœ€è¦å»æŒ‡å®šé€šä¿¡ç±»å‹ã€‚æ¯”å¦‚ï¼Œå¯¹äºstlinkï¼Œæˆ‘ä»¬ä½¿ç”¨hla_swdï¼š\n# Choose transport interfance transport select hla_swd æˆ–è€…å¯¹äºcmsis-dapï¼Œæˆ‘ä»¬ä½¿ç”¨swdï¼š\nsource [find interface/cmsis-dap.cfg] transport select swd å†ç„¶åï¼Œå°±å¯ä»¥çœ‹ä¸€ä¸‹æˆ‘ä»¬ä½¿ç”¨çš„MCUæ˜¯å¦åœ¨targetsé‡Œé¢äº†ã€‚ç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ˜¯åœ¨çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯èƒ½éœ€è¦è¿›è¡Œä¸€äº›äº›çš„é…ç½®ã€‚æ¯”å¦‚ï¼ŒæŒ‡å®šèŠ¯ç‰‡åç§°ï¼š\nset CHIPNAME stm32h7x å†æ¯”å¦‚ï¼Œæ‰“å¼€octo-spiçš„å¼€å…³ï¼š\n# Enable stmqspi if {![info exists OCTOSPI1]} { set OCTOSPI1 1 set OCTOSPI2 0 } ç„¶åç›´æ¥å¼•ç”¨å¯¹åº”çš„å†…ç½®é…ç½®æ–‡ä»¶å³å¯ï¼š\n# Use built-in stm32h7 openocd configs source [find target/stm32h7x.cfg] source [find board/stm32h7x_dual_qspi.cfg] è¿™é‡Œï¼Œç”±äºæˆ‘ä»¬å·²ç»äº‹å…ˆçœ‹äº†è¿™ä¸¤ä¸ªæ–‡ä»¶ï¼ŒçŸ¥é“æ‰“å¼€octo-spiè¦æŠŠOCTOSPI1é…ç½®ä¸º1ã€‚å¯¹äºä¸åŒçš„MCUï¼Œæœ€å¥½å»çœ‹ä¸€ä¸‹å¯¹åº”targetä¸‹çš„é…ç½®æ–‡ä»¶ï¼Œè¿™æ ·ä½ å°±èƒ½å¤ŸçŸ¥é“å¯ä»¥é…ç½®å“ªäº›ä¸œè¥¿ï¼Œéœ€è¦é…ç½®å“ªäº›ä¸œè¥¿ã€‚\nOpenOCDæä¾›äº†éå¸¸éå¸¸å¤šçš„é…ç½®é€‰é¡¹ï¼Œå…¶å†…ç½®çš„å„ç§targetçš„é€‰é¡¹å°±æ˜¯éå¸¸å¥½çš„å‚è€ƒã€‚å¦‚æœå‘ç°æœ‰å‘½ä»¤ä¸å¤ªæ˜ç™½ï¼Œå¯ä»¥å»å®˜æ–¹æ–‡æ¡£æŸ¥è¯¢ã€‚å½“ä½ èƒ½å¤Ÿçœ‹æ˜ç™½ä¸€ä¸ªMCUçš„å®Œæ•´çš„é…ç½®æ–‡ä»¶ï¼Œé‚£ä¹ˆç›¸ä¿¡è‡ªå·±å†™ä¸€å†™ä¹Ÿä¸åœ¨è¯ä¸‹äº†ã€‚\nOpenOCDçš„å‘½ä»¤ åœ¨å†™å®Œé…ç½®æ–‡ä»¶ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨OpenOCDè¿›è¡Œå®é™…çš„è°ƒè¯•äº†ã€‚åœ¨è°ƒè¯•ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å­¦ä¹ ä¸€ä¸‹æœ€å¸¸ç”¨çš„OpenOCDçš„å‘½ä»¤ï¼Œè¿™äº›å‘½ä»¤åœ¨è°ƒè¯•ä¸­éƒ½éå¸¸å¸¸ç”¨ã€‚\nhaltï¼šæš‚åœCPUè¿è¡Œï¼Œåœ¨æ‰§è¡Œçƒ§å½•å‘½ä»¤ä¹‹å‰å¿…é¡»å…ˆhaltï¼Œå¦åˆ™CPUä¸ä¼šç†ä½ çš„\nflashï¼šflashå®é™…ä¸ŠåŒ…å«å¾ˆå¤šå­å‘½ä»¤ï¼Œå¸¸ç”¨çš„æœ‰flash infoï¼Œflash listï¼Œfalsh banks, flash write_imageï¼Œflash verify_imageç­‰ã€‚å…·ä½“ç”¨æ³•å‚è§å®˜æ–¹æ‰‹å†Œ\nflash write_image erase [filename] [address]ï¼šçƒ§å½•æŒ‡å®šæ–‡ä»¶åˆ°å¯¹åº”åœ°å€ã€‚å¯¹äºstm32h7ï¼Œå¦‚æœçƒ§å½•elfæ–‡ä»¶ï¼Œä¸éœ€è¦åŠ åœ°å€ã€‚è€Œå¦‚æœçƒ§å½•binæ–‡ä»¶ï¼Œåˆ™éœ€è¦åŠ åœ°å€ï¼š flash write_image erase build/h7b0.bin 0x08000000 # æˆ–è€… flash write_image erase build/h7b0.elf resetï¼šå¤ä½\ninitï¼šåˆå§‹åŒ–MCU\nreset haltï¼šå¤ä½å¹¶ä¸”ç«‹åˆ»æš‚åœCPU\nmdx(mdd/mdw/mdh/mdb)ï¼šæ˜¾ç¤ºå¯¹åº”åœ°å€çš„æ•°æ®ï¼ˆmemory displayï¼‰ï¼Œmddæ˜¯64bitï¼Œmdwæ˜¯32bitï¼Œmdhæ˜¯16bitï¼Œmdbæ˜¯8bit\nmwx(mwd/mww/mwh/mwb)ï¼šå¾€å¯¹åº”åœ°å€å†™å…¥ï¼Œå„ä¸ªå‘½ä»¤å’Œä¸Šé¢ç±»ä¼¼\nprogram: OpenOCDæä¾›äº†programå‘½ä»¤ï¼Œç›¸å½“äºæ˜¯flashå‘½ä»¤çš„é«˜çº§å°è£…ã€‚å¯ä»¥ç›´æ¥ä½¿ç”¨å¦‚ä¸‹ä¸€æ¡å‘½ä»¤ï¼Œå®Œæˆåˆå§‹åŒ–ã€åœæ­¢ã€çƒ§å½•ã€é‡å¯ã€é€€å‡ºç­‰ä¸€ç³»åˆ—å‘½ä»¤å¯ä»¥å®Œæˆçš„äº‹æƒ…ï¼š\n1 2 3 4 5 6 7 8 9 # ä¸€æ¡å‘½ä»¤å®Œæˆçƒ§å†™ program build/h7b0.elf verify reset exit # ä¸‹é¢ä¸€å †å‘½ä»¤ä¹Ÿä¸€æ · init halt flash write_image erase build/h7b0.elf reset shutdown stmqspi OpenOCDæ”¯æŒstm32ç³»åˆ—MCUçš„qual-spiå’Œocto-spiï¼Œå¯ä»¥ä½¿ç”¨spiæŠŠå¤–éƒ¨flashæ˜ å°„åˆ°å†…éƒ¨çš„åœ°å€ç©ºé—´ï¼Œè¿™äº›flashå¯ä»¥è‡ªåŠ¨åœ°è¢«OpenOCDæ£€æµ‹åˆ°ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼ŒMCUå¯ä»¥ç›´æ¥è¯»å–å¯¹åº”çš„å†…å­˜ï¼Œæ‰§è¡Œflashé‡Œé¢çš„ä»£ç ã€‚ä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒMCUä¸èƒ½ç›´æ¥ä»å¤–ç½®flashåŒºåŸŸå¯åŠ¨ã€‚å› æ­¤ï¼Œåœ¨å…·ä½“çš„å®ç°ä»£ç é‡Œé¢ï¼Œå¿…é¡»åœ¨å†…ç½®flashåŒºï¼ˆæˆ–è€…è¯´bootä»£ç é‡Œé¢ï¼‰ï¼Œé…ç½®å¥½qspiæˆ–è€…ospiçš„memory mappingã€‚è¿™æ ·OpenOCDæ‰èƒ½ä½¿ç”¨åœ°å€æ˜ å°„å»æ“ä½œè¿™éƒ¨åˆ†å†…å­˜ã€‚ä¸‹é¢æ˜¯æµ‹è¯•å‘½ä»¤ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # é¦–å…ˆï¼Œè¿›å…¥OpenOCD nc localhost 4444 # ä¹‹åï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æŸ¥çœ‹spi-flash # æŸ¥çœ‹flashåˆ—è¡¨ï¼Œå¯ä»¥çœ‹åˆ°æœ‰å†…ç½®å’Œå¤–ç½®ä¸¤ä¸ªflash $ flash list \u003e {name stm32h7b0xx.bank1.cpu0 driver stm32h7x base 134217728 size 0 bus_width 0 chip_width 0 target stm32h7b0xx.cpu0} {name stm32h7b0xx.octospi1 driver stmqspi base 2415919104 size 0 bus_width 0 chip_width 0 target stm32h7b0xx.cpu0} # è·å–å†…ç½®flashçš„ä¿¡æ¯ $ flash info 0 \u003e Device: STM32H7Ax/7Bx flash size probed value 128k STM32H7 flash has a single bank Bank (0) size is 128 kb, base address is 0x08000000 #0 : stm32h7x at 0x08000000, size 0x00020000, buswidth 0, chipwidth 0 # 0: 0x00000000 (0x8000 32kB) not protected # 1: 0x00008000 (0x8000 32kB) not protected # 2: 0x00010000 (0x8000 32kB) not protected # 3: 0x00018000 (0x8000 32kB) not protected STM32H7Ax/7Bx - Rev: unknown (0x1001) # è·å–å¤–éƒ¨flashä¿¡æ¯ $ flash info 1 \u003e flash1 'win w25q64fv/jv' id = 0x1740ef size = 8192 KiB #1 : stmqspi at 0x90000000, size 0x00800000, buswidth 0, chipwidth 0 # 0: 0x00000000 (0x10000 64kB) not protected # 1: 0x00010000 (0x10000 64kB) not protected ... çœç•¥ #126: 0x007e0000 (0x10000 64kB) not protected #127: 0x007f0000 (0x10000 64kB) not protected flash1 'win w25q64fv/jv', device id = 0x1740ef, flash size = 8192Ki B (page size = 256, read = 0x03, qread = 0xeb, pprog = 0x02, mass_erase = 0xc7, sector size = 64 KiB, sector_erase = 0xd8) å¯ä»¥çœ‹åˆ°ï¼ŒOpenOCDç”šè‡³è¿å¤–éƒ¨flashçš„èŠ¯ç‰‡å‹å·ï¼ˆw25q64ï¼‰éƒ½èƒ½éƒ½è¯»å–åˆ°ã€‚é™¤äº†listå’Œinfoå‘½ä»¤å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨bankså’Œprobeå‘½ä»¤ï¼š\nè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨OpenOCDè¿›è¡Œçƒ§å½•çš„æ—¶å€™ï¼Œé€šå¸¸ä¸ä¼šå¯åŠ¨èŠ¯ç‰‡ã€‚å› æ­¤å¯¹äºå¤–ç½®SPI Flashï¼Œä¸€èˆ¬è¿˜éœ€è¦é€šè¿‡æ‰‹åŠ¨å†™å¯„å­˜å™¨çš„æ–¹å¼æ¥è¿›è¡Œæ—¶é’Ÿçš„åˆå§‹åŒ–å’ŒSPIå¤–è®¾çš„åˆå§‹åŒ–ã€‚è¿™æ ·æ‰èƒ½è®©OpenOCDæ­£ç¡®åœ°è¯†åˆ«åˆ°ç›®æ ‡èŠ¯ç‰‡ã€‚å¦‚æœä½ ä½¿ç”¨çš„èŠ¯ç‰‡åœ¨OpenOCDå·²ç»å†…ç½®ï¼Œé‚£ä¹ˆä¸€èˆ¬å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œç›´æ¥sourceå³å¯ã€‚å¦‚æœæ²¡æœ‰å†…ç½®æˆ–è€…ä½ æœ‰è‡ªå·±çš„è®¾ç½®ï¼ˆæ¯”å¦‚SPI GPIOé…ç½®ä¸åŒï¼‰ï¼Œé‚£ä¹ˆå°±éœ€è¦è‡ªå·±å†™äº†ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # OCTOSPI åˆå§‹åŒ– proc octospi_init { octo } { global a b mmw 0x58024540 0x000006FF 0\t;# RCC_AHB4ENR |= GPIOAEN-GPIOKEN (enable clocks) mmw 0x58024534 0x00284000 0\t;# RCC_AHB3ENR |= IOMNGREN, OSPI2EN, OSPI1EN (enable clocks) sleep 1\t;# Wait for clock startup mww 0x5200B404 0x03010111\t;# OCTOSPIM_P1CR: assign Port 1 to OCTOSPI1 mww 0x5200B408 0x00000000\t;# OCTOSPIM_P2CR: disable Port 2 # AF mapping can be found in datasheet. For h7b0, see DS13196, page 54 # PB02: OCSPI1_CLK, PB06: OCSPI1_NCS, PD11: OCSPI1_IO0, PD12: OCSPI1_IO1, PE2: OCSPI1_IO2, PD13: OCSPI1_IO3 # Generate the GPIO config: perl resources/gpio_gen.pl -c \"PB06:AF10:V, PB02:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PE02:AF09:V\" # mmw command: \"memory modify word, modify only given bits\" # usage: mmw \"address setbits clearbits\" # PB06:AF10:V, PB02:AF09:V, PD13:AF09:V, PD12:AF09:V, PD11:AF09:V, PE02:AF09:V # Port B: PB06:AF10:V, PB02:AF09:V mmw 0x58020400 0x00002020 0x00001010 ;# MODER mmw 0x58020408 0x00003030 0x00000000 ;# OSPEEDR mmw 0x5802040C 0x00000000 0x00003030 ;# PUPDR mmw 0x58020420 0x0A000900 0x05000600 ;# AFRL # Port D: PD13:AF09:V, PD12:AF09:V, PD11:AF09:V mmw 0x58020C00 0x0A800000 0x05400000 ;# MODER mmw 0x58020C08 0x0FC00000 0x00000000 ;# OSPEEDR mmw 0x58020C0C 0x00000000 0x0FC00000 ;# PUPDR mmw 0x58020C24 0x00999000 0x00666000 ;# AFRH # Port E: PE02:AF09:V mmw 0x58021000 0x00000020 0x00000010 ;# MODER mmw 0x58021008 0x00000030 0x00000000 ;# OSPEEDR mmw 0x5802100C 0x00000000 0x00000030 ;# PUPDR mmw 0x58021020 0x00000900 0x00000600 ;# AFRL # OCTOSPI1: memory-mapped 4-line read mode with 3-byte(24bits) addresses mww 0x52005130 0x00001000\t;# OCTOSPI_LPTR: deactivate CS after 4096 clocks when FIFO is full # Enter Memory mapped mode mww 0x52005000 0x3040000B\t;# OCTOSPI_CR: FMODE=0x11, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=0 mww 0x52005008 0x00160100\t;# OCTOSPI_DCR1: MTYP=0x0, FSIZE=0x16=22=2^(22+1), CSHT=0x00, CKMODE=0, DLYBYP=0 mww 0x5200500C 0x00000001\t;# OCTOSPI_DCR2: WRAPSIZE=0x00, PRESCALER=0+1 mww 0x52005108 0x00000008\t;# OCTOSPI_TCR: SSHIFT=0, DHQC=0, DCYC=0x8 mww 0x52005100 0x03002303\t;# OCTOSPI_CCR: SIOO=0, DMODE=011, ABMODE=0x0, ADSIZE=10, ADMODE=011, ISIZE=0x0, IMODE=011 mww 0x52005110 0x000000EB\t;# OCTOSPI_IR: INSTR=FastRead, 0xeb flash probe $a\t;# load configuration from CR, TCR, CCR, IR register values } # RCCæ—¶é’Ÿé…ç½®ï¼Œç„¶åè°ƒç”¨octospi_init $_CHIPNAME.cpu0 configure -event reset-init { global OCTOSPI1 global OCTOSPI2 mmw 0x52002000 0x00000004 0x0000000B\t;# FLASH_ACR: 4 WS for 64MHZ HCLK mmw 0x58024400 0x00000001 0x00000018\t;# RCC_CR: HSIDIV=1, HSI on mww 0x58024418 0x00000040\t;# RCC_CDCFGR1: CDCPRE=1, CDPPRE=2, HPRE=1 mww 0x5802441C 0x00000440\t;# RCC_CDCFGR2: CDPPRE2=2, CDPPRE1=2 mww 0x58024420 0x00000040\t;# RCC_SRDCFGR: SRDPPRE=2 mww 0x58024428 0x00404040\t;# RCC_PLLCKSELR: DIVM3=4, DIVM2=4, DIVM1=4, PLLSRC=HSI mww 0x5802442C 0x01ff0ccc\t;# RCC_PLLCFGR: PLLxRGE=8MHz to 16MHz, PLLxVCOSEL=wide mww 0x58024430 0x01010207\t;# RCC_PLL1DIVR: 64MHz: DIVR1=2, DIVQ1=2, DIVP1=2, DIVN1=8 mww 0x58024438 0x01010207\t;# RCC_PLL2DIVR: 64MHz: DIVR2=2, DIVQ2=2, DIVP2=2, DIVN2=8 mww 0x58024440 0x01010207\t;# RCC_PLL3DIVR: 64MHz: DIVR3=2, DIVQ3=2, DIVP3=2, DIVN3=8 mmw 0x58024400 0x01000000 0\t;# RCC_CR: PLL1ON=1 sleep 1 mmw 0x58024410 0x00000003 0\t;# RCC_CFGR: PLL1 as system clock sleep 1 adapter speed 4000 if { $OCTOSPI1 } { octospi_init 0 } } OpenOCDå®˜æ–¹æœ‰æä¾›æ ¹æ®ä½ çš„Pinçš„é…ç½®è‡ªåŠ¨ç”ŸæˆSPI GPIOé…ç½®çš„å·¥å…·ï¼Œåœ¨å®˜æ–¹åº“çš„gpio_gen.plæ–‡ä»¶ä¸­ï¼Œéœ€è¦perlæ‰§è¡Œã€‚è¿™æ ·å°±ä¸ç”¨å¯¹ç…§ç€æ‰‹å†Œä¸€ä¸ªä¸€ä¸ªåœ°è‡ªå·±å»ç®—å¯„å­˜å™¨çš„å€¼äº†ï¼Œéå¸¸çš„æ–¹ä¾¿ã€‚\n","description":"","tags":["keyboard","embedding"],"title":"OpenOCD","uri":"/posts/keyboard/openocd/"},{"categories":null,"content":"Makefile ç¨‹åºçš„ç¼–è¯‘å’Œé“¾æ¥ é¦–å…ˆéœ€è¦äº†è§£ä¸€ä¸‹ç¨‹åºçš„ç¼–è¯‘å’Œé“¾æ¥ã€‚ç¼–è¯‘å°±æ˜¯æŠŠæºä»£ç ç¼–è¯‘æˆç›®æ ‡ï¼ˆobjï¼‰æ–‡ä»¶ï¼Œè€Œé“¾æ¥æ˜¯æŠŠæ‰€æœ‰çš„ç›®æ ‡æ–‡ä»¶ï¼ˆåŒ…æ‹¬å‡½æ•°ã€å…¨å±€å˜é‡ç­‰ï¼‰é“¾æ¥ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ã€‚\nMakefileä»‹ç» ä½¿ç”¨makeå‘½ä»¤å°±éœ€è¦Makefileæ–‡ä»¶ã€‚Makefileæ–‡ä»¶ä¼šå‘Šè¯‰makeå‘½ä»¤å¦‚ä½•ç¼–è¯‘ã€é“¾æ¥ç¨‹åºã€‚\nMakefileè§„åˆ™ é¦–å…ˆçœ‹ä¸€ä¸‹Makefileä¸­æœ€åŸºç¡€çš„è§„åˆ™ï¼š\nç›®æ ‡ï¼šä¾èµ– å‘½ä»¤ è§„åˆ™å¾ˆç®€å•ï¼šå½“ä¾èµ–æ›´æ–°æ—¶ï¼Œæ‰§è¡Œå‘½ä»¤ç”Ÿæˆç›®æ ‡ã€‚è¿™ä¸ªç®€å•çš„è§„åˆ™å°±æ˜¯Makefileæœ€æ ¸å¿ƒçš„å†…å®¹ã€‚ä¸‹é¢ç¨å¾®ä»‹ç»ä¸€ä¸‹è¿™ä¸‰ä¸ªæ¦‚å¿µï¼š\nç›®æ ‡ï¼šç›®æ ‡æ–‡ä»¶ï¼Œå¯ä»¥æ˜¯ç¼–è¯‘äº§ç‰©ï¼ˆobjï¼‰ã€é“¾æ¥äº§ç‰©ï¼ˆå¯æ‰§è¡Œæ–‡ä»¶ï¼‰ï¼Œè¿˜å¯ä»¥æ˜¯æ ‡ç­¾ï¼ˆLabelï¼Œåé¢ä¼šè§£é‡Šï¼‰ ä¾èµ–ï¼šç”Ÿæˆç›®æ ‡æ‰€ä¾èµ–çš„æ–‡ä»¶æˆ–è€…å…¶ä»–ç›®æ ‡ å‘½ä»¤ï¼šä¸€èˆ¬æ˜¯shellå‘½ä»¤ï¼Œç”¨äºä»ä¾èµ–ç”Ÿæˆç›®æ ‡ã€‚makeä¼šæ¯”è¾ƒç›®æ ‡å’Œä¾èµ–çš„ç”Ÿæˆæ—¶é—´ï¼Œå¦‚æœä¾èµ–æ¯”è¾ƒæ–°ï¼Œé‚£ä¹ˆå°±ä¼šæ‰§è¡Œå‘½ä»¤ ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 # æœ€ç»ˆç›®æ ‡æ–‡ä»¶--å¯æ‰§è¡Œæ–‡ä»¶ edit : main.o kbd.o cc -o edit main.o kbd.o # ä¸­é—´ç›®æ ‡æ–‡ä»¶ main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c # ä¼ªç›®æ ‡æ–‡ä»¶ clean : rm edit main.o kbd.o å¯ä»¥çœ‹åˆ°é‡Œé¢å®šä¹‰çš„3ä¸ªç›®æ ‡ï¼Œç¬¬ä¸€ä¸ªæ˜¯ç”Ÿæˆeditå¯æ‰§è¡Œæ–‡ä»¶ï¼Œç¬¬äºŒä¸ªæ˜¯ç¼–è¯‘ä¸­é—´æ–‡ä»¶ï¼Œç¬¬ä¸‰ä¸ªæ˜¯cleanã€‚éœ€è¦æåˆ°çš„æ˜¯ï¼Œè¿™é‡Œç›®æ ‡cleanå¹¶ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œè€Œæ˜¯ä¸€ä¸ªlabelã€‚å¯ä»¥çœ‹åˆ°è¿™ä¸ªç›®æ ‡æ²¡æœ‰ä»»ä½•ä¾èµ–ï¼Œé‚£å°±è¯´æ˜åªè¦è¿è¡Œmake cleanï¼Œä¸‹é¢çš„å‘½ä»¤ä¸€å®šä¼šè¢«æ‰§è¡Œã€‚\nmakeæ˜¯å¦‚ä½•å·¥ä½œçš„ åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œ ç›´æ¥æ‰§è¡Œmakeé‚£ä¹ˆï¼š\nmakeä¼šå»æ‰¾Makefile Makefileä¸­ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªç›®æ ‡ï¼Œä½œä¸ºç»ˆæç›®æ ‡ ç„¶ååµŒå¥—åœ°å»æ ¹æ®ç»ˆæç›®æ ‡çš„æ‰€æœ‰ä¾èµ–å»æ‰¾å…¶ä»–ç›®æ ‡ï¼Œç„¶åæ ¹æ®éœ€è¦æ‰§è¡Œå‘½ä»¤ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œmakeä¸ä¼šç®¡å‘½ä»¤çš„é”™è¯¯ï¼Œå®ƒåªç®¡æ–‡ä»¶çš„ä¾èµ–æ€§ï¼Œåœ¨ä¾èµ–æ‰¾ä¸åˆ°çš„æƒ…å†µä¸‹ç›´æ¥æŠ¥é”™é€€å‡ºï¼Œè€Œå‘½ä»¤æŠ¥é”™åˆ™ä¸ä¼šã€‚\nMakefileä¸­çš„å˜é‡ å’ŒCè¯­è¨€çš„å®ç±»ä¼¼ï¼Œåœ¨Makefileä¸­å¯ä»¥å®šä¹‰å˜é‡ï¼Œä»¥æå‡Makefileçš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚å˜é‡çš„å®šä¹‰å’Œä½¿ç”¨å¾ˆç®€å•ï¼š\n1 2 3 4 # å®šä¹‰objectså˜é‡ objects = main.o kbd.o # ä½¿ç”¨objectså˜é‡ edit : $(objects) makeçš„è‡ªåŠ¨æ¨å¯¼ makeæœ‰è‡ªåŠ¨æ¨å¯¼çš„èƒ½åŠ›ï¼Œå³å®ƒä¼šè®°ä½å‰é¢çš„å‘½ä»¤ï¼Œè¿™æ ·å°±ä¸ç”¨æ¯æ¬¡å†å†™åŒæ ·çš„å‘½ä»¤äº†ã€‚ å¦å¤–ï¼Œmakeè¿˜æœ‰ä¸€ä¸ªåŠŸèƒ½å°±æ˜¯ï¼Œæ¯å½“makeçœ‹åˆ°ä¸€ä¸ª.oæ–‡ä»¶ï¼Œå®ƒéƒ½ä¼šæŠŠå¯¹åº”çš„.cæ–‡ä»¶åŠ å…¥åˆ°ä¾èµ–é‡Œé¢ã€‚ ä½¿ç”¨è¿™ä¸¤ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬çš„Makefileå°±å˜æˆäº†è¿™æ ·ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # å˜é‡å®šä¹‰ objects = main.o kbd.o # æœ€ç»ˆç›®æ ‡æ–‡ä»¶ edit : $(objects) cc -o edit $(objects) # ä¸­é—´ç›®æ ‡æ–‡ä»¶ main.o : defs.h kbd.o : defs.h command.h # ä¼ªç›®æ ‡æ–‡ä»¶ .PHONY : clean clean : rm edit $(objects) æ¸…ç©ºç›®æ ‡æ–‡ä»¶çš„è§„åˆ™ æ¯ä¸ªMakefileä¸­éƒ½åº”è¯¥å†™ä¸€ä¸ªæ¸…ç©ºç›®æ ‡æ–‡ä»¶ï¼ˆ.oå’Œæ‰§è¡Œæ–‡ä»¶ï¼‰çš„è§„åˆ™ï¼Œè¿™ä¸ä»…ä¾¿äºé‡ç¼–è¯‘ï¼Œä¹Ÿå¾ˆåˆ©äºä¿æŒæ–‡ä»¶çš„æ¸…æ´ã€‚è¿˜è®°çš„ä¹‹å‰ä¾‹å­é‡Œé¢çš„cleanç›®æ ‡å—ï¼Ÿæ²¡é”™å°±æ˜¯è¿™ä¸ªã€‚ä¸è¿‡æ›´å¥½çš„å†™æ³•æ˜¯ï¼š\n1 2 3 .PHONY : clean clean : -rm edit $(objects) è¿™é‡Œï¼Œ.PHONYè¡¨ç¤ºcleanæ˜¯ä¸€ä¸ªä¼ªç›®æ ‡ï¼Œè€Œrmå‰é¢çš„-è¡¨ç¤ºä¹Ÿè®¸æŸäº›æ–‡ä»¶å‡ºç°é—®é¢˜ï¼Œä½†ä¸è¦ç®¡ï¼Œç»§ç»­åšåé¢çš„äº‹ã€‚ å¦å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªä¸æˆæ–‡çš„è§„çŸ©æ˜¯ï¼Œcleanä¸€èˆ¬éƒ½æ”¾åœ¨Makefileçš„æœ€åï¼ˆç›¸å¯¹åº”åœ°ï¼Œç¬¬ä¸€ä¸ªç›®æ ‡æ˜¯é»˜è®¤ç›®æ ‡æˆ–è€…è¯´ç»ˆæç›®æ ‡ï¼‰ã€‚\nMakefileæ€»è¿° ä¸Šé¢ä»‹ç»äº†å…³äºmakeå’ŒMakefileçš„åŸºç¡€çŸ¥è¯†ï¼Œä¸‹é¢æˆ‘ä»¬å°±æ·±å…¥äº†è§£Makefileã€‚\né€‰æ‹©æ‰§è¡Œçš„Makefile é»˜è®¤æƒ…å†µä¸‹ï¼Œ makeä¼šä½¿ç”¨å½“å‰ç›®å½•ä¸‹çš„Makefileæˆ–è€…makefileã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨åœ°æŒ‡å®šMakefileï¼š\n1 2 make -f your_make_file make --file your_make_file å¼•ç”¨å…¶ä»–çš„Makefile åœ¨ä¸€ä¸ªMakefileä¸­ï¼Œä½ ä¹Ÿå¯ä»¥å¼•ç”¨å…¶å®ƒçš„Makefileï¼Œåªéœ€è¦ä½¿ç”¨includeå…³é”®å­—å³å¯ï¼š\n1 2 3 4 # å¼•å…¥å…¶ä»–makefile include foo.make *.mk $(many_makefiles) # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä¹Ÿç»§ç»­ -include not_exist.make è¢«å¼•å…¥çš„Makefileä¼šåŸæ ·åœ°æ”¾åœ¨è¿™é‡Œï¼ˆå½“ç„¶ï¼Œä¹Ÿæ˜¯é€’å½’åœ°æœç´¢æ‰€æœ‰ä¾èµ–çš„Makefileï¼‰ã€‚å¦‚æœåœ¨includeå‰é¢æœ‰ä¸€ä¸ª-ï¼Œåˆ™è¯´æ˜å³ä½¿æœ‰é—®é¢˜ä¹Ÿç»§ç»­ï¼ˆå’Œä¸Šé¢å‘½ä»¤é‡Œé¢çš„å«ä¹‰ä¸€æ ·ï¼‰ã€‚\nMakefileçš„ä¹¦å†™è§„åˆ™ åœ¨Makefileé‡Œï¼Œè§„åˆ™çš„é¡ºåºæ˜¯éå¸¸é‡è¦çš„ï¼Œè¿™æ˜¯å› ä¸ºMakefileä¸­åªæœ‰ä¸€ä¸ªç»ˆæç›®æ ‡ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œç¬¬ä¸€ä¸ªè§„åˆ™é‡Œé¢çš„ç›®æ ‡å°±æ˜¯ç»ˆæç›®æ ‡ï¼Œå¦‚æœç¬¬ä¸€ä¸ªè§„åˆ™é‡Œæœ‰å¾ˆå¤šç›®æ ‡ï¼Œé‚£å…¶ä¸­ç¬¬ä¸€ä¸ªç›®æ ‡æ˜¯ç»ˆæç›®æ ‡ã€‚æ•´ä¸ªmakeå‘½ä»¤æ‰€è¦å®Œæˆçš„ä¹Ÿæ˜¯è¿™ä¸ªç›®æ ‡ã€‚ åœ¨ä¸Šé¢ä»‹ç»ä¸­ï¼Œæˆ‘ä»¬å·²ç»ä»‹ç»äº†è§„åˆ™çš„å†™æ³•ã€‚å®é™…ä¸Šï¼Œè§„åˆ™è¿˜æœ‰ä¸€ç§å†™æ³•ï¼š\n1 targets : prerequisites ; command ç›®æ ‡å’Œä¾èµ–éƒ½å¯ä»¥æ˜¯å¤šä¸ªæ–‡ä»¶ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚è€Œå‘½ä»¤å¦‚æœå’Œç›®æ ‡/ä¾èµ–åœ¨åŒä¸€è¡Œï¼Œé‚£ä¹ˆå¿…é¡»åˆ†å·éš”å¼€ï¼›å¦‚æœä¸åœ¨åŒä¸€è¡Œï¼Œé‚£ä¹ˆæ–°è¡Œå¿…é¡»ä»¥TABå¼€å¤´ï¼š\n1 2 3 targets : prerequisites command # â†‘ æ³¨æ„è¿™é‡Œæ˜¯tab é€šé…ç¬¦ Makefileæ”¯æŒ3ç§é€šé…ç¬¦ï¼ˆwildcardï¼‰ï¼š*, ?,[...]ã€‚å®šä¹‰å’Œlinuxé‡Œé¢ä¸€æ ·ï¼Œä¸å†ç»†è¯´äº†ã€‚\nä¼ªç›®æ ‡ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬æåˆ°äº†.PHONYå®šä¹‰çš„æ˜¯ä¸€ä¸ªä¼ªç›®æ ‡ã€‚ä¸ºå•¥å«ä¼ªç›®æ ‡å‘¢ï¼Œè¿™æ˜¯å› ä¸ºå®é™…ä¸Šcleané‚£ä¸ªå‘½ä»¤å¹¶ä¸æ˜¯ä¸€ä¸ªç›®æ ‡æ–‡ä»¶ï¼Œè€Œåªæ˜¯ä¸€ä¸ªæ ‡ç­¾ã€‚æ‰§è¡Œmake cleanä¹Ÿä¸ç”Ÿæˆä»»ä½•ç›®æ ‡æ–‡ä»¶ï¼Œæ‰€ä»¥å«ä¼ªç›®æ ‡ã€‚ ä¼ªç›®æ ‡åœ¨Makefileä¸­å¾ˆæœ‰ç”¨ï¼Œæ¯”å¦‚å¦‚æœä½ æƒ³ä½¿ç”¨makeä¸€ä¸‹å­ç”Ÿæˆå¥½å¤šæ–‡ä»¶ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿™æ ·å†™ï¼š\n1 2 3 4 5 6 7 8 9 10 11 all : prog1 prog2 prog3 .PHONY : all prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o prog2 : prog2.o cc -o prog2 prog2.o prog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o è¿™é‡Œï¼Œæˆ‘ä»¬çš„ç»ˆæç›®æ ‡allå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªä¼ªç›®æ ‡ï¼Œç„¶åå®ƒä¾èµ–äº†ä¸‰ä¸ªç›®æ ‡ã€‚è¿™æ ·ï¼Œåœ¨æ‰§è¡Œmake allçš„æ—¶å€™ï¼Œä¸‹é¢ä¸‰ä¸ªç›®æ ‡ä¼šæ€»æ˜¯è¢«æ‰§è¡Œã€‚\né™æ€æ¨¡å¼è§„åˆ™ åœ¨å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å’Œä¾èµ–éƒ½æ˜¯å¾ˆç›¸ä¼¼çš„ï¼Œå¦‚ä¸‹é¢çš„è§„åˆ™ï¼š\n1 2 3 4 a.o : a.c $(CC) -c $(CFLAGS) a.c -o a.o b.o : b.c $(CC) -c $(CFLAGS) b.c -o b.o è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨æ¨¡å¼è§„åˆ™ï¼š\n1 2 targets: target_pattern : prereq_pattern commands è¿™é‡Œï¼Œç›®æ ‡è¿˜æ˜¯ä¿æŒä¸å˜ï¼Œä½†æ˜¯åé¢çš„ä¾èµ–å˜ä¸ºäº†ç”±æ¨¡å¼ç”Ÿæˆã€‚ä¸€èˆ¬æœ€å¸¸ç”¨çš„å°±æ˜¯%.o: %.cï¼Œå³æŠŠtargetä¸­æ‰€æœ‰çš„.oæ–‡ä»¶éƒ½æ›¿æ¢æˆ.cæ–‡ä»¶ï¼š\n1 2 objects = foo.o bar.o $(objects): %.o: %.c ç»“åˆMakefileä¸­çš„filterå‡½æ•°ï¼Œå°±å¯ä»¥æ‰¹é‡ç”Ÿæˆæˆåƒä¸Šä¸‡çš„.oæ–‡ä»¶äº†ï¼š\n1 2 3 files = foo.elc bar.o lose.o $(filter %.o,$(files)): %.o: %.c $(CC) -c $(CFLAGS) $\u003c -o $@ è¿™é‡Œï¼Œåˆæœ‰äº†ä¸‰ä¸ªæ–°çŸ¥è¯†ç‚¹ï¼šfilterå‡½æ•°ã€$\u003cå’Œ$@ã€‚filteræ˜¯makeè‡ªå¸¦çš„å‡½æ•°ï¼Œè€Œçš„å’Œ$\u003cå’Œ$@åˆ™æ˜¯è‡ªåŠ¨åŒ–å˜é‡ï¼Œ$\u003cè¡¨ç¤ºæ‰€æœ‰çš„ä¾èµ–ç›®æ ‡é›†ï¼ˆä¹Ÿå°±æ˜¯foo.cã€bar.cï¼‰ï¼Œ$@è¡¨ç¤ºç›®æ ‡é›†ï¼ˆä¹Ÿå°±æ˜¯foo.oã€bar.oï¼‰ã€‚å…³äºå‡½æ•°å’Œè‡ªåŠ¨åŒ–å˜é‡ï¼Œæˆ‘ä»¬åé¢è¿˜ä¼šè¯¦ç»†è¯´æ˜ã€‚\n","description":"","tags":["makefile","c","c++"],"title":"Learn Makefile - part 1","uri":"/posts/engineering/makefile/"},{"categories":null,"content":"ä½¿ç”¨FMCé©±åŠ¨8080æ¥å£å±å¹• FMC STM32ä¸­çš„FMCä¸»è¦æ˜¯ç”¨æ¥æ§åˆ¶å¤–æ¥å­˜å‚¨ã€‚ç”±äº8080æ¥å£çš„è¯»å†™æ—¶åºå’Œå¾ˆå¤šå¤–æ¥å­˜å‚¨å¾ˆç›¸ä¼¼ï¼Œæ‰€ä»¥FMCå¯ä»¥ç”¨æ¥ç›´æ¥é©±åŠ¨8080æ¥å£çš„å±å¹•ã€‚CubeMXä¸­ä¹Ÿæä¾›äº†ç›¸åº”çš„åŠŸèƒ½ï¼Œéå¸¸ç®€å•æ–¹ä¾¿ã€‚\nSTM32ä¼šæŠŠå¤–æ¥RAMæ˜ å°„ä¸º4ä¸ªbankï¼Œæ¯ä¸ªbankå¯¹åº”ä¸€ä¸ªåœ°å€åŒºã€‚FMCå¯ä»¥ç›´æ¥å†™æ•°æ®åˆ°è¿™äº›åœ°å€ï¼Œè€Œä¸ç”¨åœ¨æ‰‹å†™å¤æ‚çš„å¤–æ¥RAMæ—¶åºï¼š\n8080æ¥å£ FMCå’Œ8080å±å¹•çš„æ¥å£å¯¹åº”å¦‚ä¸‹ï¼š\nFMC D[0:15]ï¼šæ•°æ®çº¿D0~D15 FMC NExï¼šç‰‡é€‰ä¿¡å· FMC NOEï¼šè¯»ä½¿èƒ½ FMC NWEï¼šå†™ä½¿èƒ½ FMC Axï¼šåœ°å€çº¿ï¼Œå‘½ä»¤/æ•°æ®é€‰æ‹© ä¸‹å›¾æ˜¯FMCå’Œ8080æ¥å£çš„å…¸å‹è¿æ¥ï¼š\næ—¶åº åœ¨é…ç½®FMCé©±åŠ¨8080æ¥å£å±å¹•æ—¶ï¼Œæ—¶åºçš„é…ç½®éå¸¸é‡è¦ã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥äº†è§£ä¸‹8080æ¥å£çš„æ—¶åºï¼ˆä¸€èˆ¬å…·ä½“çš„æ—¶åºå€¼è¯·æŸ¥é˜…é©±åŠ¨èŠ¯ç‰‡çš„datasheetï¼‰ï¼š\nåœ¨é©±åŠ¨èŠ¯ç‰‡çš„datasheetä¸­æ‰¾åˆ°è¿™äº›å€¼ï¼Œåé¢åœ¨é…ç½®FMCæ—¶åºæ—¶ä¼šç”¨åˆ°ã€‚\nåœ¨æˆ‘ä½¿ç”¨æ˜¯st7789vé©±åŠ¨èŠ¯ç‰‡ä¸­ï¼Œè¿™äº›å€¼ä¸ºï¼š\nt_ah: 10 ns t_as: 0 ns t_cyc: 66 ns t_cyc(read): 160/450 nsï¼ˆè¯»å±å¹•RAM/è¯»IDï¼‰ t_wrlw: 15ns t_wrlr: 355 ns/45 nsï¼ˆè¯»å±å¹•RAM/è¯»IDï¼‰ t_wrhw: 15 ns t_wrhr: 90 ns t_ds: 10 ns t_dh: 10ns t_acc: \u003c 340ns/40nsï¼ˆè¯»å±å¹•RAM/è¯»IDï¼‰ã€‚t_accï¼š10nså¯¹äºè¯»æ¥è¯´ t_od: 20~80ns æ ¹æ®è¿™äº›æ—¶é—´ï¼Œå¦å¤–å¯ä»¥åœ¨CubeMXä¸­ï¼Œçœ‹åˆ°FMCè¿è¡Œçš„æ—¶é’Ÿé¢‘ç‡ï¼ˆå¦‚280MHZï¼‰ï¼Œé‚£ä¹ˆä¸€ä¸ªtickå°±æ˜¯3.57nsã€‚æ ¹æ®è¿™äº›å‚æ•°ï¼Œæˆ‘ä»¬å°±å¯ä»¥å»è®¾ç½®FMCçš„æ—¶é—´å‚æ•°ã€‚è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š\nå½“ç„¶è¿™é‡Œæ˜¯é’ˆå¯¹F103çš„FSMCã€‚å¯¹äºæˆ‘ä»¬ç”¨çš„h7b0 + st7789vçš„ç»„åˆï¼Œç»è¿‡æˆ‘å¥½é•¿æ—¶é—´çš„è°ƒè¯•ï¼Œå‘ç°åº”è¯¥åœ¨ä»£ç é‡Œé¢è¿™ä¹ˆè®¾ç½®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Timing */ Timing.AddressSetupTime = 0; Timing.AddressHoldTime = 0; Timing.DataSetupTime = 18; Timing.BusTurnAroundDuration = 0; Timing.CLKDivision = 2; Timing.DataLatency = 2; Timing.AccessMode = FMC_ACCESS_MODE_A; /* ExtTiming */ ExtTiming.AddressSetupTime = 0; ExtTiming.AddressHoldTime = 0; ExtTiming.DataSetupTime = 10; ExtTiming.BusTurnAroundDuration = 0; ExtTiming.CLKDivision = 2; ExtTiming.DataLatency = 2; ExtTiming.AccessMode = FMC_ACCESS_MODE_A; å…¶ä¸­ï¼ŒTimingæ˜¯è¯»æ—¶åºï¼Œè€ŒExtTimingæ˜¯å†™æ—¶åºã€‚\n","description":"","tags":["stm32"],"title":"FMC","uri":"/posts/keyboard/fmc/"},{"categories":null,"content":"TouchGFX æ–‡æ¡£é“¾æ¥ï¼šhttps://support.touchgfx.com/4.20/zh-CN/docs/category/introduction\nå­¦ä¹ TouchGFXçš„æ­¥éª¤ é¦–å…ˆï¼Œå¼€å‘åŸºäºstm32çš„TouchGFXåº”ç”¨å¯ä»¥åˆ†æˆå››ä¸ªæ­¥éª¤å¦‚ä¸‹å›¾ï¼š\nå‰ä¸¤ä¸ªæ­¥éª¤ç¡¬ä»¶é€‰æ‹©å’Œå¼€å‘æ¿é…ç½®å’ŒTouchGFXå…³ç³»ä¸å¤§ï¼Œå› æ­¤æˆ‘ä»¬ç›´æ¥è·³è¿‡ï¼Œä»TouchGFXæœ¬èº«çš„å¼€å‘å¼€å§‹ã€‚é¦–å…ˆæˆ‘ä»¬éœ€è¦å­¦ä¹ TouchGFXçš„æŠ½è±¡å±‚çš„å¼€å‘ï¼Œå³TouchGFX AL\nTouchGFXçš„æŠ½è±¡å±‚ï¼ˆALï¼‰ TouchGFX ALç”±ä¸¤ä¸ªéƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ç¡¬ä»¶æŠ½è±¡å±‚ï¼ˆHALï¼‰å’Œæ“ä½œç³»ç»ŸæŠ½è±¡å±‚ï¼ˆOSALï¼‰ã€‚é¡¾åæ€ä¹‰ï¼Œè¿™ä¸¤ä¸ªæŠ½è±¡å±‚å®é™…ä¸Šå°±å……å½“äº†TouchGFXå’Œç¡¬ä»¶ä»¥åŠæ“ä½œç³»ç»Ÿè¿æ¥çš„æ¡¥æ¢ï¼ŒæŠŠç¡¬ä»¶ã€TouchGFXå¼•æ“ä»¥åŠæ“ä½œç³»ç»Ÿè¿æ¥èµ·æ¥ï¼Œä»è€Œæ„å»ºåœ¨å•ç‰‡æœºä¸Šè¿è¡Œçš„å›¾å½¢ç•Œé¢ç¨‹åºã€‚\næŠ½è±¡å±‚çš„èŒè´£ é‚£ä¹ˆï¼ŒæŠ½è±¡å±‚å…·ä½“è´Ÿè´£å“ªäº›äº‹æƒ…å‘¢ï¼Ÿè¿™é‡Œæœ‰ä¸€ä¸ªè¡¨æ ¼ï¼Œé‡Œé¢åˆ—ä¸¾äº†æŠ½è±¡å±‚çš„å…·ä½“èŒè´£ã€‚ç®€å•æ¥è¯´ï¼Œå°±æ˜¯å¦‚ä¸‹å‡ ä»¶äº‹æƒ…ï¼š\nåœ¨TouchGFXå¼•æ“çš„ä¸»å¾ªç¯ä¸­ï¼Œä¼šè‡ªåŠ¨åœ°è°ƒç”¨ALå±‚çš„è‹¥å¹²ä¸ªé’©å­å‡½æ•°ï¼ˆæˆ–è€…è§¦å‘ä¸­æ–­ï¼‰ï¼Œä»è€Œå®Œæˆä¸Šè¿°çš„è¿™äº›äº‹æƒ…ï¼š\næˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯å»å¼€å‘è¿™äº›é’©å­å‡½æ•°ï¼Œä»è€Œæ­å»ºèµ·TouchGFXåˆ°ç¡¬ä»¶ä»¥åŠæ“ä½œç³»ç»Ÿçš„æ¡¥æ¢ã€‚ä¸‹é¢æˆ‘ä»¬ä¼šä»‹ç»æ¯ä¸ªé’©å­çš„å…·ä½“èŒè´£å’Œç”¨æ³•ã€‚\nå°†TouchGFX Engineä¸»å¾ªç¯ä¸æ˜¾ç¤ºå™¨ä¼ è¾“åŒæ­¥ æ­¤æ­¥éª¤èƒŒåçš„ä¸»è¦æ€æƒ³æ˜¯ï¼Œåœ¨æ¸²æŸ“å®Œæˆåé˜»å¡TouchGFX Engineä¸»å¾ªç¯ï¼Œä»è€Œç¡®ä¿åœ¨æ˜¾ç¤ºè®¾å¤‡å‡†å¤‡å¥½ä¹‹å‰ä¸å†äº§ç”Ÿå…¶ä»–å¸§ã€‚ ä¸€æ—¦æ˜¾ç¤ºè®¾å¤‡å‡†å¤‡å°±ç»ªï¼ŒOSALå‘è¢«é˜»å¡çš„Engineä¸»å¾ªç¯å‘å‡ºä¿¡å·ï¼Œä»¥ç»§ç»­äº§ç”Ÿï¼ˆç”Ÿäº§ã€æ¸²æŸ“ï¼‰æ˜¾ç¤ºå¸§ã€‚\nå¼€å‘è€…å¯ä»¥é€šè¿‡Rendering doneé’©å­ä»¥åŠDisplay Readyä¸­æ–­æ¥å®Œæˆè¿™ä¸ªæ­¥éª¤ï¼Œç„¶åé€šè¿‡ä½¿ç”¨OSALä¸­çš„OSWrappers::signalVSyncæ¥å®ŒæˆåŒæ­¥ã€‚\nä¸‹é¢ä¼šä»‹ç»Rendering doneå’ŒDisplay Readyã€‚\næ¸²æŸ“å®Œæˆï¼ˆRendering doneï¼‰ æ¸²æŸ“å®Œæˆé’©å­å³OSWrappers::waitForVSyncä¼šåœ¨æ¸²æŸ“å®Œæˆä¹‹åè¢«TouchGFXå¼•æ“è‡ªåŠ¨è°ƒç”¨ã€‚å¼€å‘è€…åœ¨å®ç°è¿™ä¸ªALæ–¹æ³•çš„æ—¶å€™ï¼Œå¿…é¡»é˜»å¡å›¾å½¢å¼•æ“ï¼Œç›´åˆ°æ¸²æŸ“ä¸‹ä¸€å¸§ã€‚æ ‡å‡†çš„å®ç°æ–¹å¼æ˜¯ä»ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ä¸­è¯»å–ï¼Œè¯»ä¸åˆ°åˆ™é˜»å¡ã€‚å½“OSWrapper::signalVSyncå‘å‡ºä¿¡å·æ—¶ï¼ŒOSWrappers::waitForVSyncä¼šæ”¶åˆ°ä¿¡å·å¹¶ä¸”è§£é™¤é˜»å¡ï¼Œç„¶åTouchGFXä¼šå¼€å§‹æ¸²æŸ“ä¸‹ä¸€å¸§ã€‚\næ˜¾ç¤ºå°±ç»ªï¼ˆDisplay Readyï¼‰ Display Readyä¸­æ–­åº”è¯¥æ¥è‡ªæ˜¾ç¤ºå±ï¼ˆæˆ–è€…ç›¸å…³controllerã€å®šæ—¶å™¨ï¼‰ï¼Œè¿™ä¸ªä¸­æ–­ä¼šè§¦å‘ä¸»å¾ªç¯åœæ­¢é˜»å¡å¹¶ç»§ç»­æ¸²æŸ“ä¸‹ä¸€å¸§ã€‚åœ¨ä¸­æ–­è§¦å‘ä¹‹åï¼Œå°±åº”è¯¥å»è°ƒç”¨OSWrappers::signalVsyncæ¥ä½¿ä¸Šä¸ªsectionä»‹ç»çš„OSWrappers::waitForVsyncè§£é™¤é˜»å¡ã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªåŸºäºRTOSçš„å®ç°ç¤ºä¾‹ï¼Œå¦‚æœä½¿ç”¨TouchGFX Generatorï¼ŒRTOSçš„ä»£ç ä¼šè‡ªåŠ¨åœ°ç”Ÿæˆå¥½ã€‚å…¶ä»–OSçš„éœ€è¦å‚è€ƒè¿™äº›ä»£ç è‡ªè¡Œå®ç°OSWrappersï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // RTOS_OSWrappers.cpp // static osMessageQId vsync_queue = 0; //Queue identifier is assigned elsewhere // åœ¨ä¸­æ–­ä¸­è°ƒç”¨è¯¥å‡½æ•°ï¼Œå¾€vsync_queueä¸­æ”¾ä¸€ä¸ªå€¼ï¼ŒwaitForVSyncæ”¶åˆ°ä¹‹åä¼šé€šçŸ¥å¼•æ“ç»§ç»­æ¸²æŸ“ä¸‹ä¸€å¸§ void OSWrappers::signalVSync() { if (vsync_queue) { osMessagePut(vsync_queue, dummy, 0); } } // åœ¨æ¸²æŸ“å®Œä¸€å¸§ä¹‹åï¼Œåœ¨è¿™é‡Œé˜»å¡ï¼Œç›´åˆ°æ”¶åˆ°é˜Ÿåˆ—ä¸­çš„å€¼ï¼Œç»§ç»­ä¸‹ä¸€å¸§æ¸²æŸ“ void OSWrappers::waitForVSync() { uint32_t dummyGet; // First make sure the queue is empty, by trying to remove an element with 0 timeout. osMessageQueueGet(vsync_queue, \u0026dummyGet, 0, 0); // Then, wait for next VSYNC to occur. osMessageQueueGet(vsync_queue, \u0026dummyGet, 0, osWaitForever); } è§¦æ‘¸ä¸å…¶ä»–å¤–éƒ¨äº‹ä»¶ æ¯”è¾ƒç®€å•ï¼Œçœ‹çœ‹å°±è¡Œã€‚è¯´ç™½äº†å°±ä¸¤ç§æ–¹å¼ï¼šè½®è¯¢/ä¸­æ–­ã€‚\nè§ï¼šhttps://support.touchgfx.com/4.20/zh-CN/docs/development/touchgfx-hal-development/touchgfx-architecture#report-touch-and-physical-button-events\nåŒæ­¥å¸§ç¼“å†²è®¿é—® å¸§ç¼“å†²ï¼ˆframebufferï¼‰æ˜¯æ•´ä¸ªå›¾å½¢ç³»ç»Ÿè¦æ“ä½œçš„æ ¸å¿ƒæ•°æ®ã€‚åœ¨æ•´ä¸ªæ˜¾ç¤ºè¿‡ç¨‹ä¸­ï¼Œä¼šæœ‰å¾ˆå¤šä¸ªç¡¬ä»¶è®¿é—®å¸§ç¼“å†²ï¼Œå¦‚CPUã€DMA2Dã€LTDCç­‰ï¼Œå› æ­¤TouchGFX ALå¿…é¡»æä¾›ä¸€ç§ä¿æŠ¤è¯¥å­˜å‚¨å™¨çš„æ–¹å¼ï¼Œä»è€Œä¸è®©æ•°æ®è¯»å†™å‡ºç°é—®é¢˜ï¼ˆæ¯”å¦‚CPUå†™ä¸€åŠï¼ŒDMA2Då°±å»è¯»å–äº†ï¼‰ã€‚\nTouchGFXé€šè¿‡OSWrappersä¸­çš„æ¥å£æ¥åŒæ­¥å¸§ç¼“å†²çš„è®¿é—®ï¼Œæœ€å¸¸è§„çš„å®ç°æ–¹å¼æ˜¯é€šè¿‡ä¿¡å·é‡æ¥ä¿æŠ¤å¸§ç¼“å†²çš„è®¿é—®ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥è‡ªè¡Œå®ç°å…¶ä»–æ–¹å¼ã€‚ä¸‹è¡¨å®šä¹‰äº†OSWrappersä¸­å¯¹è®¿é—®å¸§ç¼“å†²éœ€è¦ç”¨åˆ°çš„å‡½æ•°åˆ—è¡¨ï¼Œè¿™äº›å‡½æ•°å¯ä»¥ç”±TouchGFX Generatorç”Ÿæˆï¼ˆfor RTOSï¼‰ï¼Œä¹Ÿå¯ä»¥è‡ªè¡Œå®ç°ï¼š\næŠ¥å‘Šä¸‹ä¸€ä¸ªå¯ç”¨çš„å¸§ç¼“å†²åŒº TouchGFXå¿…é¡»åœ¨æ¯ä¸ªTickçŸ¥é“ä¸‹ä¸€ä¸ªå¯ç”¨çš„å¸§ç¼“å†²åŒºã€‚å¸§ç¼“å†²çš„ç­–ç•¥å¯ä»¥æœ‰å¤šç§ï¼Œä½¿ç”¨å•å¸§ç¼“å†²æˆ–åŒå¸§ç¼“å†²æ—¶ï¼ŒTouchGFX Engineå°†æ ¹æ®å¸§ç¼“å†²çš„å…¨å®½ã€é«˜åº¦å’Œä½å®½å°†åƒç´ æ•°æ®å†™å…¥å­˜å‚¨åŒºã€‚è€Œå¯¹äºéƒ¨åˆ†ç¼“å­˜ï¼Œå¯ä»¥å‚è§è¿™é‡Œã€‚\næ‰§è¡Œæ¸²æŸ“æ“ä½œ å¾ˆå¤šstm32çš„MCUéƒ½æä¾›äº†æŠŠå†…å®¹æ¸²æŸ“åˆ°å¸§ç¼“å†²çš„å¤–è®¾ï¼Œå¦‚DMA2Dã€‚åœ¨æ¸²æŸ“å†…å®¹åˆ°å¸§ç¼“å†²ä¹‹å‰ï¼ŒTouchGFXå¼•æ“ä¼šé¦–å…ˆæ£€æŸ¥HALå±‚æ˜¯å¦å®ç°äº†æ¸²æŸ“åŠŸèƒ½ã€‚å¦‚æœå®ç°äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªæ“ä½œå°±ä¼šç›´æ¥äº¤ç»™HALå±‚å®Œæˆï¼Œå¦åˆ™ä¼šäº¤ç»™CPUå¤„ç†ã€‚\nTouchGFXå¼•æ“ä¼šè°ƒç”¨HAL::getBlitCaps()æ¥è·å–ç¡¬ä»¶çš„èƒ½åŠ›æè¿°ï¼Œå¼€å‘è€…éœ€è¦å®ç°å¯¹åº”çš„HALå­ç±»æ¥æŠŠMCUçš„ç¡¬ä»¶æ¸²æŸ“èƒ½åŠ›æ·»åŠ è¿›æ¥ã€‚ç„¶åï¼ŒTouchGFXå¼•æ“ä¼šä½¿ç”¨HALç±»ä¸­å®šä¹‰çš„å…·ä½“æ“ä½œï¼Œå¦‚HAL::blitCopy()ç­‰ï¼Œå»æ‰§è¡Œå…·ä½“çš„æ¸²æŸ“å·¥ä½œã€‚å¦‚æœHALæ²¡æœ‰å®ç°å¯¹åº”çš„å‡½æ•°ï¼ŒTouchGFXä¼šé»˜è®¤ä½¿ç”¨CPUå®Œæˆè¿™äº›äº‹æƒ…ã€‚\næŠŠå¸§ç¼“å†²ä¼ è¾“åˆ°æ˜¾ç¤ºè®¾å¤‡ æ¯å½“ä¸€éƒ¨åˆ†å¸§ç¼“å†²æ¸²æŸ“å®Œæˆä¹‹åï¼ŒTouchGFXå¼•æ“ä¼šè°ƒç”¨Rendering of area completeé’©å­æ¥é€šçŸ¥ALå±‚å»æŠŠæ¸²æŸ“å®Œæˆçš„é‚£éƒ¨åˆ†å¸§ç¼“å†²ä¼ è¾“åˆ°æ˜¾ç¤ºè®¾å¤‡ã€‚\nRendering of area completeé’©å­ åœ¨ä»£ç é‡Œé¢ï¼Œè¿™ä¸ªé’©å­æ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼šHAL::flushFrameBuffer(Rect\u0026 rect)ã€‚åœ¨LTDCä¸­æˆ‘ä»¬ä¸ç”¨ç®¡è¿™ä¸ªä¸œè¥¿ï¼Œå› ä¸ºLTDCä¼šè‡ªåŠ¨æŠŠè¿™äº›äº‹æƒ…åšäº†ã€‚è¿™ä¸ªå‡½æ•°ç•™ç©ºå³å¯ã€‚è€Œå¯¹äºå…¶ä»–çš„æ¥å£ï¼Œå¦‚SPI/8080ï¼Œåˆ™éœ€è¦å¼€å‘è€…æ‰‹åŠ¨å®ç°è¯¥å‡½æ•°å®ç°å¯¹å¸§ç¼“å†²çš„ä¼ è¾“ã€‚\nå¯¹äºå¸¦GRAMçš„æ˜¾ç¤ºè®¾å¤‡ï¼ˆå³æ˜¾ç¤ºè®¾å¤‡é‡Œé¢ä¹Ÿæœ‰RAMï¼Œå¹¶å£å±å¸¸è§ï¼‰ï¼Œè¿™ä¸ªå‡½æ•°çš„å®ç°å…è®¸æ‰‹åŠ¨å‘èµ·å‘GRAMçš„å¸§ç¼“å†²åŒºåŸŸçš„ä¼ è¾“ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void TouchGFXHAL::flushFrameBuffer(const touchgfx::Rect\u0026 r) { HAL::flushFrameBuffer(rect); //call superclass //start transfer if not running already! if (!IsTransmittingData()) { const uint8_t* pixels = ...; // Calculate pixel address SendFrameBufferRect((uint8_t*)pixels, r.x, r.y, r.width, r.height); } else { ... // Queue rect for later or wait here } } TouchGFXçš„ç¡¬ä»¶æŠ½è±¡å±‚ï¼ˆHALï¼‰ äº†è§£äº†æŠ½è±¡å±‚å„ä¸ªé’©å­çš„èŒè´£ä¹‹åï¼Œé¦–å…ˆçœ‹ä¸€ä¸‹ç¡¬ä»¶æŠ½è±¡å±‚ï¼ˆHALï¼‰ã€‚\nTouchGFX Generator TouchGFX Generatoræ˜¯å¼€å‘TouchGFXåº”ç”¨çš„å¿…å¤‡å·¥å…·ï¼Œå’ŒCubeMXç±»ä¼¼ï¼ŒTouchGFX Generatoræ˜¯ç”¨æ¥ç”ŸæˆTouchGFXä»£ç çš„å·¥å…·ï¼Œé‡Œé¢æä¾›äº†æœ‰å…³æ˜¾ç¤ºçš„å„ç§é…ç½®ã€‚å’ŒCubeMXä¸åŒçš„æ˜¯ï¼ŒTouchGFXç”Ÿæˆçš„æ˜¯C++ä»£ç ï¼Œé€šè¿‡ç»§æ‰¿å‘å¼€å‘è€…æä¾›çµæ´»æ€§ã€‚\nåœ¨CubeMXé‡Œé¢å¼€å¯TouchGFX Generatorä¹‹åï¼Œç”Ÿæˆçš„ä»£ç ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªTouchGFXæ–‡ä»¶å¤¹å¹¶ä¸”æŠŠç›¸å…³ä»£ç æ–‡ä»¶éƒ½ç”Ÿæˆè¿›å»ã€‚ä¸‹é¢æ˜¯TouchGFXé¡¹ç›®çš„é¡¹ç›®ç»“æ„ï¼š\nâ”‚ .mxproject â”‚ myproject.ioc â”œâ”€â”€â”€Core â”œâ”€â”€â”€Drivers â”œâ”€â”€â”€EWARM â”œâ”€â”€â”€Middlewares â””â”€â”€â”€TouchGFX â”‚ ApplicationTemplate.touchgfx.part â”œâ”€â”€â”€App â”‚ app_touchgfx.c â”‚ app_touchgfx.h â””â”€â”€â”€target â”‚ STM32TouchController.cpp â”‚ STM32TouchController.hpp â”‚ TouchGFXGPIO.cpp â”‚ TouchGFXHAL.cpp â”‚ TouchGFXHAL.hpp â”‚ â””â”€â”€â”€generated OSWrappers.cpp TouchGFXConfiguration.cpp TouchGFXGeneratedHAL.cpp TouchGFXGeneratedHAL.hpp åœ¨è¿™é‡Œæˆ‘ä»¬åªå…³å¿ƒTouchGFXæ–‡ä»¶å¤¹ä¸‹çš„å†…å®¹ï¼š\nApplicationTemplate.touchgfx.partï¼šTouchGFX Designerå·¥ç¨‹ç›¸å…³çš„ä¸€äº›é…ç½®ï¼Œæ¯”å¦‚å±å¹•å°ºå¯¸ã€ä½æ·±ç­‰\nAppï¼šX-Cubeæ¥å£ï¼Œå…¶ä¸­app_touchgfx.cåŒ…å«MX_TouchGFX_Process(void)å’ŒMX_TouchGFX_Init(void)å‡½æ•°ï¼Œè¿™äº›å‡½æ•°ç”¨äºåœ¨CubeMXç”Ÿæˆçš„ä¸»å‡½æ•°ä¸­åˆå§‹åŒ–TouchGFXä»¥åŠå¼€å§‹ä¸»å¾ªç¯\ntarget/generatedï¼šæ³¨æ„è¿™ä¸ªç›®å½•æ˜¯åªè¯»çš„ï¼ŒåŒ…å«æ ¹æ®ç›¸å…³é…ç½®ç”Ÿæˆçš„TouchGFXæºæ–‡ä»¶ã€‚ç®€å•æ¥è¯´ï¼ŒTouchGFXGeneratedHALæ˜¯è‡ªåŠ¨ç”Ÿæˆçš„HALå±‚ï¼ŒOSWrappersæ˜¯OSALå±‚ã€‚è€ŒTouchGFXConfigurationæ˜¯TouchGFXçš„ç›¸å…³é…ç½®ï¼ŒåŒ…å«ä¸€ä¸ªç”¨äºæ„å»ºHALçš„å‡½æ•°ä»¥åŠå¯åŠ¨TouchGFXä¸»å‡½æ•°çš„å‡½æ•°ã€‚\ntargetï¼šè¿™ä¸ªç›®å½•æ˜¯å¼€å‘è€…çš„ä»£ç æ‰€åœ¨ï¼Œå¯ä»¥ç»§æ‰¿target/generatedé‡Œé¢çš„ç±»ä»è€Œå®ç°å¯¹HAL/OSALçš„è¦†å†™ã€‚ä¹Ÿå¯ä»¥æ‹“å±•HALï¼Œæ·»åŠ æ–°åŠŸèƒ½ç­‰ç­‰ã€‚ç”Ÿæˆçš„STM32TouchController.cppæ–‡ä»¶åŒ…å«äº†è§¦æ‘¸æ§åˆ¶çš„ç©ºæ¥å£ï¼Œè€ŒTouchGFXHAL.cppå®šä¹‰äº†TouchGFXGeneratedHALçš„å­ç±»ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºHALæ¥è¯´ï¼ŒTouchGFXHALä¼šç»§æ‰¿TouchGFXGeneratedHALï¼Œç”¨æˆ·å¯èƒ½éœ€è¦ä¿®æ”¹TouchGFXHALæ¥å®ŒæˆHALçš„å…¶ä»–é…ç½®ã€‚HALçš„ä¸€èˆ¬æ¶æ„å¦‚ä¸‹æ‰€ç¤ºï¼š\n","description":"","tags":["keyboard","stm32"],"title":"TouchGFX","uri":"/posts/keyboard/touchgfx/"},{"categories":null,"content":"QMK - 2 QMK's source code can be found at Github: https://github.com/qmk/qmk_firmware.\nLearn QMK's source code Basic project structure There are three logic levels in QMK project:\nCore(_quantum) -- Keyboard/Revision(_kb) -- Keymap(_user) In QMK, many custom functions have a _kb or _user suffix. By convention, when you customize your keyboard or a revision of your keyboard, using _kb functions. And when you customize your keymap, use _user functions.\nRemember to call _user function at the beginning of your _kb functions. Otherwise, those _user functions won't be execute any more.\nProgram Entry Like other C programs, QMK's entry is a main() function. QMK's main function is at quantum/main.c, which is the entrance of all the QMK firmware.\nQMK's main() function is quite simple: setup platform/protocol/keyboard and then run the infinite main loop. The main loop will call protocol_task(), then the keyboard_task() in quantum/keyboard.c is called. keyboard_task() is where the keyboard specific functionality is dispatched, such as matrix scanning, mouse handling and controlling keyboard status LEDs.\nMatrix Scanning Matrix scanning is the core of a keyboard firmware. QMK provides built in scanning algorithm, you just need to define your matrix layout.\nTo declare your own key matrix, a C macro is used. For example, to define a 2*2 matrix, you can use the following code\n1 2 3 4 5 6 7 #define LAYOUT( \\ k00, k01, \\ k10, k11 \\ ) { \\ {k00, k01}, \\ {k10, k11} \\ } Note that you may not have a key at every position in the matrix, you can use keycode KC_NO in the second part of the macro. A typical numpad layout can be defined using the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define LAYOUT( \\ k00, k01, k02, k03, \\ k10, k11, k12, k13, \\ k20, k21, k22, \\ k30, k31, k32, k33, \\ k40, k42 \\ ) { \\ { k00, k01, k02, k03 }, \\ { k10, k11, k12, k13 }, \\ { k20, k21, k22, KC_NO }, \\ { k30, k31, k32, k33 }, \\ { k40, KC_NO, k42, KC_NO } \\ } In keymap, you can use this macro to map keycodes of actual physical keys to matrix keys:\n1 2 3 4 5 6 7 8 9 const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = LAYOUT( KC_NUM, KC_PSLS, KC_PAST, KC_PMNS, KC_P7, KC_P8, KC_P9, KC_PPLS, KC_P4, KC_P5, KC_P6, KC_P1, KC_P2, KC_P3, KC_PENT, KC_P0, KC_PDOT ) } You can see the keymap has 3 dimensions. The first dimension is actual layer. Each layer has MATRIX_ROWS * MATRIX_COLS keys. In the given example, we defined only one layer.\nDetect key strokes At each matrix scanning loop, the matrix scanning function returns the current state of the matrix. QMK stores the result of last matrix scan, and compares with the current scanning result to determine which key is pressed or released. The the key code is dispatched to process_record() function.\nProcess Record Function process_record() is not complex, it contains a chain of events(c functions). Many of then depends on rules defined in rules.mk. The full events list is here. If any of them returns false, the following functions won't be executed.\nCustomize keymap You can create your own key code with QMK. To create your key code, you need to define an enum in keymap.c first:\n1 2 3 4 enum my_keycodes { FOO = SAFE_RANGE, BAR }; QMK provides a macro SAFE_RANGE which ensure that you got a unique and correct key code.\nProgram a key When you want to overwrite your key's function or define the functionality of your new keycode, you can use process_record_kb() or process_record_user(). Remember this process_record() function? Your customized process_record_kb/user() function is similar: return false if you want to overwrite this key or attach new functionality to the key, otherwise just return true. Here is an example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Example of process_record_ bool process_record_user(uint16_t keycode, keyrecord_t *record) { switch (keycode) { case FOO: // Set your new key if (record-\u003eevent.pressed) { // æŒ‰ä¸‹æ—¶åšäº›ä»€ä¹ˆ } else { // æŠ¬èµ·æ—¶åšäº›ä»€ä¹ˆ } // è¦†ç›–å·²æœ‰åŠŸèƒ½ return false; // è·³è¿‡æ­¤é”®çš„æ‰€æœ‰è¿›ä¸€æ­¥å¤„ç† case KC_ENTER: // ç»™å›è½¦å¢åŠ æ–°çš„åŠŸèƒ½ // å½“æŒ‰ä¸‹å›è½¦æ—¶æ’­æ”¾éŸ³ç¬¦ if (record-\u003eevent.pressed) { PLAY_SONG(tone_qwerty); } // è¿”å›trueåˆ™ä¸è¦†ç›–å…¶åŸæ¥çš„åŠŸèƒ½ï¼Œè¿”å›falseåˆ™ä¸ºè¦†ç›– return true; // è®©QMKå“åº”å›è½¦æŒ‰ä¸‹/æŠ¬èµ·äº‹ä»¶ default: // å…¶ä»–é”®ä½éƒ½ä¿æŒä¸å˜ï¼ˆè¿”å›trueï¼‰ return true; // æ­£å¸¸å“åº”å…¶ä»–é”®ç  } } The definition of input param recordï¼š\n1 2 3 4 5 6 7 8 9 10 keyrecord_t record { keyevent_t event { keypos_t key { uint8_t col uint8_t row } bool pressed uint16_t time } } record has the input key's col/row, whether it's pressed and the press time.\nKeyboard Initialization You can also customize the initialization process of the keyboard. There are 3 functions that you can overwrite:\nkeyboard_pre_init_*: happens at the early start of the firmware's setup process, can be used to initialize your hardware matrix_init_*: happens midway of the firmware's setup process. At this moment, hardware is initialized, but features may not be yet keyboard_post_init_*: happens at the end of the firmware's setup process. Hardware and most features are ready, you should put most of your customization code here Keyboard Pre Initialization keyboard_pre_init_* is used to initialize your own extra hardwares. Note that this process starts very early -- even earlier than the USB starts. The following is an example to set up LEDs using keyboard_pre_init_*:\n1 2 3 4 5 6 7 8 9 10 void keyboard_pre_init_user(void) { // Call the keyboard pre init code. // Set our LED pins as output setPinOutput(B0); setPinOutput(B1); setPinOutput(B2); setPinOutput(B3); setPinOutput(B4); } Matrix Initialization Code matrix_init_* is called when the matrix is initialized, you can overwrite the low-level matrix configuration here. If you want to change the default pin initialization method, you can use the following method:\nvoid matrix_init_pins(void): GPIO pin initialization. By default it will initialize pins set in MATRIX_ROW_PINS and MATRIX_COL_PINS, and the setup method is defined using ROW2COL, COL2ROW or DIRECT_PINS. Keyboard Post Initialization Code You most customization code should be wrote here. At this moment, most hardware and features are initialized, you can take changes to certain features as you want.\nThe following is an example about setting up RGB lights:\n1 2 3 4 5 6 void keyboard_post_init_user(void) { // Call the post init code. rgblight_enable_noeeprom(); // enables Rgb, without saving settings rgblight_sethsv_noeeprom(180, 255, 255); // sets the color to teal/cyan without saving rgblight_mode_noeeprom(RGBLIGHT_MODE_BREATHING + 3); // sets mode to Fast breathing without saving } QMK configuration files We've already knew that there are some configuration files in QMK when you're going to create your own keyboard, such as info.json, rules.mk. In this section, we'll learn how to customize those files.\nNOTE: there are many configs that you can set at multiple files. In this case, when you try to compile the firmware, qmk would complain and tell you which config will be used:\nPrune your configurations accordingly.\ninfo.json You can config the hardware and enabled features in info.json. The full reference of info.json can be found here: https://docs.qmk.fm/#/reference_info_json.\nHardware configuration At the top of info.json, there are some configs about the manufacturer and hardware that you can customize:\n1 2 3 4 5 6 7 8 9 10 { \"keyboard_name\": \"your_keyboard_name\", \"manufacturer\": \"You\", \"maintainer\": \"You\", \"usb\": { \"vid\": \"0xFEED\", \"pid\": \"0x0000\", \"device_version\": \"1.0.0\" } } in which, the manufacturer and keyboard_name will be displayed in the list of USB devices on Windows and MacOS. You can also choose your USB's vid and pid.\nMatrix configuration You can also define the GPIO pins which are used for matrix scanning in info.json:\n1 2 3 4 5 6 { \"matrix_pins\": { \"cols\": [\"C1\", \"C2\", \"C3\", \"C4\"], \"rows\": [\"D1\", \"D2\", \"D3\", \"D4\"] }, } Then declare your diode direction in your PCB:\n1 \"diode_direction\": \"ROW2COL\" Layout configuration Next you can config the layout of your keyboard:\n1 2 3 4 5 6 7 8 9 10 \"layouts\": { \"LAYOUT_fancer\": { \"layout\": [ { \"matrix\": [0, 0], \"x\": 0, \"y\": 0 }, { \"matrix\": [0, 1], \"x\": 1, \"y\": 0 }, { \"matrix\": [1, 0], \"x\": 0, \"y\": 1 }, { \"matrix\": [1, 1], \"x\": 1, \"y\": 1 } ] } } For more available configurations, see: https://docs.qmk.fm/#/reference_info_json\nconfig.h config.h is the basic header of the firmware. All configurations here are persist over the whole project. There are lots of configurations available, see this document.\nI list some most commonly used configs in config.h here:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // vendor id #define VENDOR_ID 0x1234 // product id #define PRODUCT_ID 0x1234 // device version(often used for revisions) #define DEVICE_VER 0 // manufacturer #define MANUFACTURER MY_LAB // keyboard name #define PRODUCT fancer // number of rows/cols #define MATRIX_ROWS 2 #define MATRIX_COLS 2 // MCU pins of rows, from top to down(might be overwritten by user, see https://docs.qmk.fm/#/custom_quantum_functions?id=low-level-matrix-overrides) #define MATRIX_ROW_PINS { A1, A3 } // MCU pins of cols, from left to right(might be overwritten as well) #define MATRIX_COL_PINS { A2, A4 } // IO delay in ms between changing matrix pin and reading values #define MATRIX_IO_DELAY 30 // the direction of diode, COL2ROW means the black mark on your diode is facing to the rows #define DIODE_DIRECTION COL2ROW // debounce threshold in ms #define DEBOUNCE 5 // layout of the keyboard #define LAYOUT( \\ k00, k01, \\ k10, k11, \\ ) { \\ { k00, k01, }, \\ { k10, k11, }, \\ } rules.mk rules.mk defines some built options when compiling the firmware. It's actually a makefile which can be recognized with tools like cmake. In rules.mk you can set building configurations, MCU options and enable certain features.\nBuild Options FIRMWARE_FORMAT: defines the compiled firmware's format, like .hex or .bin SRC: added sources files for compilation/linking LAYOUTS: a list of layouts that this keyboard supports. See Matrix Scanning section. LTO_ENABLE: add it to reduce the size of your firmware Feature Options You can also enable/disable many features such as MAGIC Actions, AUDIO, RGBLIGHT, etc. in rules.mk. The full list can be found here: https://docs.qmk.fm/#/config_options?id=feature-options.\nHere is an example of rules.mk of owlab suit80:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # MCU name MCU = atmega32u4 # Bootloader selection BOOTLOADER = atmel-dfu # Build Options # change yes to no to disable # BOOTMAGIC_ENABLE = yes # Enable Bootmagic Lite MOUSEKEY_ENABLE = yes # Mouse keys EXTRAKEY_ENABLE = yes # Audio control and System control CONSOLE_ENABLE = no # Console for debug COMMAND_ENABLE = no # Commands for debug and configuration NKRO_ENABLE = yes # Enable N-Key Rollover BACKLIGHT_ENABLE = no # Enable keyboard backlight functionality RGBLIGHT_ENABLE = no # Enable keyboard RGB underglow AUDIO_ENABLE = no # Audio output ","description":"","tags":["keyboard","qmk"],"title":"Learn QMK - 2","uri":"/posts/keyboard/qmk-2/"},{"categories":null,"content":"STM32 - 3 æ—¶é’Ÿå’ŒUSBæ¥å£\næ—¶é’Ÿ ä¸€äº›ç¼©å†™ å¤–éƒ¨é«˜é€Ÿæ—¶é’Ÿï¼šHSE å†…éƒ¨é«˜é€Ÿæ—¶é’Ÿï¼šHSI æ—¶é’Ÿå’Œå¤ä½æ§åˆ¶ï¼šRCCï¼ˆReset and Clock Control) STM32çš„æ—¶é’Ÿç³»ç»Ÿç®€ä»‹ è¿™ä¸ªå›¾æ˜¯å®˜æ–¹æ‰‹å†Œçš„æ—¶é’Ÿæ ‘çš„ç®€åŒ–ç‰ˆï¼Œä¸ºäº†ä¾¿äºç†è§£ï¼Œå¯ä»¥ä»ä¸­é—´çš„SYSCLKï¼ŒæŠŠæ•´ä¸ªæ—¶é’Ÿæ ‘åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šå·¦è¾¹ä¸ºæ—¶é’Ÿæºï¼Œå³è¾¹ä¸ºç‰‡ä¸Šå¤–è®¾ã€‚\nç³»ç»Ÿæ—¶é’Ÿæ¥æºé€‰æ‹© å¯ä»¥çœ‹åˆ°SYSCLKæ—è¾¹çš„é‚£ä¸ªæ¢¯å½¢ï¼Œå°±æ˜¯ä¸€ä¸ªé€‰æ‹©å™¨ï¼Œç”±ä»–æ¥é€‰æ‹©STM32ç©¶ç«Ÿç”¨å“ªä¸ªæ—¶é’Ÿæºã€‚HSEã€HSIå°±ä¸å†å¤šè¯´ï¼Œä¸­é—´çš„é‚£ä¸ªPLLå«é”ç›¸ç¯ï¼Œç”¨æ¥åšå€é¢‘çš„ï¼Œå°±æ˜¯æŠŠHSIæˆ–HSEåšä¸€å®šçš„å€é¢‘ä¹‹åå†ä½œä¸ºæ•´ä¸ªç‰‡ä¸Šå¤–è®¾çš„æ—¶é’Ÿè¾“å…¥ã€‚\nç‰‡ä¸Šå¤–è®¾æ—¶é’Ÿ SYSCLKå³è¾¹ï¼Œä¼šé¦–å…ˆè¿‡ä¸€ä¸ªAHBæ€»çº¿è¿›è¡Œåˆ†é¢‘ï¼ŒæŠŠè¾“å…¥çš„æ—¶é’Ÿé¢‘ç‡åˆ†æˆ1/nï¼Œå˜æˆäº†HCLKã€‚ç„¶åHCLKä¸€åˆ†ä¸ºäºŒï¼Œ å»ä¾›ç»™ç‰‡ä¸Šå¤–è®¾ã€‚å…¶ä¸­APB1çš„æœ€å¤§é¢‘ç‡æ¯”APB2ä½ä¸€äº›ï¼Œå³APB2çš„æ—¶é’Ÿçš„æœ€é«˜é¢‘ç‡æä¸€äº›ï¼ŒåŠŸè€—ä¹Ÿé«˜ä¸€äº›ï¼Œé€‚åˆé«˜é¢‘çš„ç‰‡ä¸Šå¤–è®¾ã€‚\nAPB1å’ŒAPB2æ˜¯ä¸¤æ¡æ€»çº¿ï¼Œéƒ½æŒ‚è½½åœ¨AHBæ€»çº¿ä¸Š é©±åŠ¨Cortex-M3å†…æ ¸çš„æ—¶é’Ÿæ˜¯HCLK STM32æ—¶é’Ÿç¼–ç¨‹æ¥å£ API é¦–å…ˆäº†è§£ä¸¤ä¸ªAPIï¼š\n1 2 3 4 5 // é…ç½®æ—¶é’Ÿæ¥æºï¼Œå³ä¸Šé¢å›¾ä¸­çš„å·¦åŠéƒ¨åˆ† HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef *RCC_OscInitStruct); // é…ç½®SYSCLKã€HCLKã€PCLK1ã€PCLK2æ—¶é’Ÿï¼Œå³ä¸Šé¢å›¾ä¸­çš„å³åŠéƒ¨åˆ† HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef *RCC_ClkInitStruct, uint32_t Flatency); æ—¶é’Ÿé…ç½® é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å»é…ç½®æ—¶é’Ÿæ¥æºã€‚ä»ä¸Šé¢çš„APIå¯ä»¥çœ‹åˆ°ï¼Œé…ç½®æ—¶é’Ÿæºéœ€è¦ä¸€ä¸ªRCC_OscInitTypeDefï¼Œå…¶å®šä¹‰å¯ä»¥å»çœ‹æºç ï¼Œç°åœ¨æˆ‘ä»¬å°±ä»¥å¤–éƒ¨æ—¶é’Ÿæº+9å€é¢‘é”ç›¸ç¯ä¸ºä¾‹ï¼Œçœ‹çœ‹æ€ä¹ˆé…ç½®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 RCC_OscInitTypeDef oscInit; // é…ç½®æ—¶é’Ÿç±»å‹ä¸ºHSE oscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE; // é…ç½®HSEå¼€å¯æˆ–å…³é—­ oscInit.HSEState = RCC_HSE_ON; // é…ç½®æ‰“å¼€é”ç›¸ç¯PLL oscInit.PLL.PLLState = RCC_PLL_ON; // è®¾ç½®PLLçš„æ—¶é’Ÿæ¥æº oscInit.PLL.PLLSource = RCC_PLLSOURCE_HSE; // è®¾ç½®PLLçš„å€é¢‘å€æ•°ä¸º9å€é¢‘ oscInit.PLL.PLLMUL = RCC_PLL_MUL9; // è®¾ç½®æ—¶é’Ÿæº HAL_RCC_OscConfig(\u0026oscInit); è®¾ç½®å®Œæ—¶é’Ÿæºä¹‹åï¼Œå°±å¯ä»¥è®¾ç½®åç»­çš„æ—¶é’Ÿäº†ï¼Œä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 RCC_ClkInitTypeDef clkInit; // è¢«è®¾ç½®çš„æ—¶é’Ÿç±»å‹ï¼Œæˆ‘ä»¬é€‰æ‹©SYSCLKå’ŒHCLK clkInit.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK; // è®¾ç½®SYSCLKç­‰äºPLLæ—¶é’Ÿæº clkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLL // é€šè¿‡è®¾ç½®AHBåˆ†é¢‘å™¨åˆ†é¢‘å€ç‡ä¸º1ï¼Œæ¥è®¾ç½®HCLK=SYSCLK clkInit.AHBCLKDivider = RCC_SYSCLK_DIV1; // æœ€åè®¾ç½®æ—¶é’Ÿ HAL_RCC_ClockConfig(\u0026clkInit, FLASH_LATENCY_2); æœ€åä¸€ä¸ªå‚æ•°çš„FLASH_LATENCYé…ç½®ï¼Œå®é™…ä¸Šå’Œä½ è®¾ç½®çš„æ—¶é’ŸSYSCLKæœ‰å…³ç³»ï¼Œå…·ä½“å¤šå°‘é¢‘ç‡çš„æ—¶é’Ÿå¯¹åº”å¤šå°‘FLASH_LATENCYéœ€è¦å»åº“é‡Œé¢çš„ä»£ç é‡Œçœ‹æ³¨é‡Šã€‚\nåˆ°è¿™é‡Œï¼Œæ—¶é’Ÿå°±é…ç½®å®Œäº†ã€‚æ›´å¤šçš„æ—¶é’Ÿé…ç½®å¯ä»¥å»çœ‹HALåº“çš„æºä»£ç æ‰‹å†Œã€‚\nUSB USBä»‹ç» é¦–å…ˆéœ€è¦ä»‹ç»ä¸‹usbçš„åŸºæœ¬æ¦‚å¿µå’Œå‚æ•°ï¼Œè¿™å¯¹äºåœ¨stm32ä¸Šä½¿ç”¨usbè®¾å¤‡æœ‰å¾ˆå¤§çš„å¸®åŠ©ã€‚\nUSBé»˜è®¤æ˜¯ä¸ª4pinè®¾å¤‡ï¼Œå…¶ä¸­ä¸­é—´çš„D+å’ŒD-åˆ†åˆ«ä¼šæ¥ä¸€ä¸ª15Kçš„ä¸‹æ‹‰ç”µé˜»ï¼š\næ‰€ä»¥ï¼Œé»˜è®¤D+å’ŒD-é»˜è®¤éƒ½æ˜¯ä½ç”µå¹³ã€‚ç„¶è€Œï¼Œåœ¨USBæ’å¤´ä¸Šé¢ï¼ŒD+ä¼šæ¥ä¸€ä¸ª1.5Kçš„ä¸Šæ‹‰ç”µé˜»ï¼Œè¿™æ ·çš„è¯ä¸€æ—¦æ’å…¥USBè®¾å¤‡ï¼ŒD+å°±ä¼šè¢«æ‹‰åˆ°é«˜ç”µå¹³ï¼Œäº§ç”Ÿä¸€ä¸ªä¸­æ–­è¡¨åè®¾å¤‡å·²è¿æ¥ã€‚\nUSBåˆ†ä¸ºä¸»æœºå’Œè®¾å¤‡ï¼Œæ‰€æœ‰çš„é€šä¿¡éƒ½æ˜¯ç”±ä¸»æœºï¼ˆæ¯”å¦‚PCï¼‰å‘èµ·çš„ï¼Œè¾“å…¥å’Œè¾“å‡ºä¹Ÿéƒ½æ˜¯é’ˆå¯¹ä¸»æœºè€Œè¨€ã€‚\nUSBçš„ä¼ è¾“ç±»å‹ ä¸€å…±4ç§ï¼š\næ§åˆ¶ï¼šä¸€èˆ¬æ˜¯ç”¨äºåˆæ¬¡è¿æ¥çš„åˆå§‹åŒ–ï¼Œæ¯”å¦‚åˆ†é…åœ°å€ã€è·å–USBè®¾å¤‡ä¿¡æ¯ç­‰ ä¸­æ–­ï¼šä¸»æœºä¼šå®šæ—¶è¯¢é—®æ˜¯å¦æœ‰æ•°æ®ï¼Œè¿™å°±æ˜¯é¼ æ ‡ã€é”®ç›˜ç­‰è®¾å¤‡çš„é€šä¿¡æ¨¡å¼ æ‰¹é‡ï¼šå¤§æ–‡ä»¶ä¼ è¾“ åŒæ­¥ï¼šæ•°æ®åŒæ­¥ï¼Œæ¯”å¦‚æ‘„åƒå¤´ USBä¾›ç”µ USBå¯ä»¥ç»™è®¾å¤‡ä¾›ç”µï¼Œè¿™æ˜¯é€šè¿‡VBUSæ¥ä¾›ç”µçš„ã€‚USB2.0ç»™ä½åŠŸè€—è®¾å¤‡ä¾›ç”µç”µæµæœ€å¤šå¯ä»¥100maã€‚å¯¹äºé«˜åŠŸè€—è®¾å¤‡ï¼Œæœ€é«˜ä¸è¶…è¿‡500maã€‚\nUSBé…ç½®æè¿°ç¬¦ ä¸Šé¢è¯´çš„è¿™äº›é…ç½®ï¼Œæ¯”å¦‚æ˜¯å¦ä½åŠŸè€—è®¾å¤‡ç­‰ï¼Œéƒ½æ˜¯åœ¨æœ€åˆè¿æ¥çš„æ—¶å€™ï¼Œè®¾å¤‡é€šè¿‡USBé…ç½®æè¿°ç¬¦å‘Šè¯‰ä¸»æœºçš„ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œå¯ä»¥å‚è€ƒä¸‹ã€‚å…·ä½“æ‰€æœ‰çš„æè¿°ç¬¦å»ºè®®å»USBçš„å®˜æ–¹æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ï¼š\nUSB HID USBæ”¯æŒå¾ˆå¤šç§è®¾å¤‡ç±»å‹ï¼Œæˆ‘ä»¬ä¸»è¦ä¼šç”¨åˆ°HIDï¼Œå³Human Interface Deviceã€‚\nUSBæŒ‚èµ·æ¨¡å¼ å½“USBä¸»æœºè¿ç»­3msæ²¡æœ‰æ£€æµ‹åˆ°USBè®¾å¤‡æœ‰ä¿¡å·ï¼Œå°±è‡ªåŠ¨è¿›å…¥USBæŒ‚èµ·æ¨¡å¼ã€‚å› æ­¤ï¼Œä¸ºäº†é¿å…è¿›å…¥æŒ‚èµ·æ¨¡å¼ï¼Œè®¾å¤‡éœ€è¦å‘¨æœŸæ€§åœ°å‘é€Keep Aliveæˆ–è€…SOFä¿¡å·ã€‚\nHIDé”®ç›˜çš„é”®å€¼ å¯¹äºUSB HIDè®¾å¤‡æ¥è¯´ï¼Œå…¶é”®ç›˜çš„æ•°æ®åŒ…åŒ…å«8ä¸ªå­—èŠ‚ã€‚åŸºæœ¬ä¸Šå¯ä»¥åˆ†ä¸º3éƒ¨åˆ†ï¼š\nByte0ï¼šåŠŸèƒ½é”®ï¼Œå¦‚L/R-Ctrlã€Shiftã€Altã€GUIç­‰ Byte1ï¼šä¿ç•™ Byte2-7ï¼šæ™®é€šæŒ‰é”® å¯¹äºæ™®é€šæŒ‰é”®æ¥è¯´ï¼ŒHIDè®¾å¤‡å·²ç»è§„å®šå¥½äº†å„ä¸ªæŒ‰é”®çš„é”®å€¼ï¼Œæ¯”å¦‚å³ç®­å¤´çš„é”®å€¼ä¸º79ï¼ˆåå…­è¿›åˆ¶0x4Fï¼‰ã€‚å¦‚æœè¦å‘ä¸»æœºå‘é€ä¸€ä¸ªå³ç®­å¤´æŒ‰é”®ï¼Œé‚£ä¹ˆåœ¨Byte2å†™ä¸ª0x4Få°±è¡Œäº†ã€‚\nSTM32çš„USBé…ç½® é»˜è®¤æƒ…å†µä¸‹ï¼ŒSTM32CubeMXç”Ÿæˆçš„USB HIDè®¾å¤‡æ˜¯é¼ æ ‡ï¼Œéœ€è¦ä¿®æ”¹é…ç½®æè¿°ç¬¦æ¥ä¿®æ”¹ä¸ºé”®ç›˜çš„é”®å€¼ã€‚é¦–å…ˆçœ‹ä¸€ä¸‹STM32CubeMXé…ç½®USBçš„ç•Œé¢ï¼š\nå·¦ä¸‹è§’å¯ä»¥çœ‹åˆ°F411æ˜¯USB_OTG_FSï¼Œæ„æ€æ˜¯å¸¦OTFçš„å…¨é€ŸUSBè®¾å¤‡ã€‚ä¸­é—´å¯ä»¥çœ‹åˆ°ç›¸å…³çš„é…ç½®é¡¹ï¼Œå¯¹äºé”®ç›˜è®¾å¤‡ä¸€èˆ¬é€‰Device Onlyå³å¯ã€‚ä¸‹é¢æ˜¯ä¼‘çœ å’Œä¾›ç”µçš„é€‰é¡¹ï¼Œé€‰ä¸é€‰éƒ½å¯ä»¥ã€‚\nç„¶åï¼Œåœ¨middlewareä¸‹é€‰æ‹©USB_DEVICEï¼Œå°±å¯ä»¥çœ‹åˆ°ä½œä¸ºUSBè®¾å¤‡çš„ç›¸å…³é…ç½®ï¼š\nä¸­é—´çš„Class For FS IPå°±é€‰æ‹©HIDè®¾å¤‡ï¼Œä¸‹é¢çš„Device Descriptorè®¾å¤‡æè¿°ç¬¦ï¼Œå°±å¯ä»¥é…ç½®è¿™ä¸ªUSBè®¾å¤‡è¿æ¥åˆ°ç”µè„‘ä¸Šä¹‹åçš„ä¸€äº›ä¿¡æ¯ï¼Œæ¯”å¦‚å‚å®¶ã€è®¾å¤‡åç­‰ç­‰ã€‚ç„¶åç”Ÿæˆä»£ç å³å¯ã€‚\né»˜è®¤æƒ…å†µä¸‹ï¼ŒCubeMXç”Ÿæˆçš„HIDè®¾å¤‡æ˜¯é¼ æ ‡ã€‚åœ¨ç”Ÿæˆçš„ä»£ç ä¸­ï¼Œæ‰¾åˆ°usbd_hid.cæ–‡ä»¶ï¼Œæ‰¾åˆ°è¿™æ®µä»£ç ï¼š\nå¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ªnInterfaceProtocolï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹å€¼ä¸º0x02ï¼Œå³mouseã€‚å¯¹äºé”®ç›˜æˆ‘ä»¬æŠŠå®ƒæ”¹æˆ0x01å³å¯ã€‚æ­¤å¤–ï¼Œåœ¨ä¸‹é¢è¿˜æœ‰ä¸€ä¸ªHID_MOUSE_REPORT_DESC_SIZEå¸¸é‡ï¼ŒæŒ‡çš„æ˜¯é¼ æ ‡çš„å›æŠ¥æè¿°ç¬¦çš„å¤§å°ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦æŠŠå®ƒæ”¹ä¸ºé”®ç›˜çš„å¤§å°ï¼š\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªDESC_SIZEæœ‰ä¸¤å¤„ï¼Œéƒ½éœ€è¦æ”¹ä¸ºé”®ç›˜ã€‚\næ”¹å®Œä¸Šé¢ä¸‰ä¸ªåœ°æ–¹ä¹‹åï¼Œæˆ‘ä»¬çš„ä»£ç å°±å¯ä»¥ä½œä¸ºé”®ç›˜çš„USBHIDè®¾å¤‡è¿æ¥åˆ°ç”µè„‘ä¸Šäº†ã€‚\næ•°æ®ä¼ è¾“ æœ€åçš„æœ€åï¼Œåœ¨ä»£ç ä¸­åªéœ€è¦è°ƒç”¨\n1 USBD_HID_SendReport(\u0026hUsbDeviceHS, data, data_length); å³å¯å‘USBä¸»æœºç«¯å‘é€æ•°æ®ã€‚å½“ç„¶ï¼Œdataå’Œdata_lengthéƒ½å¿…é¡»ç¬¦åˆUSBçš„æè¿°ä»¥åŠé…ç½®ã€‚å…·ä½“è¯·å‚è§USBçš„æ–‡æ¡£ï¼šhttps://www.usb.org\n","description":"","tags":["keyboard"],"title":"STM32 - 3","uri":"/posts/keyboard/stm32-3/"},{"categories":null,"content":"STM32 - 2 ä¹‹å‰æˆ‘ä»¬å·²ç»äº†è§£äº†ä¸€äº›STM32çš„åŸºç¡€çŸ¥è¯†ï¼Œä¸‹é¢å°±å¼€å§‹æ­£å¼çš„ç¼–ç¨‹äº†ã€‚æˆ‘ä»¬ä¸»è¦ä¼šä½¿ç”¨STM32çš„HALåº“ï¼Œè¿™äº›åº“å‡½æ•°å·²ç»åœ¨åˆ›å»ºå·¥ç¨‹çš„æ—¶å€™åˆå§‹åŒ–å¥½äº†ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œç›´æ¥ä½¿ç”¨å³å¯ã€‚\nGPIO ç‰‡ä¸Šå¤–è®¾çš„ä½¿èƒ½æ—¶é’Ÿ é¦–å…ˆäº†è§£ä¸€ä¸‹STM32çš„ç‰‡ä¸Šå¤–è®¾çš„ä½¿èƒ½æ—¶é’Ÿã€‚STM32å‡ ä¹æ‰€æœ‰çš„ç‰‡ä¸Šè®¾å¤‡éƒ½æœ‰ä½¿èƒ½æ—¶é’Ÿï¼ŒåŒ…æ‹¬è¾“å…¥è¾“å‡ºGPIOã€‚ä¸æŠŠä½¿èƒ½æ—¶é’Ÿæ‰“å¼€ï¼Œå¯¹åº”çš„å¤–è®¾å°±ä¸èƒ½ç”¨ã€‚STM32è¿™ä¹ˆè®¾è®¡æ˜¯ä¸ºäº†é™ä½åŠŸè€—ã€‚\né‚£æ€ä¹ˆæ ·å¯åŠ¨ä½¿èƒ½æ—¶é’Ÿå‘¢ï¼Ÿä»¥æœ€å°ç³»ç»Ÿæ¿ä¸Šé¢çš„PC13ä¸ºä¾‹ï¼Œè¿™ä¸ªIOå®é™…ä¸Šå°±æ˜¯GPIOCçš„13å·å¼•è„šï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åœ¨main.cé‡Œé¢ä½¿ç”¨å¦‚ä¸‹ä»£ç å°±å¯ä»¥å¼€å¯GPIOCçš„ä½¿èƒ½æ—¶é’Ÿï¼š\n1 __HAL_RCC_GPIOC_CLK_ENABLE(); åˆå§‹åŒ–GPIO åœ¨æ‰“å¼€GPIOçš„ä½¿èƒ½æ—¶é’Ÿä¹‹åï¼Œå°±è¦åˆå§‹åŒ–GPIOäº†ã€‚å¯ä»¥ä½¿ç”¨å¦‚ä¸‹APIåˆå§‹åŒ–GPIOï¼š\n1 void HAL_GPIO_Init(GPIOC, \u0026GPIO_InitStruct); å…¶ä¸­ï¼ŒGPIOCå°±æ˜¯GPIOçš„ç±»å‹ï¼Œè€Œåé¢çš„é‚£ä¸ªGPIO_InitStructåˆ™æ˜¯å„ç§åˆå§‹åŒ–å‚æ•°ï¼Œå¦‚è¾“å…¥è¾“å‡ºæ¨¡å¼ã€è¾“å…¥è¾“å‡ºå¼•è„šç­‰ã€‚ä¸‹é¢æ˜¯åˆå§‹åŒ–è®¾ç½®çš„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void MX_GPIO_Init(void) { // GPIOåˆå§‹åŒ–è®¾ç½® GPIO_InitTypeDef GPIO_InitStruct = {0}; // æ‰“å¼€GPIOCçš„ä½¿èƒ½æ—¶é’Ÿ __HAL_RCC_GPIOC_CLK_ENABLE(); // è®¾ç½®GPIOCçš„13å·å¼•è„šçš„è¾“å‡ºLevel HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); // ç„¶åé…ç½®å„ç§GPIOçš„è®¾ç½®ï¼Œå¦‚å¼•è„šä¸º13ï¼Œæ¨¡å¼ä¸ºPPï¼ˆæ¨æŒ½è¾“å‡ºï¼‰ï¼Œæ²¡æœ‰ä¸Šæ‹‰ç”µé˜»ï¼Œè¾“å‡ºé€Ÿç‡ç­‰ç­‰ã€‚ GPIO_InitStruct.Pin = GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; // å®ŒæˆGPIOçš„åˆå§‹åŒ– HAL_GPIO_Init(GPIOC, \u0026GPIO_InitStruct); } å‘GPIOå†™å…¥å€¼ï¼ˆè¾“å‡ºï¼‰ åœ¨åˆå§‹åŒ–å®Œæ¯•ä¹‹åï¼Œå°±å¯ä»¥ä½¿ç”¨HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);å‘å¯¹åº”çš„GPIOå†™å…¥å€¼äº†ã€‚å‚æ•°éƒ½å¾ˆå®¹æ˜“ç†è§£ï¼Œæœ€åä¸€ä¸ªå‚æ•°ï¼Œå¦‚æœæ˜¯SETï¼Œé‚£ä¹ˆå°±æ˜¯å†™1ï¼›å¦‚æœæ˜¯RESETï¼Œå°±æ˜¯å†™0ã€‚\nOKï¼Œåˆ°è¿™é‡Œï¼Œä¸€ä¸ªæœ€ç®€å•çš„äº®ç¯ç¨‹åºå°±å†™å®Œäº†ã€‚åé¢ï¼Œæˆ‘ä»¬å°±æ·±å…¥äº†è§£ä¸€ä¸‹GPIOçš„å„ç§è®¾ç½®å±æ€§ã€‚\nGPIOçš„è®¾ç½® GPIOçš„è®¾ç½®ä¸»è¦æ˜¯ä½¿ç”¨GPIO_InitTypeDefæ¥å£°æ˜ï¼šGPIO_InitTypeDef GPIO_InitStruct = {0};ã€‚GPIO_InitTypeDefä¸»è¦åŒ…å«4ä¸ªè®¾ç½®ï¼š\nModeï¼šIOå¼•è„šçš„æ¨¡å¼\næˆ‘ä»¬åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ç”¨åˆ°çš„ï¼Œå°±æ˜¯GPIO_MODE_OUTPUT_PPï¼Œå³è¾“å‡ºæ¨æŒ½æ¨¡å¼ï¼ˆOutput Push-Pull Modeï¼‰ã€‚æ¨æŒ½æ¨¡å¼å°±æ˜¯é«˜ä½ç”µå¹³å‡æœ‰é©±åŠ¨èƒ½åŠ›çš„è¾“å‡ºæ¨¡å¼ã€‚\næ­¤å¤–ï¼Œè¾“å‡ºæ¨¡å¼è¿˜æœ‰GPIO_MODE_OUTPUT_ODï¼Œå³è¾“å‡ºå¼€æ¼æ¨¡å¼ã€‚å¼€æ¼è¾“å‡ºé«˜ç”µå¹³ç›¸å½“äºé«˜é˜»æ€ï¼Œæ˜¯æ²¡æœ‰é©±åŠ¨èƒ½åŠ›çš„ã€‚\nå¦å¤–ï¼Œè¿˜å¯ä»¥é€‰æ‹©è¾“å…¥æ¨¡å¼ï¼Œå³GPIO_MODE_INPUTå’ŒGPIO_MODE_AF_INPUTã€‚å…·ä½“è¿™äº›æ¨¡å¼çš„åŒºåˆ«ï¼Œå¯ä»¥å‚è€ƒä¸‹ https://www.bilibili.com/video/BV1th411z7sn 15åˆ†é’Ÿå·¦å³çš„è®²è§£ï¼Œå¾ˆè¯¦ç»†\nPinï¼šå°±æ˜¯ç¬¬å‡ å·IOå¼•è„š\nå¦‚æœè¦è®¾ç½®ç¬¬13å·å¼•è„šï¼Œå°±å¯ä»¥ä½¿ç”¨ï¼šGPIO_InitStruct.Pin = GPIO_PIN_13;ï¼Œå¦‚æœè¦è®¾ç½®å¤šä¸ªå¼•è„šï¼Œå¯ä»¥ä½¿ç”¨|:\n1 2 // åŒæ—¶è®¾ç½®13å’Œ14å·å¼•è„š GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14; Pullï¼šç”¨åœ¨è¾“å…¥æ¨¡å¼é‡Œé¢ï¼Œå³ä¸Šæ‹‰/ä¸‹æ‹‰ç”µé˜»ï¼Œç”¨æ¥è®¾ç½®è¾“å…¥æ‚¬ç©ºçš„æ—¶å€™ï¼Œè¾“å…¥å£æ˜¯é«˜ç”µå¹³ï¼ˆä¸Šæ‹‰ç”µé˜»PULLUPï¼‰è¿˜æ˜¯ä½ç”µå¹³ï¼ˆä¸‹æ‹‰ç”µé˜»PULLDOWNï¼‰è¿˜æ˜¯å°±æŠŠå®ƒæ‚¬ç©ºï¼ˆNOPULLï¼‰ï¼Œè¯¦è§ https://www.bilibili.com/video/BV1th411z7sn 9åˆ†é’Ÿ30ç§’å·¦å³çš„è®²è§£\nSpeedï¼šè®¾ç½®IOå¼•è„šå…è®¸çš„æœ€å¤§é€Ÿåº¦\nçœ‹f411çš„æºä»£ç å¯ä»¥åˆ°è¿™é‡Œå¯ä»¥è®¾ç½®4ä¸ªçº§åˆ«çš„IOé€Ÿåº¦ï¼Œåˆ†åˆ«æ˜¯2Mã€12.5M~50Mã€25M~100Må’Œ50M~200Mã€‚é€Ÿåº¦è¶Šå¿«ï¼ŒIOçš„è¯»å–é¢‘ç‡å°±è¶Šé«˜ï¼Œä¹Ÿå°±è¶Šè€—ç”µã€‚\n1 2 3 4 #define GPIO_SPEED_FREQ_LOW 0x00000000U /*!\u003c IO works at 2 MHz, please refer to the product datasheet */ #define GPIO_SPEED_FREQ_MEDIUM 0x00000001U /*!\u003c range 12,5 MHz to 50 MHz, please refer to the product datasheet */ #define GPIO_SPEED_FREQ_HIGH 0x00000002U /*!\u003c range 25 MHz to 100 MHz, please refer to the product datasheet */ #define GPIO_SPEED_FREQ_VERY_HIGH 0x00000003U /*!\u003c range 50 MHz to 200 MHz, please refer to the product datasheet */ æœ€åï¼Œéœ€è¦æ³¨æ„ä¼ è¿›å»çš„GPIO_InitTypeDefæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨\u0026GPIO_InitStruct ä¼ åœ°å€è¿›å»ã€‚\nGPIOè¾“å…¥ æˆ‘ä»¬å°±ç”¨æœ€ç®€å•çš„å¼€å…³æ¥å­¦ä¹ GPIOå£çš„è¾“å…¥ã€‚\né¦–å…ˆå¤ä¹ ä¸€ä¸‹åœ¨é…ç½®è¾“å…¥æ¨¡å¼çš„æ—¶å€™ï¼Œæœ‰ä¸€ä¸ªPullå­—æ®µã€‚è¿™ä¸ªå­—æ®µä»£è¡¨ç€åœ¨è¾“å…¥æ‚¬ç©ºçš„æ—¶å€™ï¼Œé»˜è®¤æ˜¯ä¸Šæ‹‰ç”µé˜»è¿˜æ˜¯ä¸‹æ‹‰ç”µé˜»æˆ–è€…æ˜¯æ‚¬ç©ºã€‚è¿™ç©æ„æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸‹é¢çš„å¼€å…³ç”µè·¯ï¼š\nå¾ˆå¥½ç†è§£ï¼Œå¼€å…³æŒ‰ä¸‹çš„æ—¶å€™ï¼ŒGPIOè¾“å…¥å°±æ¥åœ°ï¼Œå³ä½ç”µå¹³0ã€‚é‚£è¿™ä¸ªä¸Šä¸‹æ‹‰ç”µé˜»æœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ\nçœ‹ä¸‹å·¦è¾¹çš„å›¾ï¼Œå¦‚æœå¼€å…³æ–­å¼€ï¼Œè¿™ä¸ªæ—¶å€™PA0è¾“å…¥å°±æ‚¬ç©ºäº†ã€‚å¦‚æœè¿™ä¸ªæ—¶å€™GPIOå£çš„é…ç½®ä¸ºæ‚¬ç©ºï¼Œé‚£è¿™ä¸ªå¼•è„šå°±çœŸçš„æ‚¬ç©ºäº†ï¼Œå…¶è¾“å…¥å°±ä¸ç¡®å®šã€‚è€Œå¦‚æœè¿™ä¸ªæ—¶å€™ï¼ŒGPIOå£çš„è¾“å…¥é…ç½®ä¸ºä¸‹æ‹‰ç”µé˜»ï¼Œæ­¤æ—¶PA0æ‚¬ç©ºï¼Œè¾“å…¥å°±è¢«ä¸‹æ‹‰ç”µé˜»æ‹‰åˆ°äº†ä½ç”µå¹³ï¼Œé‚£è¿™ä¸ªæŒ‰é”®å®é™…ä¸Šå°±æ²¡ç”¨äº†ã€‚å› æ­¤ï¼Œåœ¨æŒ‰é”®ä¸€è¾¹æ¥åœ°çš„æ—¶å€™ï¼Œå¦‚æœæ²¡æœ‰æ‰‹åŠ¨é…ç½®ä¸Šæ‹‰ç”µé˜»ï¼ˆå³è¾¹çš„å›¾ï¼‰ï¼Œé‚£å°±å¿…é¡»æŠŠGPIOçš„è¾“å…¥è®¾ç½®ä¸ºä¸Šæ‹‰ç”µé˜»æ¨¡å¼ï¼ˆPULLUPï¼‰ï¼Œæ¥ä¿è¯å¼€å…³æ–­å¼€æ—¶è¾“å…¥ä¸ºé«˜ç”µå¹³ã€‚\nå½“ç„¶ï¼Œå¦‚æœåƒå³è¾¹ä¸€æ ·ï¼Œå¤–é¢å•ç‹¬é…ç½®äº†ä¸Šæ‹‰ç”µé˜»ï¼Œé‚£ä¹ˆPA0çš„è¾“å…¥æ¨¡å¼é…ç½®ä¸ºä¸Šæ‹‰ç”µé˜»æ¨¡å¼æˆ–è€…æ‚¬ç©ºæ—¶éƒ½å¯ä»¥çš„ã€‚\nâ— æ³¨æ„ï¼šç”±äºSTM32ç³»åˆ—å¹¶ä¸æ˜¯æ‰€æœ‰çš„å¼€å…³éƒ½æœ‰ä¸‹æ‹‰ç”µé˜»æ¨¡å¼ï¼Œå› æ­¤ï¼Œåœ¨ä¹ æƒ¯ä¸Šï¼Œåªè¦æ˜¯å¼€å…³éƒ½é‡‡ç”¨ä½ç”µå¹³è§¦å‘çš„æ–¹å¼ï¼Œå³ä¸€è¾¹æ¥åœ°ä¸€è¾¹æ¥GPIOã€‚\nè¾“å…¥æ¨¡å¼ æŒ‰é”®æ¶ˆæŠ– ä¸€èˆ¬æ¥è¯´ï¼ŒæŒ‰ä¸‹æŒ‰é”®ä¹‹åï¼ŒæŒ‰é”®ä¼šæœ‰ä¸€ä¸ª5-10msçš„æŠ–åŠ¨ï¼Œç„¶åæ‰ä¼šç¨³å®šåœ¨é«˜ç”µå¹³ã€‚æ¶ˆé™¤æŠ–åŠ¨çš„ç­–ç•¥å¾ˆç®€å•ï¼Œåœ¨æ£€æµ‹åˆ°æŒ‰é”®ä¹‹åï¼Œå»¶è¿Ÿ20mså†è¿›å…¥å®Œå…¨æŒ‰ä¸‹æ—¶çš„é‚£ä¸ªwhileå¾ªç¯ã€‚ç„¶åå°±åªè¦æŒ‰ä¸‹å°±ä¸€ç›´åœ¨è¿™ä¸ªwhileå¾ªç¯é‡Œï¼Œç›´åˆ°æ¾å¼€æŒ‰é”®ï¼Œè·³å‡ºwhileå¾ªç¯ï¼Œç„¶åå†delay20msã€‚å¯¹äºæŒ‰é”®çš„è¦æ±‚æ¯”è¾ƒé«˜çš„åœºåˆï¼Œå¯èƒ½è¿˜éœ€è¦åç»­çš„æ»¤æ³¢ã€‚\nGPIOè¾“å‡º ä¸Šé¢æˆ‘ä»¬å·²ç»äº†è§£äº†GPIOè¾“å‡ºæ¨¡å¼çš„æ¨æŒ½æ¨¡å¼ï¼ˆPPï¼‰ï¼Œå³è¾“å‡ºçš„æ—¶å€™ï¼Œä¸Šä¸‹ä¸¤ä¸ªMOSç®¡å‡å¯ä»¥å¯¼é€šï¼ˆåŒæ—¶åªæœ‰ä¸€ä¸ªèƒ½é€šï¼‰ï¼Œç„¶åè¾“å‡ºå°±èƒ½å¤Ÿè¢«ä¸‹æ¨åˆ°0Væˆ–ä¸Šæ‹‰åˆ°3.3Vï¼Œè¿™æ ·é«˜ä½ç”µå¹³éƒ½æœ‰å¼ºé©±åŠ¨èƒ½åŠ›ã€‚\né™¤äº†æ¨æŒ½æ¨¡å¼ä¹‹å¤–ï¼Œè¾“å‡ºè¿˜æœ‰å¼€æ¼æ¨¡å¼ï¼ˆODï¼‰ã€‚å…¶å®å¼€æ¼æ¨¡å¼å’Œæ¨æŒ½æ¨¡å¼çš„åŒºåˆ«å°±åœ¨äºï¼Œå¼€æ¼æ¨¡å¼çš„ä¸Šé¢æ¥é«˜ç”µå¹³çš„MOSç®¡ä¸€ç›´æ˜¯æ–­å¼€çš„ã€‚è¿™æ ·çš„è¯ï¼Œåªæœ‰ä¸‹é¢çš„MOSå¯ä»¥å¯¼é€šï¼Œé‚£å°±ä½ç”µå¹³æœ‰å¼ºé©±åŠ¨èƒ½åŠ›ã€‚è€Œåœ¨è¾“å‡º1çš„æ—¶å€™ï¼Œä¸Šä¸‹MOSå‡æ–­å¼€ï¼Œè¾“å‡ºå°±æ˜¯ä¸€ä¸ªé«˜é˜»æŠ—çŠ¶æ€ï¼Œå°±ç›¸å½“äºè¿™ä¸ªè¾“å‡ºç›´æ¥æ–­å¼€äº†ï¼ˆä¸æ˜¯è¾“å‡ºé«˜ç”µå¹³ï¼‰ã€‚\nä¸¤ä¸ªè¾“å‡ºæ¨¡å¼çš„åŒºåˆ«ï¼š\nå¼€æ¼æ¨¡å¼çš„åº”ç”¨åœºæ™¯ é©±åŠ¨IED PPå’ŒODæ¨¡å¼éƒ½èƒ½é©±åŠ¨LEDï¼Œé©±åŠ¨ç”µè·¯ç•¥æœ‰ä¸åŒï¼š\nåŒºåˆ«æ˜¯é™¤äº†ç”µè·¯ä¸åŒä¹‹å¤–ï¼Œä¸¤ä¸ªæ¨¡å¼é©±åŠ¨LEDè¿˜æœ‰å¦‚ä¸‹åŒºåˆ«ï¼š\nPPæ¨¡å¼æ˜¯è¾“å‡º1ç¯äº®ï¼Œè€ŒODæ˜¯è¾“å‡º0ç¯äº® PPæ¨¡å¼æ˜¯èŠ¯ç‰‡å‘å¤–ä¾›ç”µï¼Œè€ŒODæ˜¯å¤–é¢çš„ç”µæºä¾›ç”µï¼ŒèŠ¯ç‰‡å¸ç”µ ODæ¨¡å¼ç›¸å¯¹äºPPæ¨¡å¼ï¼Œç†è®ºä¸Šèƒ½å¤Ÿæ‰¿è½½çš„æœ€å¤§ç”µæµå¤šä¸€äº› ODæ¨¡å¼èƒ½å¤Ÿé™ä½èŠ¯ç‰‡åŠŸè€— é€»è¾‘çº¿ä¸ é€»è¾‘çº¿ä¸æœ€å¤šæ˜¯ç”¨åœ¨I2Cé€šä¿¡æ€»çº¿ä¸Šã€‚\nI2Cæ˜¯ä¸€ç§é€šä¿¡æ€»çº¿ï¼Œå®ƒæœ‰ä¸¤ä¸ªçº¿ï¼šä¸€ä¸ªæ˜¯SDAç”¨äºä¼ æ•°æ®ï¼Œä¸€ä¸ªæ˜¯SCLç”¨äºä¼ æ—¶é’Ÿã€‚å…¶æ¥çº¿å¦‚å›¾ï¼š\nI2Cçš„æ‰€æœ‰SDAå’ŒSCLçš„IOéƒ½æ˜¯ODæ¨¡å¼ï¼Œè¿™æ ·çš„è¯ï¼Œåªè¦æœ‰ä¸€ä¸ªè¾“å‡ºæ˜¯0ï¼Œé‚£ä¹ˆå¯¹åº”çš„SDAå°±ä¼šè¢«æ‹‰åˆ°0Vè¾“å‡ºä½ç”µå¹³ã€‚è€Œåªæœ‰æ‰€æœ‰çš„SDAæˆ–è€…SCLå…¨æ˜¯1ï¼Œç”±äºæ˜¯é«˜é˜»æ€ï¼Œå¯¹åº”è¾“å‡ºçš„SDAæˆ–SCLå°±ä¼šè¢«ä¸Šæ‹‰ç”µé˜»æ‹‰åˆ°VDDï¼Œè¾“å‡ºé«˜ç”µå¹³ã€‚è¿™å°±æ˜¯é€»è¾‘çº¿ä¸ã€‚\nåŒ¹é…ä¸åŒç”µå‹ç­‰çº§ STM32è¾“å‡ºçš„é«˜ç”µå¹³ä¸€èˆ¬æ˜¯3.3Vï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³è¦å»é©±åŠ¨éœ€è¦5Vè¾“å…¥çš„èŠ¯ç‰‡åº”è¯¥å¦‚ä½•åšå‘¢ï¼Ÿä¸‹é¢å°±æ˜¯ä½¿ç”¨å¼€æ¼æ¨¡å¼é©±åŠ¨5Vè¾“å…¥çš„åŸç†å›¾ï¼š\nå¯ä»¥çœ‹åˆ°ï¼Œåœ¨STM32è¾“å‡º0çš„æ—¶å€™ï¼Œé‚£å³è¾¹èŠ¯ç‰‡çš„DINè¾“å…¥å°±æ˜¯0Vä½ç”µå¹³ã€‚å¦‚æœSTM32è¾“å‡º1çš„æ—¶å€™ï¼Œç”±äºè¾“å‡ºå£ä¸ºé«˜é˜»æ€ï¼Œé‚£ä¹ˆDINå°±ä¼šè¢«å¤–æ¥ç”µæºæ‹‰åˆ°5Vï¼Œä¹Ÿå°±æ˜¯å³è¾¹èŠ¯ç‰‡éœ€è¦çš„é«˜ç”µå¹³ã€‚è¿™å°±å®ç°äº†ä¸åŒç”µå‹æ°´å¹³çš„åŒ¹é…ã€‚\n","description":"","tags":["keyboard"],"title":"STM32 - 2","uri":"/posts/keyboard/stm32-2/"},{"categories":null,"content":"STM32 å­¦ä¹ STM32çš„ç¬”è®°ï¼Œè§†é¢‘æ•™ç¨‹ï¼šhttps://www.bilibili.com/video/BV1th411z7sn?p=2\u0026spm_id_from=pageDriver\u0026vd_source=58fb33df0449f8258f0e273447aab712\nç‰‡ä¸Šèµ„æº é¦–å…ˆï¼Œéœ€è¦äº†è§£ä¸€ä¸‹STM32èŠ¯ç‰‡ä¸Šé¢éƒ½æœ‰å“ªäº›å¯ä»¥ä½¿ç”¨çš„èµ„æºï¼Œå¦‚ä¸‹å›¾ï¼š\nç®€å•è®°å¿†ä¸€ä¸‹å„ç§èµ„æº/å¤–è®¾çš„ç¼©å†™å³å¯ï¼Œåé¢ä¼šè¯¦ç»†ç”¨åˆ°\nå¼•è„šå®šä¹‰ å¼•è„šå®šä¹‰æ˜¯å­¦ä¹ ä¸€ä¸ªå•ç‰‡æœºçš„æ ¸å¿ƒï¼Œä¸€èˆ¬æ¥è¯´å¦‚æœäº†è§£äº†å¼•è„šå®šä¹‰ï¼Œè¿™ä¸ªå•ç‰‡æœºæ€ä¹ˆç”¨çš„åŸºæœ¬å°±çŸ¥é“ä¸ªå…«ä¹ä¸ç¦»åäº†ã€‚ä¾‹å­é‡Œé¢æ˜¯STM32F103C8T6ï¼Œ è¯¦ç»†å®šä¹‰å¯ä»¥è§ä¸‹é¢çš„è¡¨ã€‚è¿™é‡Œé¦–å…ˆè®²ä¸€ä¸‹æ¯ä¸ªå¼•è„šçš„å«ä¹‰ï¼š\nVBATï¼š å¤‡ç”¨ç”µæº\nPC13-TAMPER-RTCï¼šè¿™ä¸ªå¼•è„šæœ‰å¤šé‡åŠŸèƒ½ï¼Œåˆ†åˆ«æ˜¯PC13ï¼ˆIOå£ï¼‰ã€TAMPERï¼ˆä¾µå…¥æ£€æµ‹ï¼‰ã€RTCï¼ˆè¾“å‡ºRTCæ ¡å‡†æ—¶é’Ÿã€ç§’è„‰å†²ç­‰ï¼‰\nPC14-OSC32_INï¼šIOæˆ–æ¥32KHZçš„RTCæ™¶æŒ¯çš„IN\nPC15-OSC32_OUTï¼šåŒä¸Šï¼Œåªä¸è¿‡è¿™ä¸ªå¼•è„šæ˜¯RTCæ™¶æŒ¯çš„OUT\nOSC_INå’ŒOSC_OUTï¼šç³»ç»Ÿä¸»æ™¶æŒ¯ï¼Œä¸€èˆ¬æ˜¯8MHZï¼ˆèŠ¯ç‰‡é‡Œé¢ä¼šå¯¹è¿™ä¸ªé¢‘ç‡è¿›è¡Œå€é¢‘ï¼Œæ¯”å¦‚ç”Ÿæˆ72MHZçš„é¢‘ç‡ä½œä¸ºèŠ¯ç‰‡çš„ä¸»æ—¶é’Ÿï¼‰\nNRSTï¼šç³»ç»Ÿå¤ä½ï¼ŒNä»£è¡¨æ˜¯ä½ç”µå¹³å¤ä½\nVSSAå’ŒVDDAï¼šèŠ¯ç‰‡å†…æ¨¡æ‹Ÿéƒ¨åˆ†çš„ç”µæºï¼ŒVSSæ˜¯è´Ÿæï¼ˆæ¥GNDï¼‰ï¼ŒVDDæ­£æï¼ˆæ¥3.3Vï¼‰\nPAxã€PBxå’ŒPCxï¼šéƒ½æ˜¯IOï¼Œå…¶ä¸­æœ‰ä¸€äº›ç‰¹æ®Šçš„æˆ–è€…æœ‰å…¶ä»–åŠŸèƒ½çš„ï¼Œä¸‹é¢ä¼šè¯¦ç»†è®²ã€‚æ³¨æ„åœ¨è¡¨é‡Œé¢æ²¡æœ‰åŠ ç²—çš„IOï¼Œéƒ½æ˜¯ä¸æ¨èä½œä¸ºIOä½¿ç”¨çš„ï¼ˆå› ä¸ºè¿™äº›IOæœ‰å…¶ä»–åŠŸèƒ½ï¼Œé™¤éIOå®åœ¨æ˜¯ä¸å¤Ÿäº†ï¼Œå¦åˆ™è¿˜æ˜¯ç”¨é‚£äº›åŠ ç²—çš„IOï¼‰\nPA0-WKUPæ„å‘³ç€PA0é™¤äº†æ˜¯IOä¹‹å¤–ï¼Œè¿˜æœ‰wakeupçš„åŠŸèƒ½\nPB2ï¼šçœ‹ä¸»åŠŸèƒ½æ ï¼Œè¿™ä¸ªå¼•è„šé™¤äº†IOä¹‹å¤–è¿˜æœ‰BOOTçš„åŠŸèƒ½ï¼Œå³å¯ä»¥ç”¨æ¥é…ç½®å¯åŠ¨æ¨¡å¼\nPA13/14/15ã€PB3/4ï¼šè¿˜å¯ä»¥ä½œä¸ºè°ƒè¯•ç«¯å£ã€‚å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ç§è°ƒè¯•æ¨¡å¼ï¼šJTAGå’ŒSWD\nSWDè°ƒè¯•éœ€è¦ä¸¤æ ¹çº¿ï¼šSWDIOå’ŒSWCLK\nJTAGåˆ™éœ€è¦5æ ¹çº¿ï¼šJTMSã€JTCKã€JTDIã€JTDOã€NJTRST\nSTLINKä½¿ç”¨çš„SWDï¼Œå› æ­¤åªéœ€è¦ä¸¤æ ¹çº¿ã€‚ä¸è¿‡è¿™5ä¸ªIOï¼Œé»˜è®¤éƒ½ä¸ä¼šè¢«ç”¨æ¥åšæ™®é€šIOã€‚å¦‚æœä½ æ˜¯ç”¨SWDï¼Œä¸”æƒ³ä½¿ç”¨å‰©ä¸‹çš„ä¸‰ä¸ªIOï¼Œé‚£ä¹ˆéœ€è¦åœ¨ç¨‹åºé‡Œé¢é…ç½®ã€‚\nVSS_xå’ŒVDD_xï¼šç³»ç»Ÿçš„ä¸»ç”µæºï¼ŒåŒæ ·ï¼ŒVSSè´Ÿæï¼ŒVDDæ­£æã€‚ç”±äºSTM32æ˜¯åˆ†åŒºä¾›ç”µï¼Œå› æ­¤å¯ä»¥æœ‰å¤šä¸ªç”µæºï¼Œè¿™äº›ç”µæºæ­£æ/è´Ÿæå¯ä»¥çŸ­æ¥åœ¨ä¸€èµ·ï¼Œç„¶åä¸€èµ·ä¾›ç”µ\nBOOT0ï¼šå’ŒPB2/BOOT1ä¸€æ ·ï¼Œä¹Ÿæ˜¯ç”¨æ¥åšå¯åŠ¨é…ç½®\nå¯åŠ¨é…ç½® çœ‹å®Œå¼•è„šå›¾ï¼Œå¤§æ¦‚æœ‰ä¸ªå°è±¡å³å¯ã€‚ä¸‹é¢çœ‹ä¸€ä¸‹å¯åŠ¨é…ç½®ã€‚è¿˜è®°å¾—ä¹‹å‰è¡¨é‡Œçš„ä¸¤ä¸ªBOOTå—ï¼ŸBOOT0å’ŒPB2/BOOT1ã€‚è¿™ä¸¤ä¸ªå¼•è„šå¯ä»¥ç”¨æ¥è®¾ç½®æ¨¡å¼ï¼š\nå¼•è„šä¸º0å°±æ˜¯æ¥åœ°GNDçš„æ„æ€ï¼Œ1æ˜¯é«˜ç”µå¹³ã€‚é»˜è®¤éƒ½æ˜¯ä½¿ç”¨flashä½œä¸ºå¯åŠ¨åŒºåŸŸã€‚å¦å¤–ï¼Œä¸‹é¢é‚£å¥è¯çš„æ„æ€å°±æ˜¯ï¼ŒBOOT0å’ŒBOOT1åªåœ¨åˆšå¼€å§‹ä¸Šç”µä¹‹åçš„ä¸€ç¬é—´ï¼ˆç¬¬å››ä¸ªä¸Šå‡æ²¿ï¼‰æœ‰ç”¨ï¼Œåé¢å°±éšä¾¿äº†ã€‚\næœ€å°ç³»ç»Ÿç”µè·¯ æœ€å°ç³»ç»Ÿç”µè·¯å°±æ˜¯èƒ½è®©èŠ¯ç‰‡è·‘èµ·æ¥çš„æœ€å°ç”µè·¯ã€‚ä¸‹é¢å°±çœ‹ä¸€ä¸‹F103çš„æœ€å°ç”µè·¯ï¼š\nä¾›ç”µ é¦–å…ˆçœ‹ä¾›ç”µçš„éƒ¨åˆ†ã€‚å¯ä»¥çœ‹åˆ°ï¼Œæ‰€æœ‰çš„VDDéƒ½æ¥äº†3.3Vï¼Œç„¶åVSSéƒ½æ¥äº†GNDã€‚åœ¨æ‰€æœ‰çš„3.3Vå’ŒGNDä¹‹é—´éƒ½æœ‰ä¸€ä¸ªç”µå®¹ï¼Œä¿—ç§°æ»¤æ³¢ç”µå®¹ã€‚æ»¤æ³¢ç”µå®¹ä¸»è¦æ˜¯ä¿æŒä¾›ç”µç”µå‹çš„ç¨³å®šï¼Œä¸€èˆ¬ä¾›ç”µæœ€å¥½éƒ½æ¥ä¸€ä¸ªæ¯”è¾ƒå¥½ã€‚\nå¦å¤–ï¼ŒVBATæ˜¯å¤‡ç”¨çš„ç”µæºï¼Œå¦‚æœéœ€è¦ç”¨åˆ°å°±æ¥ï¼Œä¸ç”¨åˆ°å°±æ¥3.3Væˆ–è€…æ‚¬ç©ºã€‚å¦‚æœç”¨åˆ°VBATï¼Œé‚£å°±æ¥ä¸€ä¸ª3Vçš„çº½æ‰£ç”µæ± å³å¯ï¼Œç”µæ± æ­£æVBATï¼Œè´Ÿææ¥åœ°ã€‚\nå¯ä»¥çœ‹åˆ°ï¼Œæ•´ä¸ªä¾›ç”µè¿˜æ˜¯å¾ˆç®€å•çš„ã€‚ä½†æ˜¯ç”±äºä¾›ç”µå£æ¯”è¾ƒå¤šï¼Œæ‰€ä»¥èµ°çº¿å¯èƒ½æœ‰äº›éº»çƒ¦ã€‚\næ™¶æŒ¯ STM32çš„ä¸»æ™¶æŒ¯ä¸€èˆ¬éƒ½æ˜¯8MHZã€‚æ™¶æŒ¯å°±è¿æ¥èŠ¯ç‰‡ä¸Šçš„OSC_INå’ŒOSC_OUTï¼š\nè¿™ä¸¤ä¸ªç”µå®¹æ˜¯å¯éœ‡ç”µå®¹ï¼Œå¦ä¸€ç«¯æ¥åœ°å³å¯ã€‚\nå¤ä½ç”µè·¯ å¤ä½ç”µè·¯çš„åŸç†ç¨å¾®éº»çƒ¦ç‚¹ã€‚åœ¨ä¸Šç”µçš„ä¸€ç¬é—´ï¼Œç”µå®¹æ˜¯ç›¸å½“äºçŸ­è·¯çš„ï¼Œå› æ­¤å°±äº§ç”Ÿäº†ä¸€ç¬é—´çš„ä½ç”µå¹³ã€‚èŠ¯ç‰‡æ˜¯ä½ç”µå¹³å¤ä½ï¼Œæ‰€ä»¥å¯ä»¥ç†è§£ä¸ºå¼€æœºçš„ä¸€ç¬é—´å¤ä½ã€‚ä¹‹åï¼Œç”µå®¹å……ç”µæ–­å¼€ï¼Œåœ¨K1å¼€å…³æ–­å¼€çš„æƒ…å†µä¸‹ï¼ŒNRSTå°±å’Œ3.3Vç›¸è¿ï¼Œä¸€ç›´æ˜¯é«˜ç”µå¹³ä¸å¤ä½ã€‚æŒ‰ä¸‹å¤ä½å¼€å…³ï¼ŒNRSTæ¥åœ°ï¼Œå°±å®Œæˆäº†æ‰‹åŠ¨å¤ä½ã€‚\nå¯åŠ¨é…ç½®ç”µè·¯ å°±æ˜¯ä¸Šé¢é€‰çš„BOOT0/1é€‰æ‹©å¯åŠ¨é…ç½®çš„ç”µè·¯ã€‚åœ¨æˆ‘ä»¬çš„411æ¿å­ä¸Šï¼Œæ˜¯è¿™æ ·çš„ï¼š\nå¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªæ‹¨ç å¼€å…³ï¼Œé»˜è®¤æƒ…å†µä¸‹å¼€å…³å¤„åœ¨123çš„ä½ç½®ï¼Œè€Œ456è¿™ä¸€ä¾§ä¸ºONï¼Œå³é»˜è®¤æƒ…å†µä¸‹ä¸‰ä¸ªä½ç½®éƒ½æ²¡æœ‰æ¥é€šã€‚ä»å›¾ä¸Šå¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœå·¦å³æ²¡æœ‰æ¥é€šï¼Œåˆ™ä¸‰ä¸ªä½ç½®éƒ½æ–­å¼€ã€‚å³BOOT0=0ï¼Œè€ŒPB2/BOOT1æ‚¬ç©ºã€‚\nå¦‚æœæƒ³æŠŠBOOT1è®¾ç½®ä¸º1ï¼Œåˆ™éœ€è¦åŒæ—¶æŠŠ1-6å’Œ2-5è¿æ¥èµ·æ¥ï¼Œå³ä¸Šé¢ä¸¤ä¸ªå¼€å…³æ‹¨å‘ONã€‚æŠŠBOOT0ç½®1åˆ™åªéœ€è¦æ‹¨åŠ¨3-4å¼€å…³åˆ°ONå³å¯ã€‚\nHello Worldå·¥ç¨‹ ä¸‹é¢æˆ‘ä»¬å°±æ¥å†™ä¸€ä¸ªæœ€ç®€å•çš„å·¥ç¨‹æ¥æµ‹è¯•ã€‚é¦–å…ˆæˆ‘ä»¬çš„æ¿å­ä¸Šï¼Œæœ‰ä¸€ä¸ªPC13è¿æ¥çš„LEDï¼Œè¿™ä¸ªå°±æ˜¯æˆ‘ä»¬ç”¨æ¥æµ‹è¯•æ¿å­çš„ç¯ï¼Œç”µè·¯å›¾åœ¨è¿™é‡Œï¼š\nå¯ä»¥çœ‹åˆ°å…¶ä¸­ä¸€ä¸ªæ˜¯å¸¸äº®çš„pwræŒ‡ç¤ºç¯ï¼Œå¦å¤–ä¸€ä¸ªæ˜¯è¿æ¥PC13ç«¯å£çš„æµ‹è¯•ç¯ã€‚\nç„¶åå°±æ˜¯åˆ›å»ºå·¥ç¨‹çš„æ­¥éª¤äº†ï¼Œæˆ‘ä»¬ä½¿ç”¨VSCode + PlatformIO + CubeMXåˆ›å»ºæˆ‘ä»¬çš„å·¥ç¨‹ï¼Œå…·ä½“å¯ä»¥å‚è€ƒè¿™é‡Œï¼šhttps://haobogu.github.io/posts/develop-stm32-using-vscode/ã€‚\nOKï¼Œåˆ›å»ºå®Œå·¥ç¨‹ä¹‹åï¼Œå°±å¯ä»¥å¼€å§‹å†™ä»£ç äº†ã€‚æ‰“å¼€main.cæ–‡ä»¶ï¼Œæ‰¾åˆ°ä¸»å‡½æ•°é‡Œé¢çš„while(1)å¾ªç¯ï¼Œå‘ç°é‡Œé¢ä»€ä¹ˆéƒ½æ²¡æœ‰ã€‚å› ä¸ºé»˜è®¤ç”Ÿæˆçš„æ˜¯ç©ºå·¥ç¨‹ã€‚è¿™ä¸ªæ—¶å€™å¦‚æœç¼–è¯‘ä¸‹è½½ä¹‹åï¼Œä¸»æ¿ä¸Šçš„ç»¿ç¯å°±ç›´æ¥ç­äº†ï¼Œå› ä¸ºæˆ‘ä»¬å•¥éƒ½æ²¡å†™ã€‚é‚£ä¹ˆæˆ‘ä»¬ç¬¬ä¸€ä¸ªç¨‹åºå°±ä»è¿™é‡Œå¼€å§‹ã€‚\nä½¿ç”¨å¯„å­˜å™¨çš„æ–¹å¼ç‚¹äº®LED STM32çš„ç¼–ç¨‹ä¸€èˆ¬æœ‰3ç§æ–¹å¼ï¼š\nå¯„å­˜å™¨ç¼–ç¨‹ï¼šç›´æ¥æ§åˆ¶èŠ¯ç‰‡ä¸­çš„å¯„å­˜å™¨ï¼Œæ¯”è¾ƒåŸºç¡€ï¼Œé€Ÿåº¦å¿«ã€‚ä½†æ˜¯ç”±äºSTM32ç³»åˆ—å¾ˆå¤æ‚ï¼Œå¯„å­˜å™¨éå¸¸å¤šï¼Œå› æ­¤è¿™ç§æ–¹æ³•åæœŸæ¯”è¾ƒéº»çƒ¦ åº“å‡½æ•°ç¼–ç¨‹ï¼šSTå…¬å¸æä¾›äº†å¯ä»¥ç›´æ¥å¯¹èŠ¯ç‰‡åšå„ç§æ“ä½œçš„åº“å‡½æ•°ï¼Œå¯ä»¥ç†è§£ä¸ºå¯„å­˜å™¨æ“ä½œçš„å°è£…ï¼Œååˆ†æ–¹ä¾¿ï¼Œå¯ä»¥ä½œä¸ºä¸»è¦çš„ç¼–ç¨‹æ–¹å¼ HALç¼–ç¨‹ï¼šå¯ä»¥ç†è§£ä¸ºä½ä»£ç ç¼–ç¨‹ï¼Œé€šè¿‡STå…¬å¸çš„å¯¹åº”è½¯ä»¶é‡Œé¢çš„å›¾å½¢åŒ–ç•Œé¢å®Œæˆç¼–ç¨‹ã€‚ä½†æ˜¯è¿™ç§æ–¹å¼ä¸åˆ©äºå¯¹èŠ¯ç‰‡åº•å±‚çš„ç†è§£ï¼Œä¸å¥½å¼€å‘è¿›é˜¶åŠŸèƒ½ ç»¼ä¸Šï¼Œæˆ‘ä»¬ä¸»è¦ä¼šé€‰æ‹©åº“å‡½æ•°ç¼–ç¨‹çš„æ–¹å¼ã€‚å½“ç„¶å¯„å­˜å™¨ç¼–ç¨‹ä¹Ÿè¦äº†è§£ã€‚å› æ­¤æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªç¨‹åºå°±ä»å¯„å­˜å™¨ç¼–ç¨‹å¼€å§‹ï¼ˆè¿™ä¸ªç« èŠ‚å¦‚æœçœ‹ä¸æ‡‚ï¼Œæ— æ‰€è°“ï¼Œå°±äº†è§£ä¸‹ï¼‰ã€‚\nå¯„å­˜å™¨é…ç½® é¦–å…ˆæ˜¯RCCå¯„å­˜å™¨çš„æ—¶é’Ÿï¼Œè¿™ä¸ªå¯ä»¥ç†è§£ä¸ºæ˜¯GPIOçš„ä½¿èƒ½æ—¶é’Ÿã€‚è¿™é‡Œï¼Œå‡ºç°äº†STM32F4å’ŒF1çš„ä¸åŒï¼šåœ¨F1ä¸­GPIOéƒ½æ˜¯APB2çš„å¤–è®¾ï¼Œè€Œåœ¨F4ä¸­ï¼ŒGPIOæ˜¯AHB1çš„å¤–è®¾ã€‚å…·ä½“å¯ä»¥çœ‹ä¸‹F411çš„æ‰‹å†Œï¼š\nå¯ä»¥çœ‹åˆ°åœ¨F411ä¸­ï¼Œè¿™äº›GPIOéƒ½æ˜¯å’ŒAHB1ç›¸è¿çš„ã€‚è¿™ä¹Ÿæ˜¯å’Œè§†é¢‘ä¸­çš„ä¸ä¸€æ ·çš„åœ°æ–¹ã€‚ä¸è¿‡åŸç†éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰¾åˆ°å¯¹åº”çš„ä½¿èƒ½æ—¶é’Ÿçš„RCCå¯„å­˜å™¨ï¼š\nå¯ä»¥çœ‹åˆ°å’Œè§†é¢‘ä¸­ç±»ä¼¼ï¼Œæœ‰ä¸€å †GPIOxENï¼š\næˆ‘ä»¬è¦æ“ä½œPC13ä¸Šé¢çš„ç¯ï¼Œé‚£å°±GPIOCENå†™å…¥1å³å¯ï¼š\n1 2 3 4 5 // main.cä¸­çš„ä¸»å‡½æ•°ä¸­ï¼Œå…¶ä»–ä»£ç çœç•¥ // é¦–å…ˆæ‰“å¼€GPIOCçš„æ—¶é’Ÿ // ç”±äºå†™å…¥çš„æ˜¯16è¿›åˆ¶ï¼Œæˆ‘ä»¬éœ€è¦æ¯4ä½è½¬æ¢ä¸€æ¬¡ï¼Œå³ RCC -\u003e AHB1ENR = 0x00000004; ç„¶åæ‰¾åˆ°å¯¹åº”IOçš„é€šç”¨é…ç½®é«˜å¯„å­˜å™¨GPIOx_CRHï¼Œå¯ä»¥çœ‹åˆ°å¯¹åº”GPIOCæœ‰ä¸¤ä¸ªåœ°æ–¹ï¼ŒCNFé…ç½®ä¸º00ï¼Œå³æ¨æŒ½æ¨¡å¼ï¼Œè€ŒMODEé…ç½®ä¸º11ï¼ˆè¿™é‡ŒF411è¿˜æ˜¯å’Œè§†é¢‘ä¸­ä¸ä¸€æ ·ï¼Œæˆ‘ç›´æ¥å†™F411çš„ä»£ç ï¼‰\n1 2 3 // é…ç½®è¾“å‡ºå¯„å­˜å™¨ GPIOC -\u003e MODER = 0x0C000000; GPIOC -\u003e OTYPER = 0x00000000;\tå¾€PC13ç«¯å£ï¼Œå†™å…¥é«˜ç”µå¹³ å†™å‡ºæ•°æ®çš„å¯„å­˜å™¨å«GPIOx_ODRï¼Œæˆ‘ä»¬å¾€PC13å†™å‡ºé«˜ç”µå¹³ï¼Œå³ï¼š\nGPIOC -\u003e ODR = 0x00002000; OKï¼Œè¿™å°±æ˜¯å¯„å­˜å™¨ç¼–ç¨‹çš„å¤§æ¦‚æµç¨‹ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œä¸»è¦æ˜¯ç®€å•äº†è§£ä¸€ä¸‹ç¼–ç¨‹çš„æµç¨‹ï¼Œå³ä½¿èƒ½æ—¶é’Ÿã€é…ç½®IOã€è¾“å…¥è¾“å‡ºã€‚åé¢æˆ‘ä»¬ä¼šä½¿ç”¨HALåº“æ¥å¯¹STM32è¿›è¡Œç¼–ç¨‹ã€‚\n","description":"","tags":["keyboard"],"title":"STM32","uri":"/posts/keyboard/stm32/"},{"categories":null,"content":"åœ¨Macä¸Šé¢ä½¿ç”¨VSCodeå¼€å‘stm32 å› ä¸ºæœ€è¿‘æœ‰é¡¹ç›®éœ€è¦å¯¹stm32è¿›è¡Œç¡¬ä»¶çš„å¼€å‘ï¼Œè€Œæˆ‘ç°åœ¨ä¸»è¦æ˜¯åœ¨ç”¨M1èŠ¯ç‰‡çš„Macï¼Œä¸”å®˜æ–¹æä¾›çš„å„ç§é…å¥—å·¥å…·éƒ½ä¸å¤ªè¡Œï¼Œæ‰€ä»¥è®°å½•ä¸€ä¸‹åœ¨Macä¸‹æŠ˜è…¾stm32å¼€å‘çš„è¿‡ç¨‹ã€‚\nå‡†å¤‡ é¦–å…ˆï¼Œè¿›è¡Œç¡¬ä»¶å¼€å‘ä½ å¾—æœ‰ç›¸åº”çš„ç¡¬ä»¶ã€‚æˆ‘æ˜¯ä»æ·˜å®ä¸Šä¹°äº†stm32f411ceu6çš„å¼€å‘æ¿ï¼Œä»¥åŠst-link v2çš„çƒ§å†™å™¨ï¼Œåœ¨æœ¬æ–‡ä¸­æˆ‘ä»¬å°±ä»¥å®ƒä»¬ä½œä¸ºç¤ºä¾‹ã€‚\nå…¶æ¬¡ï¼Œéœ€è¦ä¸‹è½½å®‡å®™ç¬¬ä¸€ç¼–è¾‘å™¨VSCodeï¼Œå¹¶ä¸”å®‰è£…PlatformIOæ’ä»¶ã€‚è¿™ä¸ªè¿‡ç¨‹å°±ä¸å†å±•å¼€äº†ï¼Œå¯èƒ½å®‰è£…PlatformIOæ’ä»¶ä¼šæ…¢ç‚¹ï¼Œç­‰å¾…å³å¯ã€‚\nå®‰è£…STM32CubeMX å†ç„¶åå°±éœ€è¦å®‰è£…STM32CubeMXäº†ã€‚è¿™ä¸ªå·¥å…·æ˜¯ç”¨æ¥è‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„å·¥ç¨‹çš„ï¼Œè¦å¼€å‘stm32ç³»åˆ—å•ç‰‡æœºï¼Œå‡ ä¹ä¹Ÿæ˜¯å¿…é¡»çš„ã€‚\né¦–å…ˆï¼Œä¸‹è½½STM32CubeMXå®‰è£…åŒ…ï¼šhttps://www.st.com/zh/development-tools/stm32cubemx.html#overviewã€‚å®˜æ–¹æä¾›äº†Macç³»ç»Ÿå¯¹åº”çš„å®‰è£…åŒ…ï¼Œç‚¹å‡»ä¸‹è½½å³å¯ï¼Œå¤§çº¦å‡ ç™¾M\nä¸‹è½½ä¸‹æ¥æ˜¯ä¸€ä¸ªzipæ–‡ä»¶ï¼Œè§£å‹ä¹‹\nè§£å‹åçš„æ–‡ä»¶å¤¹ä¸­ï¼Œæœ‰ä¸€ä¸ª.appæ–‡ä»¶ã€‚ä¸€èˆ¬æ¥è¯´ç›´æ¥æ‰§è¡Œè¿™ä¸ª.appæ–‡ä»¶å³å¯ï¼Œä½†æ˜¯å¯¹äºM1çš„Macæ¥è¯´ï¼Œç”±äºè‹¹æœçš„å®‰å…¨ç­–ç•¥ï¼Œå¯¼è‡´ç›´æ¥å®‰è£…ä¸å¯è¡Œï¼Œéœ€è¦ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤å¤„ç†.appæ–‡ä»¶\n1 sudo xattr -cr xxxxx.app å®‰è£…è¿‡ç¨‹éœ€è¦ä½ æœ¬åœ°è£…æœ‰Javaï¼Œå¦‚æœä½ æœ¬åœ°æ²¡æœ‰Javaï¼Œæˆ–è€…Javaç‰ˆæœ¬ä¸å¯¹ï¼Œä¾ç„¶ä¸è¡Œã€‚ä¸è¿‡å¥½åœ¨åœ¨å®‰è£…åŒ…ä¸­ï¼Œå·²ç»è´´å¿ƒåœ°ç»™ä½ å‡†å¤‡å¥½äº†Jreï¼ˆæ²¡é”™ï¼Œå‹ç¼©åŒ…è§£å‹ä¹‹åæœ‰ä¸€ä¸ªjreæ–‡ä»¶å¤¹ï¼Œå°±æ˜¯åšè¿™ä¸ªçš„ï¼‰ã€‚ä¸è¿‡ï¼Œç”±äºè‹¹æœçš„å®‰å…¨ç­–ç•¥ï¼Œä½ è¿˜æ˜¯æ²¡æœ‰åŠæ³•ç›´æ¥ä½¿ç”¨jreæ–‡ä»¶å¤¹ä¸­çš„Javaï¼Œç±»ä¼¼åœ°ï¼Œä½ éœ€è¦å¯¹jreæ–‡ä»¶å¤¹å†æ‰§è¡Œä¸€éxattrï¼š\n1 sudo xattr -cr jre ç°åœ¨ä½ å¯ä»¥ä½¿ç”¨Javaæ‰§è¡Œå®‰è£…åŒ…ï¼š\n1 java -jar xxx.app ä¹‹åï¼Œä¼šå¼¹å‡ºå®‰è£…åŒ…çš„ç•Œé¢ï¼ˆè¿™ç•Œé¢çœŸå¤å¤ï¼‰ã€‚ä¸€è·¯nextï¼Œå°±èƒ½å¯ä»¥æŠŠSTM32CubeMXå®‰è£…å¥½äº†\nä½¿ç”¨STM32CubeMXåˆå§‹åŒ–å·¥ç¨‹ æ‰€æœ‰çš„ä¾èµ–éƒ½å®‰è£…å¥½äº†ï¼Œä¸‹é¢æ¥åˆå§‹åŒ–å·¥ç¨‹ã€‚æ‰“å¼€STM32CubeMXï¼Œä¸Šé¢çš„Fileèœå•ä¸­é€‰æ‹©New Projectï¼ˆå¯èƒ½ä¼šè¯»æ¡ï¼Œç­‰å¾…å³å¯ï¼‰ã€‚ç„¶ååœ¨æ–°å»ºå·¥ç¨‹çš„çª—å£ä¸­æœç´¢ä½ çš„MCUï¼Œæˆ‘è¿™é‡Œä½¿ç”¨stm32f411ceu6ï¼š\né€‰æ‹©å®ŒMCUä¹‹åï¼Œå³ä¸Šè§’Start Projectï¼Œå°±è¿›å…¥åˆå§‹åŒ–é¡µé¢ã€‚å‰é¢çš„é€‰é¡¹éƒ½ä¸ç”¨æ”¹ï¼Œç›´æ¥ç‚¹åˆ°Project Manageréƒ¨åˆ†ï¼Œè¾“å…¥ä¸€ä¸ªProjectåç§°ï¼Œç„¶ååœ¨ToolChain/IDEè¿™é‡Œé€‰æ‹©Makefileï¼š\nç‚¹å‡»å³ä¸Šè§’GENERATE CODEå³å¯ç”Ÿæˆä»£ç \nOption1ï¼šä½¿ç”¨PlatformIO æ‰“å¼€VSCodeçš„å‘½ä»¤ç•Œé¢ï¼Œè¾“å…¥show platformIOï¼Œæ‰“å¼€platformIOçš„ä¸»é¡µé¢ï¼Œç‚¹å‡»é¡µé¢ä¸Šçš„New Projectåˆ›å»ºå·¥ç¨‹ã€‚åœ¨åˆ›å»ºå·¥ç¨‹å¼¹çª—ä¸­ï¼Œ Project Nameå¡«å†™åˆšåˆšåœ¨CubeMXä¸­å†™çš„Projectåç§°ï¼ŒBoardé€‰æ‹©stm32f411CEï¼Œframeworkæ³¨æ„éœ€è¦é€‰æ‹©STM32Cubeã€‚ç„¶åé‡ç‚¹æ¥äº†ï¼Œå–æ¶ˆUse default locationå‹¾é€‰ï¼Œå¹¶ä¸”åœ¨ä¸‹é¢çš„è·¯å¾„é€‰æ‹©ä¸­é€‰æ‹©åˆšåˆšCubeMXç”Ÿæˆçš„ä»£ç ç›®å½•çš„çˆ¶æ–‡ä»¶å¤¹ã€‚\nç‚¹å‡»finishï¼Œåˆæ¬¡ç”Ÿæˆå¯èƒ½éœ€è¦ç­‰å¾…ï¼Œå®Œæˆä¹‹åVSCodeä¼šè‡ªåŠ¨è·³åˆ°å¯¹åº”çš„æ–‡ä»¶å¤¹ã€‚\nç„¶åï¼Œæ£€æŸ¥ä¸€ä¸‹æ–‡ä»¶ä¸‹çš„æ ¹ç›®å½•ä¸‹é¢æ˜¯å¦åŒæ—¶å­˜åœ¨[ä½ çš„å·¥ç¨‹å].iocå’Œplatformio.iniï¼Œå¦‚æœæœ‰ï¼Œé‚£è¯´æ˜ä»£ç å·¥ç¨‹å·²ç»è¢«æˆåŠŸåˆ›å»ºã€‚\næ¥ä¸‹æ¥ï¼Œæ‰“å¼€platformio.iniï¼ŒæŠŠCubeMXç”Ÿæˆçš„Srcç›®å½•å’ŒHeaderç›®å½•è®¾ç½®ä¸ºplatformIOçš„å¯¹åº”ç›®å½•ï¼Œç„¶åè®¾ç½®ä¸€ä¸‹ä¸‹è½½å™¨ï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯st-linkï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 # platformio.ini [env:genericSTM32F411CE] platform = ststm32 board = genericSTM32F411CE framework = stm32cube # è®¾ç½®ä¸‹è½½å™¨ debug_tool = stlink upload_protocol = stlink [platformio] include_dir=Core/Inc src_dir=Core/Src Doneï¼æ‰€æœ‰çš„é…ç½®éƒ½å®Œæˆäº†ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥æŠŠplatformIOè‡ªåŠ¨ç”Ÿæˆçš„å·¥ç¨‹æ–‡ä»¶å¤¹src, lib , teståˆ æ‰ï¼ˆæˆ‘ä»¬ç”¨çš„æ˜¯CubeMXç”Ÿæˆçš„ä»£ç å·¥ç¨‹ï¼Œä¸æ˜¯å—ï¼‰ã€‚\nçƒ§å½•å’Œè°ƒè¯• è¿æ¥st-linkä»¥åŠå¼€å‘æ¿ï¼Œå•å‡»VSCodeä¸‹é¢çš„uploadé€‰é¡¹å³å¯çƒ§å½•ä»£ç ï¼š\nå¦‚æœæƒ³è¦è°ƒè¯•çš„è¯ï¼Œå•å‡»F5ï¼ˆVSCodeçš„é»˜è®¤è°ƒè¯•å¿«æ·é”®ï¼‰å³å¯ã€‚Easyï¼Œ huhï¼Ÿ\nOption2ï¼šä½¿ç”¨makefile + OpenOCD å¦‚æœä¸æƒ³ä½¿ç”¨platformIOï¼Œå…¶å®ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚åªä¸è¿‡éœ€è¦å¯¹VSCodeå¤šä¸€ç‚¹ç‚¹é…ç½®ã€‚\nC/C++è®¾ç½® åœ¨ç”Ÿæˆå·¥ç¨‹ä¹‹åï¼Œé¦–å…ˆæ‰“å¼€.vscodeç›®å½•ä¸‹çš„c_cpp_properties.jsonï¼Œæ–°å»ºä¸€ä¸ªé…ç½®é¡¹ï¼Œæ¯”å¦‚Macï¼Œç„¶åæŠŠå„ç§ä¾èµ–æ·»åŠ è¿›includePathï¼Œå¹¶ä¸”è®¾ç½®browseã€definesã€compilerPathç­‰å‚æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 { \"configurations\": [ { \"name\": \"Mac\", \"includePath\": [ \"${workspaceFolder}/**\", \"${workspaceFolder}/Inc\", \"${workspaceFolder}/Drivers/STM32H4xx_HAL_Driver/Inc\", \"${workspaceFolder}/Drivers/STM32H4xx_HAL_Driver/Inc/Legacy\", \"${workspaceFolder}/Drivers/CMSIS/Include\", \"${workspaceFolder}/Drivers/CMSIS/Device/ST/STM32F4xx/Include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/arm-none-eabi/include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/arm-none-eabi/include/c++/10.3.1\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/lib/gcc/arm-none-eabi/10.3.1/include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/lib/gcc/arm-none-eabi/10.3.1/include-fixed\" ], \"defines\": [ \"USE_HAL_DRIVER\", \"STM32F411xE\" ], \"macFrameworkPath\": [ \"/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/System/Library/Frameworks\" ], \"compilerPath\": \"/opt/homebrew/bin/arm-none-eabi-gcc\", \"cStandard\": \"c17\", \"cppStandard\": \"c++20\", \"intelliSenseMode\": \"macos-clang-arm64\", \"configurationProvider\": \"ms-vscode.makefile-tools\", \"browse\": { \"path\": [ \"${workspaceFolder}/**\", \"${workspaceFolder}/Inc\", \"${workspaceFolder}/Drivers/STM32H4xx_HAL_Driver/Inc\", \"${workspaceFolder}/Drivers/STM32H4xx_HAL_Driver/Inc/Legacy\", \"${workspaceFolder}/Drivers/CMSIS/Include\", \"${workspaceFolder}/Drivers/CMSIS/Device/ST/STM32F4xx/Include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/arm-none-eabi/include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/arm-none-eabi/include/c++/10.3.1\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/lib/gcc/arm-none-eabi/10.3.1/include\", \"/opt/homebrew/Cellar/arm-none-eabi-gcc/10.3-2021.07/gcc/lib/gcc/arm-none-eabi/10.3.1/include-fixed\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"${workspaceFolder}/.vscode/browse.vc.db\" } } ], \"version\": 4 } éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œdefineséœ€è¦å’Œä½ çš„Makefileé‡Œé¢çš„C defineså¯¹åº”\nå¦å¤–ï¼Œ æ·»åŠ è¿›Pathä¸­çš„arm-none-eabi-gccéœ€è¦å¡«å†™ä½ æœ¬åœ°çš„å¯¹åº”SDKçš„å®‰è£…åœ°å€ã€‚\nç„¶åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‘½ä»¤è¡Œä¸­æ‰§è¡Œmakeæ¥æµ‹è¯•æ˜¯å¦å¯ä»¥æ­£ç¡®ç¼–è¯‘ã€‚æ³¨æ„ï¼Œå¦‚æœä½ æ·»åŠ äº†é¢å¤–çš„.cæ–‡ä»¶ï¼Œåˆ™éœ€è¦åœ¨Makefileé‡Œé¢æŒ‡å®šï¼š\nå¦‚æœä½ çœ‹åˆ°äº†å¦‚ä¸‹ä¿¡æ¯ï¼Œåˆ™è¯´æ˜å·¥ç¨‹é…ç½®åŸºæœ¬æ²¡æœ‰é—®é¢˜ï¼š\nOpenOCDé…ç½® é¦–å…ˆå®‰è£…OpenOCDï¼š\n1 brew install openocd å®‰è£…å®Œæ¯•ä¹‹åï¼Œä½¿ç”¨openocd --versionæ£€æŸ¥æ˜¯å¦å®‰è£…æˆåŠŸã€‚\nç„¶åï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ›å»ºopenocd.cfgï¼Œå¹¶ä¸”å‚è€ƒ/opt/homebrew/Cellar/open-ocd/0.11.0/share/openocd/scripts/ä¸‹çš„é…ç½®ï¼Œé…ç½®ä½ è‡ªå·±çš„èŠ¯ç‰‡ã€‚æ¯”å¦‚ï¼Œå¯¹äºæˆ‘ä½¿ç”¨çš„stm32f411 + stlinkï¼Œæˆ‘éœ€è¦è¿›è¡Œå¦‚ä¸‹é…ç½®ï¼š\n# Use stlink source [find interface/stlink.cfg] transport select hla_swd # Set target source [find target/stm32f4x.cfg] æ³¨æ„ åœ¨Windowsä¸‹é¢ï¼ŒOpenOCDé…ç½®æœ‰ä¸ªå‘å°±æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨sysprogså…¬å¸ç¼–è¯‘çš„OpenOCDï¼ŒåŸå› æ˜¯VSCodeä¸­cortex-debugæ’ä»¶é»˜è®¤ä½¿ç”¨äº†VirtualGDBï¼Œè€ŒVirtualGDBå°±æ˜¯sysprogså…¬å¸å‡ºå“çš„ã€‚å› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä½¿ç”¨è¯¥å…¬å¸ç¼–è¯‘çš„OpenOCDæ‰èƒ½æ­£ç¡®ä¸‹è½½ã€‚æˆ‘ä»¬å¯ä»¥å»è¿™é‡Œä¸‹è½½å¯¹åº”çš„OpenOCDï¼Œè§£å‹å¹¶ä¸”æ·»åŠ åˆ°Pathç¯å¢ƒå˜é‡ä¸­ã€‚\næ·»åŠ SVDæ–‡ä»¶ æ·»åŠ .svdæ–‡ä»¶å¯ä»¥åœ¨è°ƒè¯•çš„æ—¶å€™çœ‹åˆ°å„ä¸ªå¤–è®¾çš„çŠ¶æ€ï¼Œéå¸¸æ–¹ä¾¿ã€‚é¦–å…ˆåœ¨è¿™é‡Œä¸‹è½½å¯¹åº”èŠ¯ç‰‡çš„svdæ–‡ä»¶ï¼šhttps://github.com/posborne/cmsis-svd/\nå¦‚æœè¿™é‡Œæ²¡æœ‰ï¼Œå¯ä»¥å»keilçš„å®˜ç½‘ï¼ˆhttps://www.keil.com/dd2/pack/ï¼‰ä¸‹è½½å¯¹åº”å¼€å‘åŒ…ï¼Œè§£å‹ä¹‹åå»CMSIS/SVDç›®å½•ä¸‹æ‰¾å¯¹åº”çš„SVDï¼ˆç½‘é¡µå¾ˆå¡ï¼Œå°å¿ƒï¼‰ã€‚\næŠŠSVDå¤åˆ¶åˆ°é¡¹ç›®æ ¹ç›®å½•å¤‡ç”¨ã€‚\nVSCodeè®¾ç½® æ¥ä¸‹æ¥å°±æ˜¯VSCodeçš„debuggerè®¾ç½®ã€‚é¦–å…ˆï¼Œéœ€è¦é…ç½®ç¼–è¯‘å‘½ä»¤ã€‚åœ¨.vscodeæ–‡ä»¶å¤¹ä¸‹é¢æ·»åŠ tasks.jsonï¼Œå¹¶ä¸”å¡«å…¥å¦‚ä¸‹å†…å®¹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"make all\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"make\", \"args\": [ \"all\", \"-j\", \"4\" ] }, { \"label\": \"make clean\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"make\", \"args\": [ \"clean\" ] } ] } VSCodeçš„taskç›¸å…³å†…å®¹å¯ä»¥å»çœ‹VSCodeå®˜æ–¹æ–‡æ¡£ï¼Œä»‹ç»å¾—éå¸¸è¯¦ç»†ã€‚è¿™é‡Œæˆ‘ä»¬å°±å®šä¹‰äº†ä¸¤ä¸ªtaskï¼Œä¸€ä¸ªæ˜¯make allï¼Œä¸€ä¸ªæ˜¯make cleanã€‚\nåœ¨é…ç½®å®ŒTaskä¹‹åï¼ŒæŒ‰ä¸‹å¿«æ·é”®cmd+shift+bï¼Œå°±å¯é€‰æ‹©å¿«é€Ÿè¿è¡Œtaskäº†ï¼š\nç„¶åï¼Œæˆ‘ä»¬é…ç½®debugã€‚é¦–å…ˆå®‰è£…cortex-debugæ’ä»¶ã€‚å®‰è£…å®Œæ¯•ä¹‹åï¼Œåœ¨.vscodeç›®å½•ä¸‹åˆ›å»ºlaunch.jsonï¼Œå¹¶ä¸”è¿›è¡Œå¦‚ä¸‹é…ç½®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { // ä½¿ç”¨ IntelliSense äº†è§£ç›¸å…³å±æ€§ã€‚ // æ‚¬åœä»¥æŸ¥çœ‹ç°æœ‰å±æ€§çš„æè¿°ã€‚ // æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Cortex Debug\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"./build/f411.elf\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"runToEntryPoint\": \"main\", \"servertype\": \"openocd\", \"showDevDebugOutput\": \"parsed\", \"configFiles\": [ \"openocd.cfg\" ], \"svdFile\": \"STM32F411xx.svd\", \"device\": \"stlink\", \"preLaunchTask\": \"make all\" } ] } éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨executableä¸‹ï¼Œéœ€è¦å¡«å†™ä½ è‡ªå·±çš„å›ºä»¶è·¯å¾„ã€‚ç„¶åè®¾ç½®svdFileä¸ºä½ åˆšåˆšä¸‹è½½çš„é‚£ä¸ªSVDæ–‡ä»¶ã€‚ç„¶åç‚¹å‡»F5å°±å¯ä»¥æ„‰å¿«åœ°debugäº†ã€‚åœ¨è®¾ç½®äº†SVDä¹‹åï¼Œè¿˜å¯ä»¥åœ¨Debugé¡µé¢ä¸‹çœ‹åˆ°å„ä¸ªå¤–è®¾å’Œå¯„å­˜å™¨çš„çŠ¶æ€ï¼š\nIAP åœ¨äº§å‡ºçš„.binæ–‡ä»¶æœ«å°¾è¿½åŠ 4bytesçš„CRCæ ¡éªŒå€¼ï¼Œç„¶ååœ¨bootloaderä¸­ï¼Œé¦–å…ˆä»USBè¯»å–æ–‡ä»¶åˆ°ä¸€å—Flashçš„ä¸´æ—¶åŒºåŸŸï¼Œç„¶åæ ¹æ®æ–‡ä»¶çš„é•¿åº¦ï¼Œè®¡ç®—.binæ–‡ä»¶çš„CRCæ ¡éªŒå’Œå¹¶ä¸”å’Œ.binæ–‡ä»¶æœ«å°¾çš„å€¼ä½œæ¯”è¾ƒï¼Œå¦‚æœä¸€æ ·ï¼Œåˆ™æ­£å¼æŠŠç»“æœçƒ§å†™åˆ°Flashçš„ç¨‹åºè¿è¡ŒåŒºåŸŸã€‚å¦åˆ™ç›´æ¥é€€å‡ºã€‚è¿™æ ·å¯ä»¥é˜²æ­¢åœ¨å¤åˆ¶å›ºä»¶çš„è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œä»è€Œè®©ç³»ç»Ÿå˜ç –ã€‚\n","description":"","tags":["keyboard"],"title":"Develop stm32 using VSCode + PlatformIO on MacOS","uri":"/posts/keyboard/develop-stm32-using-vscode/"},{"categories":null,"content":"QMK What's QMK? QMK is a series of open source firmware for keyboard. Besides firmware, it also provides many useful tools for configuring your keyboard, such as QMK Configurator, QMK toolbox, etc.\nInstallation To install QMK on Mac(Intel), you can just use brew install qmk/qmk/qmk. But for M1 Macs, this installation might fail. Here is the reference for installing QMK through rosetta2: https://www.reddit.com/r/olkb/comments/nh2fk9/guide_installing_qmk_on_m1_macbook/\nAfter installation, you should use qmk setup to set your QMK configuration. Then, you can use QMK to build firmware for your keyboard!\nBuild your first firmware We can start from build a default keymap for your keyboard. To build the firmware with default keymap, you can use\n1 qmk compile -kb \u003cyour_keyboard\u003e -km default This requires your keyboard is supported officially by QMK. If not, you can create a PR to add your keyboard to QMK repo.\nIf you see the message like following, your firmware is sucessfully built:\nLinking: .build/clueboard_66_rev3_default.elf [OK] Creating load file for flashing: .build/clueboard_66_rev3_default.hex [OK] Copying clueboard_66_rev3_default.hex to qmk_firmware folder [OK] Checking file size of clueboard_66_rev3_default.hex [OK] * The firmware size is fine - 26356/28672 (2316 bytes free) Create your first firmware In the last section, we just created a firmware for clueboard_66_rev3 with default keymap. Now we'll create a new keyboard and build the firmware with a customized keymap.\nCreate a new keyboard First of all, you can create your own qmk keyboard using\n1 qmk new-keyboard Then you'll asked to choose your keyboard's name, layout and MCU. Keyboard naming supports at most 4 folder levels, the generated keyboard folder will be placed under keyboards folder:\n1 2 3 4 5 6 7 8 9 # Keyboard naming example, clueboard uses sub-folders for both organizations and revisions - qmk_firmware - keyboards - clueboard â† This is the organization folder, thereâ€™s no rules.mk file - 60 â† This is a compilable keyboard, it has a rules.mk file - 66 â† This is also compilable- it uses DEFAULT_FOLDER to specify rev3 as the default revision - rev1 â† compilable: make clueboard/66/rev1 - rev2 â† compilable: make clueboard/66/rev2 - rev3 â† compilable: make clueboard/66/rev3 or make clueboard/66 If a sub-folder has rules.mk, it will be considered as a keyboard. The keyboard folder has the following files\nreadme.md\nreadme.md is needed in QMK configurator for basic information about this keyboard\ninfo.json\ninfo.json is used by QMK API, it contains the information and metadata about this keyboard. Here is the reference about info.json\nconfig.h\nconfig.h sets important hardware informations about the keyboard, such as matrix size, product name, USB VID/PID, etc. This file is required for all keyboards firmware. For most cases, information in config.h should be consist with info.json\nrules.mk\nrules.mk means that this folder is a keyboard target and you can run make command here. In this file, you can write the default configuration of your keyboard and enable QWK features.\n\u003ckeyboard_name\u003e.c\nYou can write your own code here. There are some functions that you can write:\nvoid matrix_init_kb(void) void matrix_scan_kb(void) bool process_record_kb(uint16_t keycode, keyrecord_t *record) void led_set_kb(uint8_t usb_led) \u003ckeyboard_name\u003e.h\nYou'll define the matrix for your keyboard and other variables which will be used in \u003ckeyboard_name\u003e.c here\nCreate a new keymap After creating your keyboard, you can create a new keymap for your keyboard using\n1 qmk new-keymap -kb \u003cyour_keyboard\u003e Then, a keymap.c file will be created at the keyboard folder. You can edit this file to customize your keymap as you want.\nEdit your keymap Open keymap.c using your favorite IDE/text editor, edit the file as you want. There are some keycodes reference here:\nBasic Keycodes Quantum Keycodes Grave/Escape Mouse keys Remember to save your keymap after you edit it.\nBuild your firmware After you edit your keymap, you can use qmk compile command to complie your firmware:\n1 qmk compile -kb \u003cyour_keyboard\u003e -km \u003cyour_keymap\u003e If you see the output like:\nLinking: .build/lockr_fancer_default.elf [OK] Creating binary load file for flashing: .build/lockr_fancer_default.bin [OK] Creating load file for flashing: .build/lockr_fancer_default.hex [OK] Size after: text\tdata\tbss\tdec\thex\tfilename 0\t23028\t0\t23028\t59f4\tlockr_fancer_default.bin Copying lockr_fancer_default.bin to qmk_firmware folder [OK] Congraduations! You've done with your first customized keyboard and keymap using QMK.\nFlash your keyboard The last thing you need to do is to flash the firmware to your keyboard. There are some steps to flash the firmware:\nPut your keyboard into DFU mode\nIt depends on the specific hardware and firmware. You can try the steps to enable DFU mode here.\nFlash your firmware using QMK toolbox\nThis is the simplest way if you've successfully enable DFU mode and QMK toolbox recognizes it. Simply load the .hex or .bin file you just compiled in QMK toolbox and click the Flash button in QMK toolbox. If you see the following output:\n*** DFU device connected: Atmel Corp. ATmega32U4 (03EB:2FF4:0000) *** Attempting to flash, please don't remove device \u003e\u003e\u003e dfu-programmer.exe atmega32u4 erase --force Erasing flash... Success Checking memory from 0x0 to 0x6FFF... Empty. \u003e\u003e\u003e dfu-programmer.exe atmega32u4 flash \"D:\\Git\\qmk_firmware\\gh60_satan_default.hex\" Checking memory from 0x0 to 0x3F7F... Empty. 0% 100% Programming 0x3F80 bytes... [\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e] Success 0% 100% Reading 0x7000 bytes... [\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e] Success Validating... Success 0x3F80 bytes written into 0x7000 bytes memory (56.70%). \u003e\u003e\u003e dfu-programmer.exe atmega32u4 reset *** DFU device disconnected: Atmel Corp: ATmega32U4 (03EB:2FF4:0000) All things are done! Then test your keyboard.\n(optional) Flash your keyboard from CLI\nYou can also flash your keyboard from QMK cli tool, this is also quite simple:\n1 qmk flash Flash STM32 For most stm32 series MCUs, you have to enable DFU mode and then flash it. If you have a brand new stm32, you can enable DFU first using a hardware-way. STM32 series has three booting strategies, see the following table:\nSTM32 has a default bootloader in system memory, with enabling DFU mode. What you need to do is setting BOOT0 pin to 1, and BOOT1 pin to 0, reset the chip. Then open QMK toolbox to flash your firmware or using\nqmk flash command. If you see\nin QMK toolbox or the following output in your terminal:\nOpening DFU capable USB device... Device ID 0483:df11 Device DFU version 011a Claiming USB DFU Interface... Setting Alternate Interface #0 ... Determining device status... DFU state(10) = dfuERROR, status(10) = Device's firmware is corrupt. It cannot return to run-time (non-DFU) operations Clearing status Determining device status... DFU state(2) = dfuIDLE, status(0) = No error condition is present DFU mode device DFU version 011a Device returned transfer size 2048 DfuSe interface name: \"Internal Flash \" Downloading element to address = 0x08000000, size = 55316 Erase [=========================] 100% 55316 bytes Erase done. Download\t[=========================] 100% 55316 bytes Download done. File downloaded successfully Submitting leave request... Transitioning to dfuMANIFEST state You've successfully flash your STM32 MCU!\nMCUs æ³¨ï¼š\nQMKé»˜è®¤æ”¯æŒçš„MCUåˆ—è¡¨\n","description":"","tags":["keyboard","qmk"],"title":"Learn QMK","uri":"/posts/keyboard/qmk/"},{"categories":null,"content":"Get Started With Tokio What's Tokio? Tokio is an asynchronous runtime for the Rust programming language. It is designed for IO-bound applications, and provides many useful utilities for asynchronous cases.\nTokio application Let's start with a simple hello world tokio application. First of all, add tokio as the dependency of your project:\n1 tokio = { version = \"1\", features = [\"full\"] } Then, write your first tokio hello world program:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 async fn say_world() { print!(\"world\"); } #[tokio::main] async fn main() { // Calling `say_world()` does not execute the body of `say_world()`. let op = say_world(); // This println! comes first print!(\"hello\"); // Calling `.await` on `op` starts executing `say_world`. op.await; } Here are some notes about this hello world program:\nThe say_world function is prefixed with async keyword, which indicates that it's an asynchronous function. In Rust, this asynchronous function will not be executed until .await is called.\nThe main function is also asynchronous, but it must be marked using #[tokio::main].\nAt the beginning of main, say_world is called and the result is binded to op. However, because say_world is an asynchronous function, it won't be executed until op.await is called. Hence, the code above will always print helloworld at the console.\nSpawning In this section, we'll write a server which accepts and processes TCP sockets.\nIn the main function, we bind a tokio::net::TcpListener to a local address, listen to the address and process incoming sockets in an infinite loop:\n1 2 3 4 5 6 7 8 9 10 11 12 use tokio::net::{TcpListener, TcpStream}; #[tokio::main] async fn main() { // Bind the listener to the address let listener = TcpListener::bind(\"127.0.0.1:6379\").await.unwrap(); loop { // The second item contains the IP and port of the new connection. let (socket, _) = listener.accept().await.unwrap(); process(socket).await; } } Note that the process() function should be asynchronous:\n1 2 3 async fn process(socket: TcpStream) { // process } The code above has a problem: we can only process only one request at a time. When it processes the request, it blocks in the inside the loop. In other languages, to process concurrent requests, threads/coroutines should be spawned to process requests in background, the main loop won't block. In Rust, you can do it as well, using tokio::spawn:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use tokio::net::TcpListener; #[tokio::main] async fn main() { let listener = TcpListener::bind(\"127.0.0.1:6379\").await.unwrap(); loop { let (socket, _) = listener.accept().await.unwrap(); // A new task is spawned for each inbound socket. The socket is // moved to the new task and processed there. tokio::spawn(async move { process(socket).await; }); } } You can see we spawned a closure(which is just like a anonymous function) using tokio::spawn. Note the async and move keyword before the spawned closure. async indicates that this closure is asynchronous and won't block, while move indicates that the used variables socket is moved into the closure and won't be dropped until the closure completes.\nTask A Tokio task is an asynchronous green thread. It can be created using tokio::spawn(async{}).\ntokio::spawn() will return a JoinHandle, the caller can use JoinHandle.await.unwrap() to get the result of the task:\n1 2 3 4 5 6 7 8 9 10 11 12 #[tokio::main] async fn main() { let handle = tokio::spawn(async { // Do some async work \"return value\" }); // Do some other work let out = handle.await.unwrap(); println!(\"GOT {}\", out); } Data passed to the task In the TcpListener example, we also add move keyword before spawning the task. This keyword is required, because socket cannot be accessed from multiple threads.\nTask is Send! Tasks spawned by tokio::spawn must implement Send trait. This is because when we call .await, the task is moved by tokio runtime between threads.\nBut how to make a task Send? The answer is, if all data held by the task is Send, then the task is Send. If there exists which is not Send, the task won't compile, the following is an example:\n1 2 3 4 5 6 7 8 9 use std::sync::{Mutex, MutexGuard}; // It won't compile! async fn increment_and_do_stuff(mutex: \u0026Mutex\u003ci32\u003e) { let mut lock: MutexGuard\u003ci32\u003e = mutex.lock().unwrap(); *lock += 1; do_something_async().await; } // lock goes out of scope here This function will not compile, because MutexGuard is not Send. You can do a little refactoring to address it:\n1 2 3 4 5 6 7 8 9 // This works! async fn increment_and_do_stuff(mutex: \u0026Mutex\u003ci32\u003e) { { let mut lock: MutexGuard\u003ci32\u003e = mutex.lock().unwrap(); *lock += 1; } // lock goes out of scope here do_something_async().await; } Share state between tasks The state can be wrapped in Arc\u003cMutex\u003c_\u003e\u003e, making it accessable across many tasks and potentially many threads. For example, if you want to pass a shared HashMap to spawned tasks, you can just use Arc::new(Mutex::new(HashMap::new())) to initialize the map:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 use tokio::net::TcpListener; use std::collections::HashMap; use std::sync::{Arc, Mutex}; #[tokio::main] async fn main() { let listener = TcpListener::bind(\"127.0.0.1:6379\").await.unwrap(); println!(\"Listening\"); let db = Arc::new(Mutex::new(HashMap::new())); loop { let (socket, _) = listener.accept().await.unwrap(); // Clone the handle to the hash map. let db = db.clone(); println!(\"Accepted\"); tokio::spawn(async move { process(socket, db).await; }); } } Note that it is std::sync::Mutex, not tokio::sync::Mutex used to guard the HashMap.\nChannels Channels pass informations between threads, which is similar to channels in Golang. But in Rust, there are more types of channels, which serve for different purposes:\nmpsc: multi-producer, single-consumer channel. Many values can be sent.\noneshot: single-producer, single consumer channel. A single value can be sent.\nbroadcast: multi-producer, multi-consumer. Many values can be sent. Each receiver sees every value.\nwatch: single-producer, multi-consumer. Many values can be sent, but no history is kept. Receivers only see the most recent value.\nThere are also some other channel crates in Rust ecosystem, such as crossbeam. This document explains the differences. In one word, crossbeam::channel would block the current thread while tokio not, because tokio is designed for asynchronous situations.\nIn this article, I'll introduce mpsc and oneshot as the example.\nDefine a channel First, we define a mpsc channel:\n1 2 3 4 5 6 7 use tokio::sync::mpsc; #[tokio::main] async fn main() { // Create a new channel with a capacity of at most 32. let (tx, mut rx) = mpsc::channel(32); } mpsc::channel(32) returns both sender and receiver of the channel, we bind the sender with name tx and the receiver with rx. 32 is the buffer size of the channel.\nTo send a message to the channel, we can use tx.send():\n1 2 3 tokio::spawn(async move { tx.send(\"sending from first handle\").await; }); Because mpsc is a multi-producer channel, we can clone the sender and send messages from multiple tasks:\n1 2 3 4 5 6 7 8 9 let tx2 = tx.clone(); tokio::spawn(async move { tx.send(\"sending from first handle\").await; }); tokio::spawn(async move { tx2.send(\"sending from second handle\").await; }); .await is called after send(), which indicates the sending thread will wait until the receiver reads the sent message.\nThen, we use rx.recv() to receive messages sent to the channel:\n1 2 3 while let Some(message) = rx.recv().await { println!(\"GOT = {}\", message); } The receiver cannot be cloned, only one receiver can be used to receive messages for mpsc channel. When all senders are dropped, rx.recv() would return None, which indicates all senders are gone and the channel is closed.\nThe complete example code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 use tokio::sync::mpsc; #[tokio::main] async fn main() { let (tx, mut rx) = mpsc::channel(32); let tx2 = tx.clone(); tokio::spawn(async move { tx.send(\"sending from first handle\").await; }); tokio::spawn(async move { tx2.send(\"sending from second handle\").await; }); while let Some(message) = rx.recv().await { println!(\"GOT = {}\", message); } } In the code, we process the received message in the main thread. You can also spawn a new thread to process it.\nIO Tokio provides apis for asynchronous IO, which are similar with IO apis in std.\nBuffered read and write Generally, the message is transmitted like a frame, a typical HTTP frame is like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 enum HttpFrame { RequestHead { method: Method, uri: Uri, version: Version, headers: HeaderMap, }, ResponseHead { status: StatusCode, version: Version, headers: HeaderMap, }, BodyChunk { chunk: Bytes, }, } The frame will be converted to byte arrays to be transmitted, so when we read data, we have to convert byte arrays back to frames. Take TcpStream::read() as an example, when we manually call read(), an arbitrary amount of data might be returned. The returned data could be a frame, or a partial frame, or multiple frames. This is a little bit complex, as a result buffered IO is introduced to address this.\nFirst of all, we wrap TcpStream with a buffer:\n1 2 3 4 5 6 7 use bytes::BytesMut; use tokio::net::TcpStream; pub struct Connection { stream: TcpStream, buffer: BytesMut, } ","description":"","tags":["rust"],"title":"Get Started With Tokio","uri":"/posts/engineering/tokio/"},{"categories":null,"content":"Basics of Vue ä»€ä¹ˆæ˜¯Vueï¼Ÿ\nVueæ˜¯ä¸€æ¬¾ç”¨äºæ„å»ºç”¨æˆ·ç•Œé¢çš„ JavaScript æ¡†æ¶ã€‚å®ƒåŸºäºæ ‡å‡† HTMLã€CSS å’Œ JavaScript æ„å»ºï¼Œå¹¶æä¾›äº†ä¸€å¥—å£°æ˜å¼çš„ã€ç»„ä»¶åŒ–çš„ç¼–ç¨‹æ¨¡å‹ï¼Œå¸®åŠ©ä½ é«˜æ•ˆåœ°å¼€å‘ç”¨æˆ·ç•Œé¢ï¼Œæ— è®ºä»»åŠ¡æ˜¯ç®€å•è¿˜æ˜¯å¤æ‚ã€‚\nç®€ä»‹ Vueæ˜¯ç°åœ¨æœ€æµè¡Œçš„å‰ç«¯æ¡†æ¶ä¹‹ä¸€ï¼Œå®ƒä¸»è¦æ‹“å±•äº†HTMLçš„è¯­æ³•ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥å£°æ˜åŸºäºJSçŠ¶æ€çš„HTMLã€‚åŒæ—¶ï¼ŒVueä¼šè¿½è¸ªJSçš„çŠ¶æ€å˜åŒ–ï¼Œå¹¶ä¸”å“åº”å¼åœ°æ›´æ–°HTMLã€‚Vueæ—¢å¯ä»¥ç›´æ¥å¢å¼ºé™æ€çš„HTMLè€Œæ— éœ€æ„å»ºæµç¨‹ï¼Œä¹Ÿå¯ä»¥ä½œä¸ºWeb ComponentåµŒå…¥ç½‘é¡µã€‚\nå¯¹äºå…·æœ‰æ„å»ºæµç¨‹çš„å·¥ç¨‹æ¥è¯´ï¼ŒVueæ”¯æŒä¸€ç§ç‰¹åˆ«çš„æ–‡ä»¶ï¼Œåå«å•æ–‡ä»¶ç»„ä»¶ï¼ˆä¹Ÿå°±æ˜¯.vueæ–‡ä»¶ï¼Œè‹±æ–‡ç¼©å†™ä¸ºSFCï¼‰ã€‚åœ¨SFCä¸­ï¼Œä½ å¯ä»¥æŠŠHTMLã€CSSã€JavaScriptå°è£…åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œä¸‹é¢å°±æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u003cscript\u003e export default { data() { return { count: 0 } } } \u003c/script\u003e \u003ctemplate\u003e \u003cbutton @click=\"count++\"\u003eCount is: {{ count }}\u003c/button\u003e \u003c/template\u003e \u003cstyle scoped\u003e button { font-weight: bold; } \u003c/style\u003e å¯ä»¥çœ‹åˆ°æ•´ä¸ªæ–‡ä»¶åˆ†æˆä¸‰å—ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†åˆ«æ˜¯JSã€HTMLå’ŒCSSã€‚\nVueåŸºç¡€ ä¸‹é¢å¼€å§‹ä»‹ç»Vueçš„åŸºç¡€çŸ¥è¯†ï¼Œæˆ‘ä»¬ä»åˆ›å»ºä¸€ä¸ªVueåº”ç”¨å¼€å§‹ã€‚\nVueåº”ç”¨ åº”ç”¨å®ä¾‹å’Œæ ¹ç»„ä»¶ æ¯ä¸€ä¸ªVueåº”ç”¨å®ä¾‹éƒ½éœ€è¦ä½¿ç”¨createAppåˆ›å»ºï¼ŒcreateAppçš„å…¥å‚æ˜¯æ ¹ç»„ä»¶ï¼Œæ ¹ç»„ä»¶ä¸‹é¢ä¼šæœ‰å„ç§å„æ ·çš„å­ç»„ä»¶æ¥æ„æˆé¡µé¢ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 import { createApp } from 'vue' const app = createApp({ /* æ ¹ç»„ä»¶é€‰é¡¹ */ }) // æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»å…¶ä»–æ–‡ä»¶ä¸­å¯¼å…¥æ ¹ç»„ä»¶ import { createApp } from 'vue' // ä»ä¸€ä¸ªå•æ–‡ä»¶ç»„ä»¶ä¸­å¯¼å…¥æ ¹ç»„ä»¶ import App from './App.vue' const app = createApp(App) æŒ‚è½½åº”ç”¨ æ¯ä¸€ä¸ªåº”ç”¨å®ä¾‹éœ€è¦è¢«æŒ‚è½½ï¼Œå³è°ƒç”¨äº†.mount()å‡½æ•°ä¹‹åæ‰èƒ½è¢«æ¸²æŸ“ã€‚.mount()æ¥æ”¶ä¸€ä¸ªâ€œå®¹å™¨â€å‚æ•°ï¼Œå¯ä»¥æ˜¯ä¸€ä¸ªå®é™…çš„ DOM å…ƒç´ æˆ–æ˜¯ä¸€ä¸ª CSS é€‰æ‹©å™¨å­—ç¬¦ä¸²ï¼š\n1 \u003cdiv id=\"app\"\u003e\u003c/div\u003e 1 app.mount('#app') è¿™æ ·ï¼Œæ¯ä¸€ä¸ªé¡µé¢å°±å¯ä»¥æœ‰å¤šä¸ªVueçš„åº”ç”¨å®ä¾‹ï¼ŒæŠŠåº”ç”¨æŒ‚è½½åœ¨å¯¹åº”çš„å…ƒç´ ä¸Šå³å¯\næ¨¡æ¿è¯­æ³• Vue ä½¿ç”¨ä¸€ç§åŸºäº HTML çš„æ¨¡æ¿è¯­æ³•ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿå£°æ˜å¼åœ°å°†å…¶ç»„ä»¶å®ä¾‹çš„æ•°æ®ç»‘å®šåˆ°å‘ˆç°çš„ DOM ä¸Šã€‚æ‰€æœ‰çš„ Vue æ¨¡æ¿éƒ½æ˜¯è¯­æ³•ä¸Šåˆæ³•çš„ HTMLï¼Œå¯ä»¥è¢«ç¬¦åˆè§„èŒƒçš„æµè§ˆå™¨å’Œ HTML è§£æå™¨è§£æã€‚\næ–‡æœ¬æ’å€¼ æœ€ç®€å•çš„æ•°æ®ç»‘å®šå½¢å¼å°±æ˜¯æ–‡æœ¬æ’å€¼ï¼Œåœ¨HTMLä¸­ä½¿ç”¨åŒå¤§æ‹¬å·æ¥æŒ‡å®šï¼š\n1 \u003cspan\u003eMessage: {{ msg }}\u003c/span\u003e åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼ŒåŒå¤§æ‹¬å·æ ‡ç­¾ä¼šè¢«æ›¿æ¢ä¸ºmsgå¯¹åº”çš„propertyçš„å€¼ï¼Œæ¯æ¬¡msgçš„propertyçš„å€¼æ”¹å˜çš„æ—¶å€™HTMLæ¸²æŸ“çš„ç»“æœä¹Ÿä¼šå®æ—¶æ›´æ–°ã€‚\nç»‘å®šAttributes HTMLä¸­ï¼Œæ¯ä¸ªæ ‡ç­¾æœ‰å„ç§Attributesã€‚å¦‚æœæƒ³æŠŠå„ç§Attributesç»‘å®šåˆ°å¯å˜çš„å€¼é‡Œé¢ï¼Œå¯ä»¥ç”¨v-bindï¼š\n1 \u003cdiv v-bind:id=\"dynamicId\"\u003e\u003c/div\u003e ä¸Šé¢çš„ä»£ç å°±æŠŠ\u003cdiv\u003eçš„attribute idç»‘å®šåœ¨äº†dynamicIdè¿™ä¸ªå€¼ä¸Šé¢ã€‚v-bind:å¯ä»¥ä½¿ç”¨:ä»£æ›¿ã€‚å¦‚æœä½ æƒ³ç»‘å®šç‰¹å®šçš„classï¼ŒæŠŠidæ›¿æ¢æˆå¯¹åº”çš„classå³å¯ã€‚ä¸‹é¢å°±æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003cscript setup\u003e import { ref } from 'vue' const titleClass = ref('title') \u003c/script\u003e \u003ctemplate\u003e \u003ch1 :class=\"titleClass\"\u003eMake me red\u003c/h1\u003e \u003c/template\u003e \u003cstyle\u003e .title { color: red; } \u003c/style\u003e è¿™æ ·ï¼Œå°±æŠŠMake me redè¿™ä¸ªæ–‡æœ¬çš„é¢œè‰²è®¾ç½®æˆäº†çº¢è‰²ï¼ˆå³\u003cstyle\u003eä¸­csså®šä¹‰çš„é¢œè‰²ï¼‰\näº‹ä»¶ç›‘å¬ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨v-onæ¥ç›‘å¬DOMäº‹ä»¶ï¼š\n1 \u003cbutton v-on:click=\"increment\"\u003e{{ count }}\u003c/button\u003e ä¹Ÿå¯ä»¥ä½¿ç”¨@ä½œä¸ºç®€å†™ï¼š\n1 \u003cbutton @click=\"increment\"\u003e{{ count }}\u003c/button\u003e ä¸Šé¢çš„ä»£ç å°±ç›‘å¬äº†\u003cbutton\u003eçš„clickäº‹ä»¶ï¼Œå½“ç›‘å¬åˆ°äº‹ä»¶ä¹‹åä¼šè§¦å‘incrementå‡½æ•°ã€‚\nè¡¨å•è¾“å…¥çš„ç»‘å®š Vueå¯¹äºè¡¨å•è¾“å…¥çš„caseæœ‰ä¸€ç§ç‰¹æ®Šçš„è¯­æ³•ï¼Œå«åšv-modelã€‚é¦–å…ˆï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹ä½¿ç”¨ä¸Šé¢ä»‹ç»çš„v-onå’Œv-bindå¦‚ä½•åšåˆ°è¡¨å•è¾“å…¥ï¼š\n1 \u003cinput :value=\"text\" @input=\"onInput\"\u003e 1 2 3 4 5 function onInput(e) { // a v-on handler receives the native DOM event // as the argument. text.value = e.target.value } åœ¨HTMLçš„ä¸­ï¼Œç»‘å®šä¸€ä¸ªå€¼åä¸ºtextï¼Œç„¶åæŠŠonInputå‡½æ•°ç»‘å®šåœ¨inputäº‹ä»¶ä¸Šï¼Œæœ€ååœ¨onInputä¸­ä¿®æ”¹textçš„å€¼ã€‚\nVueç›´æ¥æä¾›äº†v-modelç”¨æ¥åšè¿™ç§äº‹æƒ…ï¼Œå…¶ç”¨æ³•ä¹Ÿå¾ˆç®€å•ï¼š\n1 \u003cinput v-model=\"text\"\u003e è¿™æ ·å°±è‡ªåŠ¨æŠŠè¾“å…¥çš„å€¼ï¼ˆå³HTMLä¸­çš„inputï¼‰ç»‘å®šåœ¨äº†textä¸Šå¹¶ä¸”å®ç°è‡ªåŠ¨æ›´æ–°ã€‚v-modelä¸åªèƒ½ç»‘å®šæ–‡æœ¬è¾“å…¥ï¼Œè¿˜èƒ½ç»‘å®šå¾ˆå¤šç±»å‹çš„è¾“å…¥æ¯”å¦‚checkboxã€å•é€‰æŒ‰é’®ç­‰ç­‰ã€‚\næ¡ä»¶æ¸²æŸ“ åœ¨Vueä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ¡ä»¶æ¸²æŸ“æ¥å†³å®šæŸä¸€ä¸ªå…ƒç´ æ˜¯å¦è¢«æ¸²æŸ“ã€‚æ¡ä»¶æ¸²æŸ“çš„å…³é”®è¯æœ‰ä¸‰ä¸ªï¼šv-if,v-else,v-else-ifã€‚å…¶ä¸­ï¼Œv-elseå’Œv-else-ifå¿…é¡»è·Ÿåœ¨ä¸€ä¸ªv-ifæˆ–ä¸€ä¸ªv-else-ifå…ƒç´ åé¢ã€‚v-ifåé¢å¯ä»¥è·Ÿä¸€ä¸ªJavaScriptè¯­å¥ï¼Œå…¶å€¼ä¸ºtrueæˆ–è€…falseï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 \u003cdiv v-if=\"type === 'A'\"\u003e A \u003c/div\u003e \u003cdiv v-else-if=\"type === 'B'\"\u003e B \u003c/div\u003e \u003cdiv v-else-if=\"type === 'C'\"\u003e C \u003c/div\u003e \u003cdiv v-else\u003e Not A/B/C \u003c/div\u003e åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦æ¸²æŸ“ä¸€ç³»åˆ—å…ƒç´ ï¼Œä½†æ˜¯ç»™æ¯ä¸ªå…ƒç´ æ·»åŠ ç›¸åŒçš„v-ifåˆå¤ªéº»çƒ¦äº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬åº”è¯¥ä½¿ç”¨\u003ctemplate\u003eå…ƒç´ æ¥æŠŠæ‰€æœ‰å…ƒç´ åŒ…èµ·æ¥ï¼š\n1 2 3 4 5 \u003ctemplate v-if=\"ok\"\u003e \u003ch1\u003eTitle\u003c/h1\u003e \u003cp\u003eParagraph 1\u003c/p\u003e \u003cp\u003eParagraph 2\u003c/p\u003e \u003c/template\u003e \u003ctemplate\u003eå…ƒç´ å¹¶ä¸ä¼šè¢«æ¸²æŸ“ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªä¸å¯è§çš„åŒ…è£…å™¨å…ƒç´ ã€‚\né™¤äº†v-ifä¹‹å¤–ï¼ŒVueè¿˜æä¾›äº†v-showæ¥å†³å®šä¸€ä¸ªå…ƒç´ æ˜¯å¦è¢«æ˜¾ç¤ºã€‚v-showå’Œv-ifçš„åŒºåˆ«åœ¨äºï¼Œv-showä»…åˆ‡æ¢äº†è¯¥å…ƒç´ ä¸Šåä¸ºdisplayçš„CSSå±æ€§ï¼Œæ— è®ºè¯¥å…ƒç´ æ˜¾ç¤ºä¸å¦ï¼Œå®ƒéƒ½ä¼šè¢«æ¸²æŸ“ï¼ˆè€Œv-ifç›´æ¥å†³å®šè¯¥å…ƒç´ ä¼šä¸ä¼šè¢«æ¸²æŸ“ï¼‰ã€‚åŒæ—¶v-showä¹Ÿä¸æ”¯æŒelseã€‚\næ€»çš„æ¥è¯´ï¼Œv-ifåœ¨é¦–æ¬¡æ¸²æŸ“æ—¶çš„åˆ‡æ¢æˆæœ¬æ¯”v-showæ›´é«˜ã€‚å› æ­¤å½“ä½ éœ€è¦éå¸¸é¢‘ç¹åˆ‡æ¢æ—¶v-showä¼šæ›´å¥½ï¼ˆå› ä¸ºv-ifæ¯æ¬¡éƒ½ä¼šåˆ‡æ¢æ¸²æŸ“ or ä¸æ¸²æŸ“ï¼‰ï¼Œè€Œè¿è¡Œæ—¶ä¸å¸¸æ”¹å˜çš„æ—¶å€™v-ifä¼šæ›´åˆé€‚ã€‚\nåˆ—è¡¨æ¸²æŸ“ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨v-foræ¥æ¸²æŸ“ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œå…¶è¯­æ³•å¦‚ä¸‹ï¼š\n1 2 3 4 5 \u003cul\u003e \u003cli v-for=\"todo in todos\" :key=\"todo.id\"\u003e {{ todo.text }} \u003c/li\u003e \u003c/ul\u003e å…¶ä¸­ï¼Œtodosæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œv-forä¼šéå†è¿™ä¸ªåˆ—è¡¨ï¼Œç„¶åæŠŠå½“å‰çš„å€¼å‘½åä¸ºtodoï¼Œtodoè¿™ä¸ªå˜é‡åªèƒ½åœ¨v-forå…ƒç´ å†…éƒ¨ä½¿ç”¨ã€‚åŒæ—¶ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬ä½¿ç”¨äº†:key=\"todo.id\"ç»™æ¯ä¸ªtodoå˜é‡åˆ†é…äº†ä¸€ä¸ªidï¼Œå¹¶ä¸”ç»‘å®šåˆ°äº†keyä¸Šé¢ã€‚è¿™ä¸ªkeyæ˜¯Vueä¸­ä¸€ä¸ªç‰¹æ®Šçš„å±æ€§ï¼Œå¯ä»¥è®©åˆ—è¡¨è‡ªåŠ¨æ¸²æŸ“åˆ°å¯¹åº”ä½ç½®ï¼Œå¯ä»¥å‚è€ƒè¿™é‡Œï¼šhttps://staging-cn.vuejs.org/api/built-in-special-attributes.html#keyã€‚\nè®¡ç®—å±æ€§ å½“æˆ‘ä»¬éœ€è¦å±•ç¤ºçš„æŸäº›å€¼/å±æ€§éœ€è¦è®¡ç®—ä¹‹åæ‰èƒ½å¾—åˆ°ç»“æœæ—¶ï¼Œå¯ä»¥ä½¿ç”¨computed()æ¥å®Œæˆå¯¹åº”çš„è®¡ç®—ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªæ›´åŠ å¤æ‚çš„todoä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u003cscript setup\u003e import { ref, computed } from 'vue' let id = 0 const newTodo = ref('') const hideCompleted = ref(false) const todos = ref([ { id: id++, text: 'Learn HTML', done: true }, { id: id++, text: 'Learn JavaScript', done: true }, { id: id++, text: 'Learn Vue', done: false } ]) const filteredTodos = computed(() =\u003e { return hideCompleted.value ? todos.value.filter((t) =\u003e !t.done) : todos.value }) function addTodo() { todos.value.push({ id: id++, text: newTodo.value, done: false }) newTodo.value = '' } function removeTodo(todo) { todos.value = todos.value.filter((t) =\u003e t !== todo) } \u003c/script\u003e \u003ctemplate\u003e \u003cinput v-model=\"newTodo\" @keyup.enter=\"addTodo\"\u003e \u003cbutton @click=\"addTodo\"\u003eAdd Todo\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"todo in filteredTodos\" :key=\"todo.id\"\u003e \u003cinput type=\"checkbox\" v-model=\"todo.done\"\u003e \u003cspan :class=\"{ done: todo.done }\"\u003e{{ todo.text }}\u003c/span\u003e \u003cbutton @click=\"removeTodo(todo)\"\u003eX\u003c/button\u003e \u003c/li\u003e \u003c/ul\u003e \u003cbutton @click=\"hideCompleted = !hideCompleted\"\u003e {{ hideCompleted ? 'Show all' : 'Hide completed' }} \u003c/button\u003e \u003c/template\u003e \u003cstyle\u003e .done { text-decoration: line-through; } \u003c/style\u003e åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ç»™æ¯ä¸ªtodoåˆ†é…ä¸€ä¸ªdoneå­—æ®µï¼Œä»£è¡¨æ˜¯å¦å®Œæˆï¼›è¿˜å£°æ˜äº†ä¸€ä¸ªhideCompletedå˜é‡ï¼Œå½“è¿™ä¸ªå˜é‡ä¸ºtrueçš„æ—¶å€™ï¼Œéšè—å·²ç»å®Œæˆçš„todoã€‚è¿™æ ·çš„è¯ï¼Œåœ¨æ¯ä¸€æ¬¡ç‚¹å‡»hideCompletedæŒ‰é’®çš„æ—¶å€™ï¼Œcomputed()éƒ½ä¼šæ ¹æ®å½“å‰çš„æ‰€æœ‰todoï¼ˆå³ä»£ç ä¸­çš„todosï¼‰è®¡ç®—å‡ºæ¥filteredTodosï¼Œç„¶åæ˜¾ç¤ºã€‚\ncomputed()ä¼šè‡ªåŠ¨åœ°è¿½è¸ªè¾“å…¥çš„çŠ¶æ€ï¼Œå¹¶ä¸”åœ¨çŠ¶æ€æœ‰æ”¹å˜çš„æ—¶å€™è‡ªåŠ¨åœ°æ›´æ–°è¾“å‡ºï¼ˆå³filteredTodosï¼‰ã€‚\næ¨¡æ¿ref ä¸Šé¢æˆ‘ä»¬ä»‹ç»äº†åœ¨Vueä¸­å¸¸ç”¨çš„ä¸€äº›è¯­æ³•ï¼Œå½“ç„¶åœ¨å¿…è¦çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰‹åŠ¨åœ°å»æ“ä½œDOMã€‚åœ¨HTMLä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ref=\"p\"æ¥å£°æ˜ä¸€ä¸ªDOMå¯¹åº”çš„refã€‚åœ¨\u003cscript setup\u003eä¸­ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦é¦–å…ˆæ¥å£°æ˜å¯¹åº”çš„refå˜é‡ï¼š\n1 const p = ref(null) æ³¨æ„ï¼Œæ­¤æ—¶æˆ‘ä»¬ä½¿ç”¨nullæ¥å£°æ˜è¿™ä¸ªå˜é‡ï¼Œè¿™æ˜¯å› ä¸ºåœ¨\u003cscript setup\u003eä¸­è¿™ä¸ªDOMå…ƒç´ è¿˜æ²¡æœ‰è¢«æŒ‚è½½ã€‚åªæœ‰å½“è¿™ä¸ªç»„ä»¶è¢«æŒ‚è½½ä¹‹åï¼Œæˆ‘ä»¬æ‰èƒ½å¤Ÿåœ¨ä»£ç é‡Œé¢è·å–åˆ°å¯¹åº”çš„å¯¹è±¡ã€‚è¿™é‡Œå°±æ¶‰åŠåˆ°äº†ç”Ÿå‘½å‘¨æœŸï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªonMountedé’©å­ï¼Œå°±å¯ä»¥åœ¨ç»„ä»¶è¢«åŠ è½½ä¹‹åè‡ªåŠ¨æ‰§è¡Œï¼Œå¹¶ä¸”è·å–åˆ°å¯¹åº”çš„æ¨¡æ¿refï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003cscript setup\u003e import { ref, onMounted } from 'vue' const p = ref(null) onMounted(() =\u003e { p.value.textContent = 'mounted!' }) \u003c/script\u003e \u003ctemplate\u003e \u003cp ref=\"p\"\u003ehello\u003c/p\u003e \u003c/template\u003e è¿™æ ·ï¼Œåœ¨ç»„ä»¶åŠ è½½ä¹‹åå°±å¯ä»¥åœ¨ä»£ç ä¸­è·å–åˆ°å…¶å¼•ç”¨ï¼Œå¹¶ä¸”è‡ªåŠ¨åœ°æŠŠæ–‡æœ¬æ¢æˆ\"mounted!\"\nç›‘å¬å™¨ ç›‘å¬å™¨é¡¾åæ€ä¹‰å°±æ˜¯ç›‘å¬æŸä¸ªrefï¼Œåœ¨å®ƒæœ‰å˜åŒ–çš„æ—¶å€™å®ŒæˆæŸäº›äº‹ä»¶ã€‚åœ¨Vueä¸­ï¼Œå¯ä»¥ä½¿ç”¨watch()æ¥ç›‘å¬æŸä¸ªrefï¼š\n1 2 3 4 5 6 7 8 import { ref, watch } from 'vue' const count = ref(0) watch(count, (newCount) =\u003e { // æ¯å½“countå˜åŒ–ï¼Œåœ¨æ§åˆ¶å°ä¸­æ‰“æ—¥å¿— console.log(`new count is: ${newCount}`) }) ç»„ä»¶Component åœ¨çœŸå®çš„ä»£ç ä¸­ï¼Œæ¯ä¸ªåº”ç”¨éƒ½æ˜¯å¤šå±‚ç»„ä»¶åµŒå¥—è€Œæˆçš„ã€‚æˆ‘ä»¬å¯ä»¥ä»å…¶ä»–.vueæ–‡ä»¶ä¸­å¯¼å…¥ç»„ä»¶ï¼Œå¹¶ä¸”ç›´æ¥ä½¿ç”¨ï¼š\n1 2 3 4 5 6 7 \u003cscript setup\u003e import ChildComp from './ChildComp.vue' \u003c/script\u003e \u003ctemplate\u003e \u003cChildComp /\u003e \u003c/template\u003e ç»„ä»¶çš„props ç»„ä»¶å¯ä»¥å£°æ˜propså±æ€§ï¼Œç„¶ååœ¨çˆ¶ç»„ä»¶ä½¿ç”¨çš„æ—¶å€™ï¼Œå°±å¯ä»¥ä¼ å…¥å¯¹åº”çš„propsä½œä¸ºè¾“å…¥ã€‚\né¦–å…ˆï¼Œåœ¨å®šä¹‰ç»„ä»¶çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨definePropså£°æ˜å…¶æ¥å—çš„propsï¼š\n1 2 3 4 5 6 \u003c!-- ChildComp.vue --\u003e \u003cscript setup\u003e const props = defineProps({ msg: String }) \u003c/script\u003e definePropsæ— éœ€å¯¼å…¥ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚åœ¨å®šä¹‰å®Œæˆä¹‹åï¼Œå…¶çˆ¶ç»„ä»¶å°±å¯ä»¥å‘ä½¿ç”¨Attributesä¸€æ ·ä½¿ç”¨å­ç»„ä»¶å®šä¹‰çš„propsï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨v-bindæ¥ç»‘å®šä¸€ä¸ªå˜é‡å€¼ï¼š\n1 \u003cChildComp :msg=\"greeting\" /\u003e Emits é™¤äº†propsä¹‹å¤–ï¼Œå­ç»„ä»¶å¯ä»¥å‘çˆ¶ç»„ä»¶å‘é€äº‹ä»¶ï¼Œç„¶ååœ¨çˆ¶ç»„ä»¶ä¸­ä½¿ç”¨v-onç›‘å¬ã€‚å’Œpropsç±»ä¼¼ï¼Œemitséœ€è¦ä½¿ç”¨defineEmitså®šä¹‰ï¼Œä¸”æ— éœ€å¯¼å…¥ï¼š\n1 2 3 4 5 \u003cscript setup\u003e const emit = defineEmits(['response']) emit('response', 'hello from child') \u003c/script\u003e è¿™æ ·ï¼Œåœ¨çˆ¶ç»„ä»¶ä¸­å°±å¯ä»¥ä½¿ç”¨v-onæ¥ç›‘å¬responseäº‹ä»¶äº†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 \u003cscript setup\u003e import { ref } from 'vue' import ChildComp from './ChildComp.vue' const childMsg = ref('No child msg yet') \u003c/script\u003e \u003ctemplate\u003e \u003cChildComp @response=\"(msg) =\u003e childMsg = msg\" /\u003e \u003cp\u003e{{ childMsg }}\u003c/p\u003e \u003c/template\u003e ä¼ é€’slots é™¤äº†é€šè¿‡propsçš„å½¢å¼ä¹‹å¤–ï¼Œçˆ¶ç»„ä»¶è¿˜å¯ä»¥é€šè¿‡slotçš„å½¢å¼æ¥å‘å­ç»„ä»¶ä¼ é€’æ•°æ®ï¼š\n1 2 3 \u003cChildComp\u003e è¿™é‡Œæ˜¯slot \u003c/ChildComp\u003e è¿™å°±è®©çˆ¶ç»„ä»¶å¯ä»¥ç»™å­ç»„ä»¶ä¼ é€’\u003ctemplate\u003eæ•°æ®äº†ã€‚åœ¨å­ç»„ä»¶ä¸­ï¼Œä¹Ÿå¯ä»¥åœ¨å¯¹åº”çš„ä½ç½®å£°æ˜\u003cslot\u003eï¼Œä½œä¸ºé»˜è®¤å€¼ï¼š\n1 2 3 \u003ctemplate\u003e \u003cslot\u003eFallback content\u003c/slot\u003e \u003c/template\u003e ç„¶åå½“çˆ¶ç»„ä»¶ä»€ä¹ˆéƒ½ä¸ä¼ çš„æ—¶å€™ï¼Œå°±ä¼šé»˜è®¤åœ°æ˜¾ç¤ºFallback contentã€‚è€Œåœ¨çˆ¶ç»„ä»¶ä¼ é€’æ•°æ®çš„æ—¶å€™ï¼Œå¯¹åº”çš„ä½ç½®ä¼šæ˜¾ç¤ºæ•°æ®ï¼š\n1 2 3 4 5 6 7 8 9 10 \u003cscript setup\u003e import { ref } from 'vue' import ChildComp from './ChildComp.vue' const msg = ref('from parent') \u003c/script\u003e \u003ctemplate\u003e \u003cChildComp\u003e{{msg}}\u003c/ChildComp\u003e \u003c/template\u003e æ­¤æ—¶ï¼Œå­ç»„ä»¶è¿™ä¸ªåœ°æ–¹ä¼šæ˜¾ç¤ºçˆ¶ç»„ä»¶é‡Œçš„msgå†…å®¹ï¼Œè€Œä¸æ˜¯Fallback contentã€‚\nMore æ›´å¤šçš„Vueç»„ä»¶åŸºç¡€ï¼Œå¯ä»¥å‚è€ƒï¼šhttps://staging-cn.vuejs.org/guide/essentials/component-basics.html#components-basics\n","description":"","tags":["frontend"],"title":"Basics of Vue","uri":"/posts/engineering/vue/"},{"categories":null,"content":"Tree sitter - advanced parsing What makes tree-sitter powerful is not only its parsing performance. Incrementally parsing, multi-language document support and pattern matching are also great features of tree-sitter. In this article, I'll introduce you those advanced features of tree-sitter.\nIncrementally parsing One of tree-sitter's main design goal is to support incrementally parsing. Update an existing parse tree in tree-sitter is easy and fast - all you need to do is pass the edit range to the tree and re-parse it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Take JSON example in last article as our start let mut parser: Parser = Parser::new(); parser.set_language(tree_sitter_json::language()).unwrap(); let source_code = \"[1, null]\"; let mut old_tree: Tree = parser.parse(source_code, None).unwrap(); // If the JSON code is changed from \"[1, null]\" to \"[1, 2, null]\" let new_source_code = \"[1, 2, null]\"; // First, we need to pass the edit to old_tree // Note the edit range must be defined let edit = InputEdit { start_byte: 3, old_end_byte: 3, new_end_byte: 4, start_position: Point::new(0, 3), old_end_position: Point::new(0,3), new_end_position: Point::new(0,4), }; old_tree.edit(\u0026edit); // Then, re-parse the tree using new code // Pass the old tree so that tree-sitter can do incrementally parsing based on the edit and old_tree let new_tree = parser.parse(new_source_code, Some(\u0026old_tree)).unwrap(); If you have stored some tree nodes before updating the tree, those tree nodes should also be updated. Otherwise, you have to re-fetch those nodes again from the new parse tree. You can use node.edit() to update tree nodes:\n1 node.edit(\u0026edit); Note that this function is only needed in the case that you have the node object before editing the tree, and the node will be used after editing the tree.\nMulti-language Document A single source code file may contains different languages, such as jsx/tsx file, which contains JavaScript and React/Html code. Tree-sitter supports this kind of document by support parsing a certain range of a file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let source_code = \"1234[1, null]123\"; let r = Range { start_byte: 4, end_byte: 13, start_point: Point::new(0, 4), end_point: Point::new(0, 13), }; // Set parsed range match parser.set_included_ranges(\u0026[r]) { Ok(_) =\u003e {}, Err(e) =\u003e println!(\"{}\", e.to_string()), } // Parse \"[1, null]\" in \"1234[1, null]123\" only let tree = parser.parse(source_code, None).unwrap(); Concurrency Tree-sitter's parse tree supports concurrent accessing, but you have to use tree.clone() to get a copy of the tree. This operation is cheap because it just increase an atomic reference count by 1 internally.\nWalking Trees If you want to traverse the whole parse tree, a tree cursor can be used to walk the syntax tree with maximum efficiency. As the first step, you can initialize a tree cursor from any tree-sitter node:\n1 let cursor = node.walk(); Then you can move the cursor using goto_xxx functions. Those functions returns true if the cursor has been successfully moved to the target node.\n1 2 3 let success = cursor.goto_first_child(); let success = cursor.goto_parent(); let success = cursor.goto_next_sibling(); You can also get the current node, current node's field name and current node's field id using cursor:\n1 2 3 4 // The cursor is always binded to a valid node, so `unwrap()` is not needed when using `cursor.node()` let current_node = cursor.node(); let field_name = cursor.field_name().unwrap(); let field_id = cursor.field_id().unwrap(); Pattern Matching Tree-sitter also provides an approach to search for patterns in a parse tree, which is quite useful for many code analysis tasks.\nQuery Syntax Searching in the parse tree needs a query. In tree-sitter, a query consists of one or more patterns, and each pattern is a S-expression.\nA tree-sitter query in S-expression has two elements in a pair of parentheses. The first is the node's type and the second is a list of other S-expressions which represent the node's children. Here is a query in our JSON example:\n(array (number) (null)) The children can be omitted, the following query matches any array with at least one number child:\n(array (number)) Fields In you want to match a pattern more specifically, you can specify the name of a child node. Here is an example:\n(array left: (number)) This query matches an array which has a number child node named \"left\".\nAlso, you can use ! before a child to constrain that the node does NOT have this child:\n(array left: (!number)) This query matches an array which does NOT have a number child named \"left\".\nAnonymous Nodes The above queries matches only named nodes. To matching anonymous nodes, you can write their name between double quotes:\n(binary_expression operator: \"!=\" right: (null)) In this case, the query matches a binary_expression where the operator is \"!=\" and the child \"right\" is a null node.\nCapturing node Sometimes, you may want to use a specific matched node in a query. You can associate a name using @ character just after that node:\n(array left: (number) @my-number) This query would associate a name \"my-number\" to the number child.\nQuantification Operators Just like regular expression, you can use + and * to represent the repeated sequence of nodes, where + matches one or more repetitions and * matches zero or more repetitions. Here are several examples:\n(class_declaration (decorator)* @the-decorator name: (identifier) @the-name) In this example, the query matches a class_declaration which has zeros or more decorator. All matched decorator and their names are captured.\nMoreover, you can use ? to represent an optional node. The usage is just like + and *:\n(call_expression function: (identifier) @the-function arguments: (arguments (string)? @the-string-arg)) Grouping Sibling Nodes A pair of parentheses () is used to group sibling nodes. Those groups can be marked as repeated or optional using quantification operators *, + and ? introduced in the last section.\n( (number) (\",\" (number))* ) This query matches a comma-separated number sequence.\nAlternations A pair of square brackets [] is used to mark alternative nodes or patterns. This is also similar with regular expression:\n[ \"break\" \"delete\" \"else\" \"for\" \"function\" \"if\" \"return\" \"try\" \"while\" ] @keyword This example matches any of those words and captures it as @keyword.\nWildcard Node In tree-sitter, a wildcard node is represented using _. It matches any nodes(named nodes or anonymous nodes), while (_) matches only named nodes:\n(call (_) @call.inner) This example matches any named nodes in call and captures them as call.inner.\nAnchors . is the anchor operator which is used to constrain matched child patterns. The constrains of an anchor operator only affect named nodes. There are three cases to use anchor operator .:\n. is placed before the first child In this case, the child pattern matches only the first matched child node. For example, if we want to match an array and its first identifier child, this query is good: (array . (identifier) @the-first-identifier) Without using ., this pattern would matches every child identifier and bind the name to all matched children. . is placed after the last child In this case, the child pattern matches the last matched child node, here is a similar example: (array (identifier) @the-last-identifier .) This query matches an array and its last identifier child, binds the name to the last identifier. . is placed between two child patterns If the anchor operator is placed between two nodes, the pattern would matches those two nodes when they are immediate siblings: (dotted_name (identifier) @prev-id . (identifier) @next-id) In this example, the query matches a dotted_name with two consecutive identifiers. That is, if the sequence is a.b.c.d, only a.b, b.c and c.d would be matched. Without the anchor operator ., a.c, a.d and b.d would also be matched. Predicates Predicate S-expression in tree-sitter can be used to represent any metadata or conditions associated with a pattern. It records information and passes the information to the higher level code to perform filtering.\nSome higher-level bindings such as Rust binding has implemented several predicates, like #eq? and #match?.\nA predicate S-expression starts with a predicate name prefixed by #. After the name, you can put @-prefixed names or strings as you want.\nFor example, the following pattern matches identifier whose names is written in SCREAMING_SNAKE_CASE:\n( (identifier) @constant (#match? @constant \"^[A-Z][A-Z_]+\") ) In this example, #match? is the predicate name, @constant and \"^[A-Z][A-Z_]+\" is the following parameters. Tree-sitter's Rust binding has implemented #match? predicate, which accepts two parameters and returns whether the two parameters are matched.\nHere is another example:\n( (pair key: (property_identifier) @key-name value: (identifier) @value-name) (#eq? @key-name @value-name) ) This example matches a key-value pair that the key and value identifiers have the same name.\nThe Query API We've introduced the query syntax in tree-sitter, in this section, we'll introduce how to use query API in Rust.\nCreate a query You can create a new query using Query::new(language, source_str):\n1 2 3 use tree_sitter::Query; let query = Query::new(tree_sitter_json::language(), \"(array (number))\").unwrap(); If there's an error in the query, Query::new() would return a QueryError, which indicates the position and the type of the error in the query string.\nExecute the query To execute the query, you need to create a QueryCursor. QueryCursor carries state and information of an execution of a query, so it cannot be shared between threads, while the Query is thread-safe. Note that even though you cannot use QueryCursor between many threads, you can reuse it a lot of times for many query executions in one thread. Here is an example about how to use QueryCursor to execute a given Query on a syntax node:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Initialize a query which matches an array with a number child as matched-array let query = Query::new(tree_sitter_json::language(), \"(array (number))@matched-array\").unwrap(); // Initialize a query cursor let mut cursor = QueryCursor::new(); // Match the source code let source_code = \"[1, 2, 3]\"; let parse_tree: Tree = parser.parse(source_code, None).unwrap(); let mut root_node = parse_tree.root_node(); let matches = cursor.matches(\u0026query, root_node, source_code.as_bytes()); // Print out all matches matches.for_each(|m| { println!(\"Match: {:?}\", m); }); // You can also use QueryCursor::captures if you don't care about which pattern is matched let captures = cursor.captures(\u0026query, root_node, source_code.as_bytes()); captures.for_each(|c| { println!(\"Capture: {:?}\", c); }); The output is:\nMatch: QueryMatch { id: 0, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 0 }] } Capture: (QueryMatch { id: 0, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 0 }] }, 0) Note that you have to name the matched node(@matched-array in this example), otherwise you'll get nothing matched. You could also name a lot of node which need to be matched, and then you'll get many matches with many captures. If we add @number in the query above: let query = Query::new(tree_sitter_json::language(), \"(array (number)@number )@matched-array\").unwrap();, we'll get\nMatch: QueryMatch { id: 0, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 1) - (0, 2)}, index: 0 }] } Match: QueryMatch { id: 1, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 4) - (0, 5)}, index: 0 }] } Match: QueryMatch { id: 2, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 7) - (0, 8)}, index: 0 }] } Capture: (QueryMatch { id: 0, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 1) - (0, 2)}, index: 0 }] }, 0) Capture: (QueryMatch { id: 1, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 4) - (0, 5)}, index: 0 }] }, 0) Capture: (QueryMatch { id: 2, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 7) - (0, 8)}, index: 0 }] }, 0) Capture: (QueryMatch { id: 0, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 1) - (0, 2)}, index: 0 }] }, 1) Capture: (QueryMatch { id: 1, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 4) - (0, 5)}, index: 0 }] }, 1) Capture: (QueryMatch { id: 2, pattern_index: 0, captures: [QueryCapture { node: {Node array (0, 0) - (0, 9)}, index: 1 }, QueryCapture { node: {Node number (0, 7) - (0, 8)}, index: 0 }] }, 1) In the matches case, there are THREE matched sequences, each matched sequence contains TWO matched node: @number and @matched-array. This is because we didn't specify the anchor, so even though the @matched-array in the three matches are same, the matched @numbers are different. That's why we have three different match results which all have same matched @matched-array -- the matching call returns all posibilities of matches.\nAs for QueryCaptures, we have SIX of them because we have THREE matched results and each matched result has TWO matched node. So some of the captures have same QueryMatchs -- they are actually the same QueryMatch instance, but each match result has more than one matched node. And the index of QueryCaptures indicates which one is the current capture.\nStatic Node Types For programming languages with static typing, tree-sitter provides type information about specific syntax node. The information is saved in a generated file node-types.json. In this file, there is an array of objects which stores all node types. Each array element describes a particular type of a syntax node:\nBasic info Every array element has two entries:\n\"type\": the node's type defined in the grammar. We can get it using node.kind(), we've introduced it here \"named\": a boolean variable which represents whether a node is named Internal nodes \"type\" and \"named\" fields define a syntax node. For syntax nodes which have children, we have more options to describe them -- \"fields\" or \"children\".\n\"fields\": an object that represents possible fields of a node. The key is the name of the field, and the value is the child type, which is describe blow \"children\": if a node doesn't have \"fields\", \"children\" is what we used to describe all possible named children A child type object describes a particular type of the child node, it's defined by the following fields:\n\"required\": a boolean variable which represents whether there is always at least one node of this type \"multiple\": a boolean variable which represents if multiple chilren can be this type \"types\": an array of possible node types of this child, each element of this array has two entries: \"type\" and \"named\", whose meaning is the same as what we described above Here are two examples of a node with \"fields\" and a node with \"children\":\nExample with fields:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"type\": \"method_definition\", \"named\": true, \"fields\": { \"body\": { \"multiple\": false, \"required\": true, \"types\": [{ \"type\": \"statement_block\", \"named\": true }] }, \"decorator\": { \"multiple\": true, \"required\": false, \"types\": [{ \"type\": \"decorator\", \"named\": true }] }, \"name\": { \"multiple\": false, \"required\": true, \"types\": [ { \"type\": \"computed_property_name\", \"named\": true }, { \"type\": \"property_identifier\", \"named\": true } ] }, \"parameters\": { \"multiple\": false, \"required\": true, \"types\": [{ \"type\": \"formal_parameters\", \"named\": true }] } } } In this example, we define a method_definition node which has four types of fields: body, decorator, name and parameters.\nExample with children:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \"type\": \"array\", \"named\": true, \"fields\": {}, \"children\": { \"multiple\": true, \"required\": false, \"types\": [ { \"type\": \"_expression\", \"named\": true }, { \"type\": \"spread_element\", \"named\": true } ] } } Supertype nodes In tree-sitter's grammar for some languages, there exists some hidden rules which is used to generate \"supertypes list\" in node-types.json. We won't discuss how to create a grammar or define a parser, so we just introduce how we use \"supertypes\" in the node-types.json.\nIn node-types.json, some nodes have \"subtypes\" field, which specifies the types of nodes that current supertype node can wrap:\n1 2 3 4 5 6 7 8 9 10 11 { \"type\": \"_declaration\", \"named\": true, \"subtypes\": [ { \"type\": \"class_declaration\", \"named\": true }, { \"type\": \"function_declaration\", \"named\": true }, { \"type\": \"generator_function_declaration\", \"named\": true }, { \"type\": \"lexical_declaration\", \"named\": true }, { \"type\": \"variable_declaration\", \"named\": true } ] } As you can see in the example, type \"_declaration\" is defined as the parent of \"class_declaration\", \"funtion_declaration\", \"generator_function_declaration\", \"lexical_declaration\" and \"variable_declaration\".\nThe super type can be used in other types of nodes, which shortens the definition of other nodes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"type\": \"export_statement\", \"named\": true, \"fields\": { \"declaration\": { \"multiple\": false, \"required\": false, \"types\": [{ \"type\": \"_declaration\", \"named\": true }] }, \"source\": { \"multiple\": false, \"required\": false, \"types\": [{ \"type\": \"string\", \"named\": true }] } } } ","description":"","tags":["rust","parsing"],"title":"Tree sitter - advanced parsing","uri":"/posts/code-intelligence/tree-sitter-advanced/"},{"categories":null,"content":"Tree sitter What's tree-sitter? Generally speaking, tree-sitter is a parser generator tool, which creates parsers for programming languages and parses source code to parse tree. Tree-sitter also provides incrementally parsing feature, making updating of parse tree efficient.\nTree-sitter aims to be\nGeneral Fast Robust Dependency-free At the moment(2022/01/23), tree-sitter has been used in many famous projects, such as Neovim, GitHub Code Search, etc.\nLanguage bindings Tree-sitter runtime is written in pure C, so it's easy to embed it to other languages. Tree-sitter provides many language bindings, you can find a list here: https://tree-sitter.github.io/tree-sitter/#language-bindings.\nIn this article, We'll use Rust bindings of tree-sitter. If you don't use Rust, don't worry! Other language bindings of tree-sitter should be similar to use.\nUsing Tree-Sitter Parsers in Rust The Rust bindings of tree-sitter can be found here. You can see all API docs at https://docs.rs/tree-sitter/latest/tree_sitter/.\nThe official document also has introductiosn of tree-sitter's raw C API. If you want to use tree-sitter in other languages, C API is a good start to learn.\nGetting Started To use tree-sitter's Rust API, you should add tree-sitter dependency to your Cargo.toml first:\n1 tree-sitter = \"0.20.3\" You can also build tree-sitter from source, see: https://tree-sitter.github.io/tree-sitter/using-parsers#building-the-library\nBasic Conceptions There are four basic conceptions in tree-sitter:\nlanguage: defines how to parse a particular language parser: generates syntax tree from source code syntax tree: is a tree representation of an entire source code file syntax node: is a single node in syntax tree In Rust's API, they are called:\nlanguage -\u003e Language parser -\u003e Parser syntax tree -\u003e Tree syntax node -\u003e Node An Example Here is an example in Rust that uses tree-sitter JSON parser. Because tree-sitter maintains parsers of most popular programming languages, we don't have to generate parsers for those languages again. Here is a list of available parsers for now.\nTo use tree-sitter's official JSON parser, just add tree-sitter-json crate to your Cargo.toml:\n1 tree-sitter-json = \"0.19.0\" The example code of parsing JSON:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 use tree_sitter::{Node, Parser, Tree}; fn main() { // Create a parser let mut parser: Parser = Parser::new(); // Set the parser's language (JSON in this case) parser.set_language(tree_sitter_json::language()).unwrap(); // Build a syntax tree based on source code stored in a string. let source_code = \"[1, null]\"; let parse_tree: Tree = parser.parse(source_code, None).unwrap(); // Get the root node of the syntax tree. let root_node: Node = parse_tree.root_node(); // Get some child nodes. let array_node: Node = root_node.named_child(0).unwrap(); let number_node: Node = array_node.named_child(0).unwrap(); // Check that the nodes have the expected types. assert_eq!(root_node.kind(), \"document\"); assert_eq!(array_node.kind(), \"array\"); assert_eq!(number_node.kind(), \"number\"); // Check that the nodes have the expected child counts. assert_eq!(root_node.child_count(), 1); assert_eq!(array_node.child_count(), 5); assert_eq!(array_node.named_child_count(), 2); assert_eq!(number_node.child_count(), 0); // Print the syntax tree as an S-expression. let s_expression = root_node.to_sexp(); println!(\"Syntax tree: {}\", s_expression); } Execute cargo run, you'll get the following output:\nSyntax tree: (document (array (number) (null))) The output is the S-expression of the JSON string input.\nThis program uses tree-sitter's Rust API and tree-sitter-json crate. If you don't want to add tree-sitter-json to your dependency list, there is a second approach: add cc to your `[build-dependency] and embed the parser at build stage by add the following code to your build script:\n1 2 3 // Cargo.toml [build-dependencies] cc=\"*\" 1 2 3 4 5 6 7 8 9 10 11 12 13 // build.rs use std::path::PathBuf; // Suppose that you have `tree-sitter-javascript` in your root directory fn main() { let dir: PathBuf = [\"tree-sitter-javascript\", \"src\"].iter().collect(); cc::Build::new() .include(\u0026dir) .file(dir.join(\"parser.c\")) .file(dir.join(\"scanner.c\")) .compile(\"tree-sitter-javascript\"); } Then, you can declare a language and set the language to your parser in your source code:\n1 2 3 4 extern \"C\" { fn tree_sitter_javascript() -\u003e Language; } let language = unsafe { tree_sitter_javascript() }; parser.set_language(language).unwrap(); The second approach to use tree-sitter is what's in tree-sitter's official document, but anyway, I prefer the first approach.\nBasic Parsing In the section above, we have an example to parse JSON string. In this section, I'll introduce more about basic parsing using tree-sitter.\nProviding the code In the example above, we simply provide source code to the parser. However, in many modern editors and IDEs, the code is stored as other data structures such as rope and piece table(VSCode uses it as TextBuffer!).\nTo support those custom data structures, tree-sitter also provides parse_with() method. With it, you can write your own function to read a chunk of text at a given byte_offset and position:\n1 2 3 4 5 6 7 8 9 10 11 12 use tree_sitter:Point; // call_back converts your own data structure at the byte_offset and position to the input of parser // call_back returns a slice of UTF8-encoded text starting at the given byte_offset and position fn call_back(byte_offset: usize, position: Point) -\u003e String { } fn main() { ... // Parse using user provided data let tree = parser.parse_with(\u0026mut call_back, Node).unwrap() } Syntax node Each node in the parse tree has a type, which is a string that defined in grammar:\n1 let node_type: \u0026str = node.kind(); You can also get all type definitions by\n1 2 3 4 use tree_sitter_json::NODE_TYPES; fn main () { println!(\"{}\", NODE_TYPES); } You can get the position of a syntax node in the form of range in bytes or row/column pair:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Position let start: Point = node.start_position(); let end: Point = node.end_position(); // Byte range use std::ops::Range; let byte_range: Range = node.byte_range(); // Get both use tree_sitter::Range; let range: Range = node.range(); let start_byte: usize = range.start_byte; let end_byte: usize = range.end_byte; let start_point: Point = range.start_point; let end_point: Point = range.end_point; Retrieving nodes Every parse tree has a root node:\n1 let root: Node = tree.root_node(); You can also access children, siblings and parent of a Node:\n1 2 3 4 5 6 7 8 9 10 11 // Get children for i in 0..node.child_count() { let child = node.child(i).unwrap(); } // Get parent let parent = node.parent().unwrap(); // Get siblings let next_sib = node.next_sibling().unwrap(); let prev_sib = node.prev_sibling().unwrap(); All those functions returns Option\u003cNode\u003e. The returned value id None means the required node is not exist. For example, the parent of a root_node is always None:\n1 2 // None let null_node = root_node.parent(); Named nodes The parse tree generated by tree-sitter is actually concrete syntax tree(CST), which contains all tokens in the source text. But in many cases, we don't need so much information. It's easier to do code analyze on an abstract syntax tree. An abstract syntax tree(AST) is also a parse tree, but has less information compared with a CST. Tree-sitter supports both use cases by using named nodes and anonymous nodes.\nNamed and anonymous nodes are defined in grammar. Here is an example:\nif_statement: ($) =\u003e seq(\"if\", \"(\", $._expression, \")\", $._statement); It's the definition of if_statement syntax node. This node has 5 children: the condition expression($._expression), the body expression($._statement), \"if\", \"(\" and \")\". In this case, the condition expression and the body expression are named nodes, because they have explicit names defined in the grammar. And \"if\", \"(\" and \")\" are anonymous nodes, because they are represented as raw string in the grammar.\nIn the tree-sitter's parse tree, you can check whether a node is a named node using node.is_named().\nWhen you traverse the tree, you can also use named variants of the describled methods above to ignore all anonymous nodes:\n1 2 3 let children_num = node.named_child_count(); let children = node.named_child(idx).unwrap(); let prev_sib = node.prev_named_sibling().unwrap(); Field To make the parse tree easier to analyze, tree-sitter supports field names of a syntax node in grammar. For example, you can use the field name to access children of a syntax node:\n1 let child = node.child_by_field_name(\"field_name\"); Field also has an unique id which you can use to access the child:\n1 let child = node.child_by_field_id(0); You can convert between the string field name and the field id using Language:\n1 2 3 4 5 6 7 // Get language let json_language = tree_sitter_json::language(); // Convert between field name and id let field_count = json_language.field_count(); let id = json_language.field_id_for_name(\"field_name\").unwrap(); let field = json_language.field_name_for_id(0).unwrap(); Similarly, node's type has an id as well and you can use Language to convert between them:\n1 2 3 4 5 6 7 8 // Convert between node type and id let node_type_count = json_language.node_kind_count(); let id = json_language.id_for_node_kind(\"array\", true).unwrap(); let node_type = json_language.node_kind_for_id(0).unwrap(); // Check node type's property let is_visible = json_language.node_kind_is_visible(); let is_named = json_language.node_kind_is_named(); That's all about tree-sitter basics In this article, we've covered most basic tree-sitter APIs. In the next articles, I'll introduce some advanced topic of tree-sitter, like incrementally parsing, pattern matching and grammar writting.\n","description":"","tags":["rust","parsing"],"title":"Tree sitter - basics","uri":"/posts/code-intelligence/tree-sitter/"},{"categories":null,"content":"Rust Build Scripts https://doc.rust-lang.org/cargo/reference/build-scripts.html\nWhat's Build Scripts in Rust Build scripts in Rust is used to integrate Rust code to external tools or dependecies such as C libraries, or execute tasks before compiling the Rust project. You can enable build scripts by placing a file named build.rs at the root of a Rust package. Cargo will compile and execute the build script before building the package.\nHere are some usages of build scripts according to the Cargo Book:\nBuilding a bundled C library. Finding a C library on the host system. Generating a Rust module from a specification. Performing any platform-specific configuration needed for the crate. The following sections will introduce the basics of build scripts in Rust.\nLife Cycle of Build Scripts Build scripts are compiled to an executable and executed before the package is built. It should return a zero exit code if there's no error. The rest of the package will be compiled after the build script finished. If any error occurs, a non-zero exit code should be returned by the build script to interrupt the build process.\nBy default, Cargo will rerun the build script if any file changes in the project. But you can also specify the watched files using rerune-if-changed command:\n1 println!(\"cargo:rerun-if-changed=wrapper.h\"); Inputs and Outputs of the Build Script All inputs of the build script are passed using environment variables. Here is the list of all available inputs for build scripts.\nAll output files of the build script should be saved in the directory specified in OUT_DIR environment variable. The script may commnunicate with Cargo by printing commands like cargo:xxx to stdout, all other lines will be ignored.\nHere is a list of all commands that Cargo accepts according to the Cargo Book:\ncargo:rerun-if-changed=PATH â€” Tells Cargo when to re-run the script. cargo:rerun-if-env-changed=VAR â€” Tells Cargo when to re-run the script. cargo:rustc-link-arg=FLAG â€“ Passes custom flags to a linker for benchmarks, binaries, cdylib crates, examples, and tests. cargo:rustc-link-arg-bin=BIN=FLAG â€“ Passes custom flags to a linker for the binary BIN. cargo:rustc-link-arg-bins=FLAG â€“ Passes custom flags to a linker for binaries. cargo:rustc-link-lib=[KIND=]NAME â€” Adds a library to link. cargo:rustc-link-search=[KIND=]PATH â€” Adds to the library search path. cargo:rustc-flags=FLAGS â€” Passes certain flags to the compiler. cargo:rustc-cfg=KEY[=\"VALUE\"] â€” Enables compile-time cfg settings. cargo:rustc-env=VAR=VALUE â€” Sets an environment variable. cargo:rustc-cdylib-link-arg=FLAG â€” Passes custom flags to a linker for cdylib crates. cargo:warning=MESSAGE â€” Displays a warning on the terminal. cargo:KEY=VALUE â€” Metadata, used by links scripts. Build Dependencies You can specify dependencies for build scripts using build-dependencies section in Cargo.toml:\n1 2 [build-dependencies] cc = \"1.0.46\" The build script cannot use dependencies or dev-dependencies in Cargo.toml.\nThe package.links Manifest Key The package.links manifest key is used to specify the native libraries that the package depends on. When using this key, the package must have a build script with the cargo:rustc-link-lib=[KIND=]=NAME command. With links key, Cargo knows about the native libraries that the package depends on. Also, metadata is passed as the output of build script in the KEY=VALUE format using links key(see cargo:KEY=VALUE command). This metadata is automatically converted to an environment variable for the dependent's build script.\n1 2 3 [package] # links to libonnxruntime links = \"onnxruntime\" By default, there is at most one package per links value to prevent conflict symbols.\n*-sys Packages In Rust's convention, any package that link to system libraries should have a -sys suffix. In our case, we generated onnxruntime-sys at ã€TODOã€‘. It's also common to have another package which wraps the -sys package, for example, onnxruntime, to provide safe and high-level APIs.\nOverriding the Build Script You can also override params in build script at Cargo configuration file. Here is an example:\n1 2 3 4 5 6 7 8 9 [target.x86_64-unknown-linux-gnu.foo] rustc-link-lib = [\"foo\"] rustc-link-search = [\"/path/to/foo\"] rustc-flags = \"-L /some/path\" rustc-cfg = ['key=\"value\"'] rustc-env = {key = \"value\"} rustc-cdylib-link-arg = [\"â€¦\"] metadata_key1 = \"value\" metadata_key2 = \"value\" In this case, if a package links to foo, then it's build script will not be executed. Instead, the medata specified in Cargo configuration file will be used.\nLearn Build Script from Examples The Cargo book provides a complete example of how to write build scripts.\n","description":"","tags":["rust"],"title":"Rust Build Scripts","uri":"/posts/engineering/rust-build-scripts/"},{"categories":null,"content":"Rust bindgen What's bindgen? bindgen is a tool which generates Rust FFI to C/C++ libraries automatically. It's quite useful when we want to use a C/C++ library in Rust. For example, PyTorch provides C library for users which don't want to use Python. With bindgen, we can quickly create Rust binding of PyTorch C library from C header(see tch-rs)\nUse bindgen The recommended way to use bindgen is using it in build.rs. build.rs is a Rust file placed in the root of a package which is used to integrate third-party libraries or user customized tools to Rust compiling process. Cargo will compile and execute build.rs first and then build the package.\nBecause many C/C++ headers have platform-specfic features, with using bindgen inside build.rs, we can generate bindings for the current target on-the-fly. Other users can also use your package by generating bindings for their platform.\nIn the following sections, we will take onnxruntime C library as an example, generate Rust bindings using bindgen.\nAdd bindgen as a build dependency First, we have to add bindgen as the build dependency. A build dependency is the dependency which is only used in building(see this section in The Cargo Book).\n1 2 [build-dependencies] bindgen = \"0.59.1\" Create a wrapper.h Header Because some libraries have more than one headers, we can include those headers in wrapper.h and take wrapper.h as an entrypoint for bindgen.\nIn our example, onnxruntime's header file can be found at https://github.com/microsoft/onnxruntime/blob/master/include/onnxruntime/core/session/onnxruntime_c_api.h. So we can just download it and then use it in build.rs.\nCreate build.rs file Create build.rs at the project root, Cargo will automatically compile and execute it before compiling the rest of the project.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 extern crate bindgen; use std::env; use std::path::PathBuf; fn main() { // Tell cargo to invalidate the built crate whenever the wrapper changes println!(\"cargo:rerun-if-changed=onnxruntime_c_api.h\"); // The bindgen::Builder is the main entry point // to bindgen, and lets you build up options for // the resulting bindings. let bindings = bindgen::Builder::default() // The input header we would like to generate // bindings for. .header(\"onnxruntime_c_api.h\") // Tell cargo to invalidate the built crate whenever any of the // included header files changed. .parse_callbacks(Box::new(bindgen::CargoCallbacks)) // Finish the builder and generate the bindings. .generate() // Unwrap the Result and panic on failure. .expect(\"Unable to generate bindings\"); // Write the bindings to the src/bindings/[os]/[arch]/bindings.rs file. let out_path = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap()) .join(\"src\") .join(\"bindings\") .join(env::var(\"CARGO_CFG_TARGET_OS\").unwrap()) .join(env::var(\"CARGO_CFG_TARGET_ARCH\").unwrap()); // If the directory doesn't exist, create it fs::create_dir_all(\u0026out_path).expect(\"Unable to create dir\"); // Write bindings to file bindings .write_to_file(out_path.join(\"bindings.rs\")) .expect(\"Couldn't write bindings!\"); } Run cargo build, and then the bindings to onnxruntime are generated, you can find it at src/bindings/[os]/[arch]/bindings.rs.\nUse generated bindings include! macro can be used to dump the generated bindings into crate's main entry point.We can add different cfg headers for bindings of different platforms.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #![allow(non_upper_case_globals)] #![allow(non_camel_case_types)] #![allow(non_snake_case)] #[cfg(all(target_os = \"windows\", target_arch = \"x86_64\"))] include!(concat!( env!(\"CARGO_MANIFEST_DIR\"), \"/src/bindings/windows/x86_64/bindings.rs\" )); #[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))] include!(concat!( env!(\"CARGO_MANIFEST_DIR\"), \"/src/bindings/macos/x86_64/bindings.rs\" )); Because onnxruntime's symbols are defined in C, they may not follow Rust's style convention. We can suppress warnings by a bunch of #![allow(...)] pragmas.\nTest bindings The generated code contains some tests. We can also add our test at src/lib.rs:\n1 2 3 4 5 6 7 8 #[cfg(test)] mod tests { use super::*; #[test] fn it_works() { assert_eq!(8, ORT_API_VERSION); } } Run cargo test, cargo will execute all tests defined in bindings.rs and lib.rs.\ntest bindgen_test_layout_wait__bindgen_ty_2 ... ok test tests::it_works ... ok test bindgen_test_layout_wait__bindgen_ty_1 ... ok test result: ok. 81 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s So far, we have successfully generated bindings for onnxruntime and tested them. With bindgen, we can also customize the generated bindings. For more options of bindgen, check https://rust-lang.github.io/rust-bindgen/customizing-generated-bindings.html.\nMore about build.rs We just generated bindings for onnxruntime. But that's not enough if we want to use it in production, especially when you want to deploy the application using the bindings to different platforms. This is where build.rs comes into play.\nAs we mentioned above, build.rs is compiled and executed before the package is compiled. So we can add somethings like platform-specific configuration, library downloading, etc. to build.rs. The full reference of build.rs is here.\n","description":"","tags":["rust"],"title":"Rust bindgen","uri":"/posts/engineering/rust-bindgen/"},{"categories":null,"content":"èƒŒæ™¯ åœ¨Transformerä¹‹å‰ï¼ŒNLPé¢†åŸŸçš„seq2seqæ¨¡å‹ä¸»è¦åŸºäºRNNç»“æ„ï¼Œå¦‚LSTMï¼ŒGRUç­‰ã€‚è¿™ç§ç»“æ„æœ‰å‡ ä¸ªéš¾ä»¥å…‹æœçš„ç¼ºç‚¹:\néš¾ä»¥å¹¶è¡ŒåŒ– é€Ÿåº¦æ…¢ é•¿è·ç¦»ä¾èµ–è®°å¿†ä¸å¤Ÿé•¿ Googleæå‡ºçš„åŸºäºself-attentionçš„Transformerå’ŒTransformer-XLç»“æ„å¯ä»¥å¾ˆå¥½åœ°è§£å†³RNNçš„ç¼ºç‚¹ï¼Œæ‰€ä»¥è‡ª2017å¹´ä»¥æ¥ï¼ŒTransformerå·²ç»æˆä¸ºäº†NLPé¢†åŸŸå¯¹è¯­è¨€å»ºæ¨¡çš„é»˜è®¤é€‰é¡¹ã€‚ Bertã€GPTã€XLNETç­‰æ¨¡å‹çš„åŸºç¡€å•ä½éƒ½æ˜¯Transformerã€‚\nOverview è®ºæ–‡é‡Œé¢çš„Transformeræ²¿ç”¨äº†ä¼ ç»Ÿçš„encoder-decoderç»“æ„ã€‚å…¶ä¸»è¦æ„é€ å•å…ƒä¸ºï¼š\nMulti-Head Attention layer Position-wise fully connected layer Positional encoding LayerNorm éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¯¹äºencoderå’Œdecoderï¼Œæ¯ä¸ªç»“æ„å¯ä»¥é‡å Næ¬¡ï¼Œåœ¨è®ºæ–‡é‡Œé¢N=6ï¼Œå³encoderå äº†Nå±‚ã€‚è¿™æ—¶ï¼Œdecoderçš„æ¯ä¸€å±‚æ‹¿åˆ°çš„K-Vçš„è¾“å…¥éƒ½æ˜¯encoderçš„æœ€åä¸€å±‚çš„ç»“æœ\nAttention Multi-Head Attentionæ˜¯Transformerä¸­æœ€é‡è¦çš„ä¸€éƒ¨åˆ†ã€‚\nScaled Dot-Product Attention Multi-head attentionçš„åŸºç¡€æ˜¯Scaled Dot-Product Attention, è¿™é‡Œï¼Œè¾“å…¥æœ‰ä¸‰ä¸ªï¼ŒQä»£è¡¨queryï¼ŒKã€Vä»£è¡¨ä¸€ä¸ªKey-Valueå¯¹ã€‚ç”¨å…¬å¼è¡¨ç¤ºä¸ºï¼š\n$$ Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})\\times V $$\næ‰€è°“self-attentionå®é™…ä¸Šå°±æ˜¯Qã€Kã€Vä¸‰ä¸ªæ˜¯ä¸€æ ·çš„ã€‚è¿™é‡Œçš„Qã€Kã€Véƒ½æ˜¯å¤šä¸ªå•è¯embeddingçš„çŸ©é˜µã€‚å¦‚æœå¥å­é•¿åº¦ä¸º128ä¸ªtokenï¼Œembeddingçš„é•¿åº¦$d_{model}=512$ï¼Œé‚£ä¹ˆå·¦è¾¹çš„softmaxè¾“å‡ºçš„å®é™…ä¸Šå°±æ˜¯128ä¸ªæƒé‡å‘é‡ï¼Œå’Œvalue embeddingç›¸ä¹˜å¾—åˆ°åŠ äº†self-attentionçš„ç»“æœã€‚\nå¯ä»¥ç®€å•ç†è§£ä¸ºï¼Œself-attentionæ˜¯é€šè¿‡Qå’ŒKç®—å‡ºæ³¨æ„åŠ›éœ€è¦æ”¾åˆ°å“ªäº›ç»´åº¦ä¸Šï¼Œå³æƒé‡å‘é‡ï¼Œç„¶åä¹˜Vå¾—åˆ°åŠ ä¸Šattentionä¹‹åçš„è¾“å‡ºã€‚\nMulti-Head Attention äº†è§£äº†Scaled Dot-Product Attentionä¹‹åï¼ŒMulti-Head Attentionå°±ç®€å•äº†ï¼šåœ¨è¾“å…¥çš„æ—¶å€™ï¼ŒæŠŠVã€Kã€Qéƒ½é‡å¤hæ¬¡ï¼Œè¿™ä¸ªhå°±æ˜¯headçš„æ•°ç›®ã€‚å½“ç„¶è¿™é‡Œä¸æ˜¯ç®€å•çš„å¤åˆ¶ï¼Œè€Œæ˜¯å¯¹Vã€Kã€Qåšçº¿æ€§å˜æ¢hæ¬¡ã€‚æ³¨æ„ï¼Œåœ¨çº¿æ€§å˜æ¢çš„æ—¶å€™ï¼Œéœ€è¦æŠŠè¾“å‡ºçš„ç»´åº¦å˜ä¸º$\\frac{d_{model}}{h}$ï¼Œè¿™æ ·çš„è¯åœ¨æœ€ç»ˆè¾“å‡ºconcatä¹‹åçš„ç»“æœçš„ç»´åº¦æ‰æ­£ç¡®ã€‚åŒæ—¶ï¼Œè¿™æ ·ä¹Ÿä¸ä¼šå¢åŠ è®¡ç®—æ¶ˆè€—ã€‚\nåœ¨æ¨¡å‹ä¸­ï¼Œé™¤äº†self-attentionä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªencoder-decoder attentionï¼ŒåŒºåˆ«å°±æ˜¯åœ¨encoder-decoder attentionä¸­ï¼ŒQå’ŒKå˜æˆäº†encoderçš„è¾“å‡ºã€‚Vè¿˜æ˜¯ä¸Šä¸€æ­¥decoderçš„è¾“å‡ºã€‚è¿™é‡Œå’Œä¼ ç»ŸRNNç»“æ„ä¸€æ ·ã€‚\nå®é™…ä¸Šï¼ŒTransformerçš„å¹¶è¡Œæ€§ä¸»è¦ä½“ç°åœ¨è®­ç»ƒä¸Šé¢ï¼Œåœ¨åšæ¨ç†çš„æ—¶å€™ï¼Œéœ€è¦å’Œä¼ ç»ŸRNNä¸€æ ·ï¼Œä¸€ä¸ªè¯ä¸€ä¸ªè¯åœ°é¢„æµ‹ï¼Œå¹¶ä¸”åœ¨é¢„æµ‹ä¸‹ä¸€ä¸ªè¯çš„æ—¶å€™éœ€è¦å½“å‰çš„è¾“å‡ºä½œä¸ºè¾“å…¥ã€‚\nPosition-wise Feed-Forward Layer è¿™ä¸€å±‚ç®€ç§°FFNï¼Œæ˜¯å¯¹æ¯ä¸€ä¸ªä½ç½®çš„ç»“æœå•ç‹¬è®­ç»ƒä¸€ä¸ªç½‘ç»œï¼Œä½ç½®å’Œä½ç½®ä¹‹é—´ä¸å…±äº«å‚æ•°ï¼Œå› æ­¤å«\"Position-wise\"ã€‚FFNçš„ç»“æ„ä¹Ÿå¾ˆç®€å•ï¼šä¸¤ä¸ªçº¿æ€§å˜æ¢ï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯ReLUï¼š $$ FFN(x) = max(0, xW_1+b_1)W_2+b_2 $$\nä¸­é—´å±‚çš„å®½åº¦æ˜¯è¶…å‚æ•°$d_{ff}$ï¼Œåœ¨è®ºæ–‡ä¸­å–å€¼ä¸º2048\nNorm Layer Transformerä¸­ï¼ŒAttentionå±‚å’ŒFFNå±‚åé¢éƒ½åŠ äº†ä¸€ä¸ªNormalizationï¼š\n$$ LayerNorm(x+Sublayer(x)) $$\nå…¶ä¸­ï¼ŒLayerNormçš„æ–¹æ³•è§Hintonçš„è®ºæ–‡ã€‚\nPositional Encoding ç”±äºself-attentionä¸­å¹¶æ²¡æœ‰ä¿å­˜ä½ç½®ç›¸å…³çš„ä¿¡æ¯ï¼Œå› æ­¤éœ€è¦åŠ Positional Encodingã€‚\nåœ¨Transformerè®ºæ–‡ä¸­ï¼Œä½œè€…æä¾›äº†ä¸¤ç§Positional Encodingï¼šç¬¬ä¸€ç§æ˜¯åŸºäºä¸‰è§’å‡½æ•°çš„ï¼Œç¬¬äºŒç§æ˜¯learned positional embeddingã€‚ç»è¿‡å®éªŒä¸¤è€…çš„ç»“æœå·®ä¸å¤šï¼Œæ‰€ä»¥ä½œè€…ä½¿ç”¨çš„åŸºäºä¸‰è§’å‡½æ•°çš„Positional Encodingã€‚è¿™é‡Œï¼Œiæ˜¯ç»´åº¦ï¼Œposæ˜¯tokençš„ä½ç½®ã€‚æ‰€ä»¥ï¼Œå¯¹äºæ¯ä¸ªç»´åº¦ï¼Œä½ç½®ç¼–ç çš„æ³¢é•¿éƒ½æ˜¯ä¸åŒçš„ã€‚è€Œå¯¹äºç›¸åŒçš„ç»´åº¦æ¥è¯´ï¼Œ $PE_{pos+k}$ æ€»æ˜¯å¯ä»¥è¡¨ç¤ºä¸º$PE_{pos}$çš„çº¿æ€§å‡½æ•°ã€‚\nTransformerçš„é—®é¢˜ è™½ç„¶åœ¨ç†è®ºä¸Šï¼ŒTransformeræ¥å—ä»»æ„é•¿çš„åºåˆ—è¿›è¡Œå¹¶è¡Œè®­ç»ƒã€‚ä½†æ˜¯ï¼Œåœ¨å®é™…è®­ç»ƒä¸­ï¼Œç”±äºGPUã€TPUå†…å­˜çš„é™åˆ¶ï¼Œä¸€èˆ¬çš„åšæ³•æ˜¯æŒ‡å®šä¸€ä¸ªå›ºå®šçš„ä¸Šä¸‹æ–‡é•¿åº¦ï¼Œç„¶åæŠŠè¾“å…¥åºåˆ—æŒ‰ç…§è¿™ä¸ªé•¿åº¦è¿›è¡Œåˆ‡åˆ†(segmentation)ï¼Œç„¶åæŠŠæ¯ä¸ªsegmentæ‰”åˆ°Transformeré‡Œé¢è¿›è¡Œè®­ç»ƒã€‚è¿™ç§è®­ç»ƒæ–¹å¼å¸¦æ¥äº†ä¸¤ä¸ªç¼ºç‚¹ï¼šç¬¬ä¸€ä¸ªæ˜¯æ— æ³•æ•æ‰è·¨segmentçš„é•¿è·ç¦»ä¾èµ–ï¼Œç¬¬äºŒä¸ªæ˜¯å›ºå®šé•¿åº¦åˆ‡åˆ†ä¼šæŠŠåŒä¸€ä¸ªè¯­ä¹‰å—ï¼ˆå¦‚ä¸€ä¸ªå¥å­ï¼‰åˆ‡åˆ†åˆ°ä¸åŒçš„segmenté‡Œé¢ï¼Œè¿™æ ·çš„è¯åœ¨é¢„æµ‹æ—¶ï¼Œç”±äºç¼ºä¹ä¸Šæ–‡ä¿¡æ¯å¯¹å‰å‡ ä¸ªå•è¯çš„é¢„æµ‹æ•ˆæœå¾ˆå·®ã€‚åœ¨è®­ç»ƒæ—¶ï¼Œä¹Ÿä¼šé™ä½æ”¶æ•›é€Ÿåº¦ã€‚\nåœ¨é¢„æµ‹æ—¶ï¼ŒTransformeråœ¨æ¯ä¸€æ­¥åªé¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯ï¼Œç„¶åå³ç§»ä¸€ä½å†é¢„æµ‹ã€‚åŒæ ·æ˜¯åªèƒ½æ‹¿åˆ°segmentå†…çš„ä¿¡æ¯ï¼Œä¸”å³ç§»ä¹‹åæ‰€æœ‰çš„é¢„æµ‹æ­¥éª¤éƒ½è¦èµ°ä¸€éï¼Œé€Ÿåº¦æ…¢ã€‚\nä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼ŒGoogleæå‡ºäº†Transformer-XL\nTransformer-XL Transformer-XLä¸»è¦æœ‰ä¸¤ä¸ªè´¡çŒ®ï¼š1. è§£å†³fixed-length contexté—®é¢˜ã€‚2.å¼•å…¥äº†ä¸€ç§æ–°çš„ä½ç½®ç¼–ç æ–¹å¼\nSegment-Level Recurrence with State Reuse Transformer-XLè§£å†³fixed-length contextçš„æ–¹å¼æ˜¯å¼•å…¥recurrentï¼šå¯¹äºæ¯ä¸ªsegmentï¼Œé‡ç”¨å…¶ä¹‹å‰çš„segmentçš„çŠ¶æ€å¼€å§‹è®­ç»ƒè€Œä¸æ˜¯ä»å¤´å¼€å§‹è®­ç»ƒã€‚\nè¿™é‡Œï¼Œ$h_{\\tau}^n$è¡¨ç¤ºç¬¬$\\tau$ä¸ªsegment $s_\\tau$ç”Ÿæˆçš„ç¬¬nä¸ªéšå±‚çŠ¶æ€åºåˆ—ã€‚æ‰€ä»¥è¿™é‡Œé¦–å…ˆæŠŠå‰é¢çš„segmentå’Œå½“å‰çš„segmentåšä¸€ä¸ªconcatï¼Œç„¶åå†ç”¨çº¿æ€§æ˜ å°„çš„æ–¹å¼ç”Ÿæˆæ–°çš„Qã€Kã€Væ‰”è¿›Transformerä¸­ã€‚\nåœ¨é¢„æµ‹æ—¶ä¹Ÿæ˜¯ç±»ä¼¼ï¼Œå¯ä»¥ç”¨åˆ°ä¹‹å‰æ‰€æœ‰çš„segmentçš„ä¿¡æ¯ã€‚ç”±äºæ‰€æœ‰çš„segmentçš„éšçŠ¶æ€éƒ½å¯ä»¥è¢«ç¼“å­˜ï¼Œæ‰€ä»¥ç›¸æ¯”Transformerï¼ŒTransformer-XLçš„é€Ÿåº¦å¯ä»¥æå‡1800+å€ã€‚\nRelative Positional Encoding åœ¨Transformer-XLä¸­ï¼Œç”±äºè¦å¯¹ä¸åŒçš„çª—å£è¿›è¡Œå¤„ç†ï¼Œå› æ­¤åœ¨åŸç‰ˆTransformerä¸­çš„åŸºäºä¸‰è§’å‡½æ•°çš„ç»å¯¹ä½ç½®ç¼–ç å°±ä¼šå‡ºç°é—®é¢˜ï¼šåŸæ¥çš„ç¼–ç åªå’Œç»´åº¦iå’Œtokençš„ä½ç½®posæœ‰å…³ç³»ï¼Œé‚£ä¹ˆåœ¨ä¸åŒçš„segmentä¸­ä¼šå‡ºç°ä¸€æ ·çš„ä½ç½®ç¼–ç ï¼ˆå³æœ‰ç›¸åŒçš„poså’Œiï¼‰ã€‚\nåŸæ¥çš„ç»å¯¹ä½ç½®ç¼–ç å…¬å¼ä¸­ï¼Œ$U_{1:L}$ æ˜¯ç»å¯¹ä½ç½®ç¼–ç ï¼Œ$E_{s_\\tau}$æ˜¯embeddingï¼Œ$h_\\tau$æ˜¯éšçŠ¶æ€\næ‰€ä»¥ï¼ŒTransformer-XLå¼•å…¥äº†ç›¸å¯¹ä½ç½®çŸ©é˜µï¼š\n$$ R_i \\in \\mathbb{R}^{L_{max}\\times d} $$\nè¿™é‡Œï¼Œiæ˜¯ä¸¤ä¸ªä½ç½®çš„ç›¸å¯¹è·ç¦»ï¼Œ$L_{max}$æ˜¯æ•´ä¸ªè¾“å…¥åºåˆ—çš„æœ€é•¿é•¿åº¦ï¼Œåœ¨å®é™…è®¡ç®—ä¸­ï¼Œiå¯ä»¥æ˜¯ä»0åˆ°M+L-1çš„ä»»ä½•æ•°å­—ï¼ŒMæ˜¯è®°å¿†çš„é•¿åº¦ï¼ŒLæ˜¯segmenté•¿åº¦ã€‚\nåœ¨å®é™…åº”ç”¨ä¸­ï¼ŒRæ˜¯å¯ä»¥è¢«æå‰è®¡ç®—å‡ºæ¥çš„ï¼Œä½¿ç”¨vanilla transformerä¸­çš„ä¸‰è§’å‡½æ•°å³å¯ã€‚\nä¸åŒäºvanilla Transformerä¸­å•çº¯åœ°æŠŠä½ç½®ç¼–ç å’ŒembeddingåŠ èµ·æ¥ï¼ŒTransformer-XLæ˜¯åœ¨è®¡ç®—attention scoreçš„æ—¶å€™åŠ¨æ€æ’å…¥ç›¸å¯¹ä½ç½®ç¼–ç \nè¿™ä¸ªå…¬å¼çŒ›ä¸€çœ‹ä¸å¥½ç†è§£ï¼Œå›æƒ³ä¸€ä¸‹åŸå§‹çš„attention scoreçš„è®¡ç®—æ–¹å¼ï¼š\n$$ Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})\\times V $$\nè€ƒè™‘è¿›æ¥åŸæ¥çš„ç»å¯¹ä½ç½®ç¼–ç Uå’Œçº¿æ€§å˜æ¢çŸ©é˜µWï¼Œæœ‰\n$$ QK^T=(E+U)W_q\\times ((K+U)W_k)^T $$\né‚£å¯¹äºç¬¬iä¸ªqueryå’Œç¬¬jä¸ªkeyæ¥è¯´ï¼Œæœ‰\nå¯¹æ¯”ä¸¤ä¸ªæ–¹æ¡ˆï¼Œå‘ç°åŒºåˆ«æœ‰3ç‚¹ï¼š\nä½¿ç”¨æå‰è®¡ç®—å¥½çš„ç›¸å¯¹ä½ç½®ç¼–ç $R_{i-j}$ä»£æ›¿ç»å¯¹ä½ç½®ç¼–ç $U_j$\nè¿™æ ·å°±åœ¨è®¡ç®—attention scoreçš„æ—¶å€™åŠ¨æ€å¼•å…¥äº†ç›¸å¯¹ä½ç½®ç¼–ç \nä½¿ç”¨å¯å­¦ä¹ çš„å‚æ•°$u,v$ä»£æ›¿$W_qU_i$\nåœ¨è€ƒè™‘ç›¸å¯¹ä½ç½®æ—¶ï¼Œæ¯”è¾ƒæ ‡å‡†æ˜¯ä½ç½®iï¼Œæ‰€ä»¥è¿™é‡Œçš„$U_i$æ˜¯å›ºå®šçš„($R_0$)ï¼Œå› æ­¤å¯¹äºä»»æ„çš„iï¼Œè¿™é‡Œéƒ½å¯ä»¥é‡‡ç”¨åŒæ ·çš„å‘é‡è¡¨ç¤ºã€‚å› æ­¤è¿™ä¸¤ä¸ªå‚æ•°å°±è¢«å½’ä¸€åŒ–æˆäº†å¯å­¦ä¹ çš„å‚æ•°$u,v$\nä½¿ç”¨$W_{k,E},W_{k,R}$ä»£æ›¿$W_k$ ä¹‹å‰ç”±äºæ˜¯$(E+U)W_k$ï¼Œå¯¹Eå’ŒUåšçš„æ˜¯åŒä¸€ä¸ªå˜æ¢ã€‚è¿™é‡ŒæŠŠå®ƒåˆ†å¼€ï¼Œå˜æˆä¸¤ä¸ªå¯å­¦ä¹ çš„çº¿æ€§å˜æ¢ã€‚å…¶ä¸­$W_{k,E}$å¯¹åº”çš„æ˜¯å¯¹keyçš„embeddingçš„å˜æ¢ï¼Œè€Œ$W_{k,R}$æ˜¯å¯¹keyçš„ç›¸å¯¹ä½ç½®ç¼–ç çš„å˜æ¢ã€‚åŒç†ï¼Œä½¿ç”¨ä¸¤ä¸ªå‚æ•°$u,v$ä»£æ›¿$W_qU_i$ä¹Ÿæ˜¯ç›¸åŒçš„ç†å¿µ\næ‰€ä»¥å¯¹äºæ–°çš„attentionçš„å…¬å¼ï¼Œ(a)å¯¹åº”çš„æ˜¯content-based addressingï¼Œå³queryå’Œkeyçš„å†…å®¹(embedding)ä¹‹é—´çš„å…³ç³»ï¼›(b)å¯¹åº”çš„æ˜¯content-dependent positional biasï¼Œå³queryå†…å®¹ç›¸å…³çš„ä½ç½®å…³ç³»ï¼›(c)å¯¹åº”çš„æ˜¯global content biasï¼Œå³å…¨å±€çš„å†…å®¹å½±å“ï¼ˆkeyçš„å½±å“ï¼‰ï¼›(d)å¯¹åº”çš„æ˜¯global positional biasï¼Œå…¨å±€çš„ä½ç½®å…³ç³»ï¼Œå³å½“å‰keyçš„ä½ç½®ã€‚\nè¿™ç§ä½ç½®ç¼–ç ä»¥å‰çš„è®ºæ–‡ä¹Ÿå‡ºç°è¿‡ï¼Œä½†æ˜¯åªæœ‰(a)å’Œ(b)ï¼Œèˆå¼ƒäº†(c)å’Œ(d)ï¼Œå³åªçœ‹é‡å’Œå½“å‰queryç›¸å…³çš„ä¿¡æ¯å’Œä½ç½®ç¼–ç ã€‚åœ¨Transformer-XLä¸­ï¼ŒæŠŠå’Œå…¨å±€ä¿¡æ¯ç›¸å…³çš„ä¸œè¥¿ä¹Ÿè€ƒè™‘è¿›æ¥äº†ã€‚\nåœ¨å®é™…å®ç°çš„æ—¶å€™ï¼Œé€šè¿‡å¹³ç§»å¯ä»¥å‡å°bdçš„è®¡ç®—é‡ï¼Œè§Appendix B\nç›¸å…³ä»£ç ä¸ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def rel_multihead_attn(w, r, r_w_bias, r_r_bias, attn_mask, mems, d_model, n_head, d_head, dropout, dropatt, is_training, kernel_initializer, scope='rel_attn'): # w : token emb # r : åå‘çš„ç»å¯¹ä½ç½®emb # r_w_bias ï¼šå…¬å¼ä¸­çš„u # r_r_bias : å…¬å¼ä¸­çš„v ... ... ... # æå–W_q + uå’ŒW_q + v rw_head_q = w_head_q + r_w_bias rr_head_q = w_head_q + r_r_bias # è®¡ç®—(a)å’Œ(c) AC = tf.einsum('ibnd,jbnd-\u003eijbn', rw_head_q, w_head_k) # è®¡ç®—(b)å’Œ(d)ï¼Œè¿™é‡Œçš„è®¡ç®—ç”¨äº†ä¸€ä¸ªtrickï¼Œä½¿å¾—BDçš„O(N^3)çš„è®¡ç®—é‡é™åˆ°äº†O(N)ï¼Œè§è®ºæ–‡appendix B BD = tf.einsum('ibnd,jnd-\u003eijbn', rr_head_q, r_head_k) BD = rel_shift(BD) # å¯¹QK^Tåšscale attn_score = (AC + BD) * scale # Mask attn_mask_t = attn_mask[:, :, None, None] attn_score = attn_score * (1 - attn_mask_t) - 1e30 * attn_mask_t # Softmax + dropout attn_prob = tf.nn.softmax(attn_score, 1) attn_prob = tf.layers.dropout(attn_prob, dropatt, training=is_training) # attentionå‘é‡ä¹˜ä»¥Vå¾—åˆ°æœ€ç»ˆçš„ç»“æœ attn_vec = tf.einsum('ijbn,jbnd-\u003eibnd', attn_prob, w_head_v) ... ... åœ¨Segment-Level Recurrenceå’ŒRelative Positional Encodingçš„åŸºç¡€ä¸Šï¼Œä¸€ä¸ªNå±‚çš„Transformer-XLçš„æ•´ä½“å…¬å¼è¡¨ç¤ºä¸ºï¼š\nå…¶ä¸­ï¼Œn=1,...,Nï¼Œ$h_\\tau^0=E_{s_\\tau}$ï¼Œå³ç¬¬ä¸€å±‚çš„hæ˜¯embeddingã€‚\nReference Transformer: https://arxiv.org/abs/1706.03762\nTransformer-XL: https://arxiv.org/abs/1901.02860\nThe Annotated Transformer: https://nlp.seas.harvard.edu/2018/04/03/attention.html\nThe Illustrated Transformer: http://jalammar.github.io/illustrated-transformer/\n","description":"","tags":["â€œdeep learning\"","nlp","transformer","paper note"],"title":"From Transformer to Transformer-XL","uri":"/posts/deep-learning/tttttransformer/"},{"categories":null,"content":"Introduction Software engineering(SE) and programming languages(PL) should make the transition just like NLP: from brittle rule-based expert systems to statistical methods and machine learning techniques.\nThe paper is orginized as follows:\nDifference between natural language and source code Taxonomy of probabilistic models of source code SE and PL applications Challenges and future directions The Naturalness Hypothesis The Naturalness Hypothesis\nSoftware is a form of human communications; software corpora have similar statistical properties to natural language corpora; these properties can be exploited to build better software engineering tools\nInsights:\nBecause coding is an act of communication, so the large code corpora is expected to have rich patterns, just like natural language corpora. Example: models developed for natural language are effective for source code Probabilistic model can be learned to describe how developers naturally writes and use code. Naturalness means learnable and predictionable Text, Code and Machine Learning Source code plays a role of connector between computers and the human mind.\nHindle et al. shows that code is more predictable than texts using n-gram language model.\nEnumerate differences between code and texts is helpful for us to gain some insights on modifying NLP techniques to deal with code:\nCode is executable and has formal syntax and semantics. We will discuss these aspects comparing code with text.\nExecutable Code is more brittle, small changes may lead to huge differences. Texts are usually more robust to readers. It requires combination of probabilistic and formal methods.\nProgramming languages can be translated between each other exactly, because all mainstream programming languages are Turing-complete.\nFormality Programming languages are formal languages. Code's formality facilites reuse, Gabel et al. found that code is more pattern dense than text.\nAlso, code has less ambiguity than text, but the problem of ambiguity still exists.\nCross-Channel Interaction Natural semantic units of code are identifiers, statements, blocks and functions. All of them have less semantic information than textual semantic units like words and sentences.\nAlmost 70% words are identifiers and neologisms(æ–°è¯) are more common in code.\nHow existing work handles neologism: introduce cache mechanisms or decompose identifiers at a subtoken level Which semantic unit of code is more useful? It's an open question.\nProbabilistic Models of Code Code-generating Models General code-generating models can be formulated as: $$ P_D(c|C(c)) $$ When context $C(c)$ is $\\emptyset$, the probability distribution $P_D$ is a language model for code; when $C(c)$ is code, $P_D$ is a transducer model; when $C(c)$ is natural language, $P_D$ is a code-generative multimodal model of code.\nIn addition, by the way they generate code's structure, code-generating models can be divided into three types:\nToken-level models: generate token sequences\nCannot always generate executable code Approaches: N-gram, with smoothing and cache mechanism. RNN Syntactic models: generate tree structures\nGenerate syntactically correct code Different from application in NLP, PCFG is not suitable for code generation. Because nearby tokens may be far away in the AST, PCFG cannot even capture close dependencies(as well as long-range dependencies, but this is not the point, n-gram do not capture this neither) Expensive computation cost than token-level model Semantic models: generate graph structures\nDIfficult, less resource on this topic Types of Code Generating Models 1. Language Models LM models programming language itself without using any external content.\nCode LMs are evaluated using perplexity or cross-entropy just like normal LM in NLP\n2. Code Transducer Models Code transducer models translate code from one format to another format. For example, pesudo code generator or code migration.\nMost of transducer models are phrase based model, which is not good at describing long-range dependency.\nTransducer models can be evaluated using BLEU, etc.\n3. Multimodal Models Multimodal model exploits non-code modalities, like comments, search queries, etc.\nThe key idea is to convert natural language to an intermediate representation, then parse it to code, which is similar with semantic parsing in NLP\nRepresentational Models of Code Different from generative models, representational models learns embeddings from code.\nDistributed representations(Code embedding) Tasks\nPredict method name Predict relevant API sequences(Seq2seq) Represent solution-problem mapping Source code input\u0026output pairs to review student assignment Neural code-generative models Generate other modalities like comments Structured prediction Predict interdependent variables, like POS prediction in NLP. Structured prediction and distributed representations are not exclusive.\nExample:\nRaychev et al. represent code as a variable dependency network, each variable is a node, model pairwise interactions as a CRF -\u003e predict types and names of variables\nGu et al. predict the sequence of API calls\nPattern Mining Models Pattern mining models aims to discover a finite set of human-interpretable patterns from source code.\nExample:\nâ€‹\tFowkes et al. learn the latent variables of a graphical model to infer common API usage patterns\nApplications Recommender Systems Modeling programmers' intent is a challenge.\nThe most prominent recommender system in code intelligence field is code completion.\nExisting Research:\nn-gram and cached n-gram:\nn-gram LM is used to model source code, cache is used to catch local information\nAST-level LM\nMaddison and Tarlow\nInferring Coding Conventions Coding convention: syntactic constraints on code beyond grammar, like formatting, CamelCase naming, etc.\nLearning of coding conventions from codebases helps teams to determine their coding conventions\nMachine learning models for learning surface structure are well-suited for this task, while there exists a challenge: the sparsity of the code constructs.\nCode Defects Finding code defects is quite difficult beacuse of the rarity of defects and the extreme diversity of source code.\nProliminary work shows that the lower probability of specific code may indicate code defects. Not all anomalous behavior is a bug(it may be just rare behavior), the vast diversity of code constructs entails sparsity, from which all anomaly detection methods suffer.\nCode Translation, Copying, and Clones Translation The success of SMT has inspired researchers to use ML to translate code from one source language to another. Translation on similar languages are easier. But for languages which have different memory allocations, translation is difficult.\nClones Clones may indicate refactoring opportunities.\nEmbedding can be used to detect clones due to the similar snippets share the similar distributed vector representations. Use embedding allows us to learn a continuous similarity metric(like cosine distance) between code locations, rather than using edit distance.\nCode to Text and Text to Code Code to Text C2T has applications to code documentation and readability.\nExample: code to pseudocode, code to comments\nText to Code This area is more related to semantic parsing in NLP.\nSemantic parsing is the task of converting a natural language utterance into a representation of its meaning, often database or logical queries. Those representations can be used in subsequentily question answering.\nBased on current research, the target code can be Excel macros, Java expressions, shell commands, etc.\nFor more information, please refer to Neubig's survey of code generation methods.\nDocumentation, Traceability and Information Retrieval General C2T and T2C can be used here, but more specialized solutions are more effective on problems like documentation and code search. Information retrieval methods are widely used.\nCode search problems are evaluated using rank-based measures.\nProgram Synthesis Program synthesis is concerned with generating full or partial programs from a specification. When the specification is natural language, this is a semantic parsing task(same as T2C). Besides natural language, a lot of other specifications can be used in program synthesis.\nProgram Analysis Program analysis aims to soundly extract semantic properties (like correctness) from programs. There are three streams which exploit probabilistic models to deal with code sound analyses problem.\nA family of modes relaxes the soundness requirement, yielding probabilistic results instead\nThe second stream uses machine learning to create models that produce plausible hypotheses of formal verification statements that can be proved\nExample: Brockschmidt et al. proposed a model which generates separation logic expressions from the heap graph of a program, suitable for formally verifying program's correctness.\nThe third stream learns heuristics replacing hard-coded heuristics to speed-up the search for a formal automated proof\nChallenges and Future Directions Deep learning is popular, but it is not necessary. In many cases, simple models can outperform advanced off-the-self deep learning methods.\nBridging Representations and Communities In software engineering research, a well-defined and widely useful set of representations are used, such as AST, CFG, etc. In contrast, machine learning usually uses continuous representations.\nIntroducing better representations that bridge the gap between machine learning and source code will allow the probabilistic models of code to reason about the rich structure and semantics of code.\nData Sparsity, Compositionality and Strong Generalization Sparsity: it's hard to find multiple source code elements which perform exactly the same tasks.\nCompositionality: meaning of some element can be understood by composing the meaning of its constituent parts.\nExample\nMethods -\u003e Classes\nWord -\u003e Variable names in camel case naming\nThis area is still challenging for general machine learning fields, because capturing relations between objects especially across abstraction levels is difficult.\nIf suï¬ƒcient progress is to be made, representing source code artifacts in machine learning will improve signiï¬cantly, positively aï¬€ecting other downstream tasks\nStrong generalization: big machine model learned from big code is usually to large for developer's machine. Hence, generalization is a deployability problem.\nDirection: transfer learning \u0026 one-shot learning Learning from multiple views of source code may help to deal with generalization problem and data sparsity Measures High-quality benchmarks, shared tasks and evaluation metrics play an important role win great success in NLP and CV in recent years.\nSome meansurements can be imprecise\nSome metrics that are widely used in NLP are not suitable for source code, such as BLEU.\nSmall changes in source code may lead to big difference; syntactically diverse answers may be semantically equivalent.\nNew Domains Debugging Trace buggy code during execution\nTraceability Study links among software engineering artifacts\nExample: fix commit -\u003e bug reports\nCode Completion and Synthesis We don't have a well-accepted benchmark in this area.\nWhen reasoning about incomplete code's semantics, modeling how code could be completed is helpful\nEducation Assistive Tools Conclusions Almost every area of program analysis and software engineering would benefit from the development of probabilistic models of source code.\nProbabilistic models of source code raise the exciting opportunity of learning from existing code, probabilistically reasoning about new source code artifacts and transferring knowledge between developers and projects\nMost of the research contained in this review was conducted within the past few years\n","description":"","tags":["paper note","research"],"title":"A Survey of Machine Learning for Big Code and Naturalness","uri":"/posts/code-intelligence/a-survey-of-machine-learning-for-big-code-and-naturalness/"},{"categories":null,"content":"Original post: http://www.sheshbabu.com/posts/rust-module-system/\nRustçš„æ¨¡å—ç³»ç»Ÿæ¯”è¾ƒç‰¹æ®Šï¼Œåˆå­¦è€…ä¸å¤ªå®¹æ˜“ä¸Šæ‰‹ç†è§£ï¼Œä¸Šé¢çš„æ–‡ç« è¯¦ç»†ä»‹ç»äº†Rustæ¨¡å—ç³»ç»Ÿï¼Œä¸‹é¢æ˜¯é˜…è¯»ç¬”è®°ã€‚\nå·¥ç¨‹ç»“æ„ é¦–å…ˆï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸ªå…¸å‹çš„Rustå·¥ç¨‹çš„æ–‡ä»¶ç»“æ„ï¼Œå’Œå…¶ä¸­çš„è°ƒç”¨\nExample 1 é¦–å…ˆçœ‹ç¬¬ä¸€ä¸ªä¾‹å­ï¼šä»main.rsä¸­è°ƒç”¨config.rsã€‚åœ¨Rustä¸­ï¼Œæ¯ä¸€ä¸ªæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹éƒ½è¢«çœ‹åšä¸€ä¸ªmoduleï¼Œå¦‚config.rsï¼Œå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªåä¸ºconfigçš„moduleã€‚æˆ‘ä»¬å¯ä»¥ä»å…¶ä»–çš„æ–‡ä»¶ä¸­å¯¼å…¥è¯¥moduleã€‚åœ¨æœ€åˆæ²¡æœ‰ä»»ä½•å¯¼å…¥è¯­å¥çš„æ—¶å€™ï¼ŒRustç¼–è¯‘å™¨åªèƒ½çœ‹åˆ°å¦‚ä¸‹çš„ç»“æ„ï¼š\né»˜è®¤æƒ…å†µä¸‹ï¼ŒRustçš„ç¼–è¯‘å™¨åªä¼šæŠŠmain.rsçœ‹åšæ˜¯crateæ¨¡å—ï¼Œè€Œä¸ä¼šæ ¹æ®æ–‡ä»¶ç›®å½•è‡ªåŠ¨ç”Ÿæˆæ¨¡å—æ ‘ï¼Œæ‰€æœ‰çš„æ¨¡å—ç»“æ„éƒ½éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å¯¼å…¥æ„å»ºã€‚\né‚£ä¹ˆï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±æ‰‹åŠ¨æ„å»ºæˆ‘ä»¬çš„æ¨¡å—æ ‘ã€‚åœ¨Rustä¸­ï¼Œå…³é”®å­—modè¢«ç”¨æ¥å£°æ˜ä¸€ä¸ªæ¨¡å—æˆ–è€…å­æ¨¡å—ã€‚æ¯”å¦‚ï¼Œå¯¹äºconfig.rsï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨mod config;æ¥å£°æ˜è¯¥æ¨¡å—ã€‚\nå®¹æ˜“å‡ºé”™çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸æ˜¯åœ¨config.rsä¸­ä½¿ç”¨mod config;å£°æ˜ï¼Œè€Œæ˜¯éœ€è¦åœ¨main.rsä¸­ä½¿ç”¨mod config;å»å£°æ˜configæ¨¡å—ï¼š\n1 2 // main.rs mod config; // declare config mod åœ¨main.rsä¸­å£°æ˜äº†configæ¨¡å—ä¹‹åï¼ŒRustçš„ç¼–è¯‘å™¨å°±ä¼šå»å¯»æ‰¾config.rsæ–‡ä»¶æˆ–è€…config/mod.rsæ–‡ä»¶æ¥æ„å»ºæ¨¡å—ç»“æ„ã€‚å¦‚æœconfig.rsä¸­æœ‰ä¸€ä¸ªåä¸ºprint_config()çš„å‡½æ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥é€šè¿‡config::print_config()æ¥è°ƒç”¨äº†ã€‚ä¸‹é¢æ˜¯å®Œæ•´çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 // main.rs mod config; fn main() { config::print_config(); println!(\"main\"); } // config.rs pub fn print_config() { // æ³¨æ„éœ€è¦æŠŠå‡½æ•°å£°æ˜ä¸ºpublic println!(\"config\"); } åˆ°æ­¤ä¸ºæ­¢æˆ‘ä»¬å­¦ä¼šäº†åŒçº§çš„æ¨¡å—å¯¼å…¥ã€‚ä½†æ˜¯åœ¨å®é™…å·¥ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¾€å¾€å¸Œæœ›é€šè¿‡æ–‡ä»¶å¤¹æ¥æŠŠä¸€ä¸ªç³»åˆ—çš„æ–‡ä»¶ç»„ç»‡åˆ°ä¸€èµ·ã€‚ä¸‹é¢çœ‹ç¬¬äºŒä¸ªä¾‹å­ã€‚\nExample 2 å‡è®¾æˆ‘ä»¬éœ€è¦ä»main.rsä¸­è°ƒç”¨routes/health_route.rsä¸­çš„å‡½æ•°print_health_routeã€‚ç”±äºhealth_route.rsåœ¨æ–‡ä»¶å¤¹routesä¸‹é¢ï¼Œå› æ­¤è¿™ä¸ªæ–‡ä»¶å¯¹main.rsæ¥è¯´æ˜¯ä¸å¯è§çš„ã€‚å¦‚ä½•è§£å†³å‘¢ï¼Ÿè¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å°±éœ€è¦åœ¨routesæ–‡ä»¶å¤¹ä¸‹é¢æ·»åŠ ä¸€ä¸ªåä¸ºmod.rsçš„æ–‡ä»¶ã€‚\n1 2 3 4 5 6 7 8 9 10 11 my_project â”œâ”€â”€ Cargo.toml â””â”€â”¬ src â”œâ”€â”€ main.rs â”œâ”€â”€ config.rs â”œâ”€â”¬ routes + â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ health_route.rs â”‚ â””â”€â”€ user_route.rs â””â”€â”¬ models â””â”€â”€ user_model.rs mod.rsåœ¨Rustçš„æ¨¡å—ç³»ç»Ÿä¸­éå¸¸é‡è¦ã€‚è¿˜è®°çš„ä¸Šé¢çš„config.rså—ï¼Ÿå¦‚æœconfigæ¨¡å—çš„ä»£ç è¶Šæ¥è¶Šå¤šï¼Œéœ€è¦åˆ†æˆè‹¥å¹²ä¸ªæ–‡ä»¶è¿›è¡Œç»„ç»‡çš„æ—¶å€™ï¼Œå°±éœ€è¦åˆ›å»ºconfigæ–‡ä»¶å¤¹ï¼Œç„¶ååœ¨config/mod.rsä¸­å£°æ˜æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰å­æ¨¡å—äº†ã€‚å¯ä»¥è¿™æ ·è®¤ä¸ºï¼šæ–‡ä»¶å¤¹æ¨¡å—çš„config/mod.rså…¶å®å°±ç›¸å½“äºå•æ–‡ä»¶æ¨¡å—çš„config.rsã€‚\nåœ¨æœ¬ä¾‹å­ä¸­ï¼Œä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚æƒ³è¦åœ¨main.rsä¸­è°ƒç”¨print_health_route()ï¼Œæˆ‘ä»¬éœ€è¦åšå¦‚ä¸‹ä¸‰ä»¶äº‹ï¼š\nåˆ›å»ºroutes/mod.rsï¼Œå¹¶ä¸”åœ¨main.rsä¸­ï¼Œä½¿ç”¨mod routes;å£°æ˜routesæ¨¡å— åœ¨routes/mod.rsä¸­å£°æ˜health_routeå­æ¨¡å—ï¼Œå¹¶ä¸”æŠŠå®ƒå£°æ˜ä¸ºpublic åœ¨routes/health_route.rsä¸­ï¼ŒæŠŠå‡½æ•°print_health_route()å£°æ˜ä¸ºpublic å®Œæˆçš„ä»£ç å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // main.rs mod config; mod routes; fn main() { routes::health_route::print_health_route(); config::print_config(); println!(\"main\"); } // routes/mod.rs pub mod health_route; // routes/health_route.rs pub fn print_health_route() { println!(\"health_route\"); } æ­¤æ—¶çš„æ¨¡å—æ ‘å¦‚ä¸‹æ‰€ç¤ºï¼š\nExample 3 ç¬¬ä¸‰ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬ä¼šå°è¯•å¦‚ä¸‹çš„è°ƒç”¨é“¾è·¯ï¼šmain.rs =\u003e routes/user_route.rs =\u003e models/user_model.rsã€‚\né¦–å…ˆå’ŒExample 2ä¸­çš„ä¸€æ ·ï¼Œæˆ‘ä»¬æŠŠmodels/user_model.rså­æ¨¡å—æ„å»ºå¥½ï¼š\nç„¶åï¼Œæˆ‘ä»¬çœ‹è°ƒç”¨é“¾è·¯çš„ååŠéƒ¨åˆ†ï¼šä»routes/user_route.rsä¸­è°ƒç”¨models/user_model/rsä¸­çš„å‡½æ•°ã€‚å¯¹äºåŒçº§çš„å‡½æ•°è°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ¨¡å—æ ‘çš„æœ€ä¸Šé¢é€çº§å¾€ä¸‹è°ƒç”¨ï¼Œå³crate::models::user_model\n1 2 3 4 5 // routes/user_route.rs pub fn print_user_route() { crate::models::user_model::print_user_model(); println!(\"user_route\"); } ä½†æ˜¯ï¼Œåœ¨æ–‡ä»¶è·¯å¾„éå¸¸é•¿çš„æ—¶å€™ï¼Œæ¯æ¬¡ä»æ ¹æ¨¡å—å¾€ä¸‹æ‰¾è·¯å¾„ä¼šéå¸¸å†—é•¿ï¼Œå› æ­¤Rustæä¾›äº†superå…³é”®è¯æ¥å®šä½åˆ°çˆ¶æ¨¡å—ã€‚\nå¦‚æœæˆ‘æƒ³æƒ³è¦ä»user_route.rsä¸­è°ƒç”¨health_routeï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨super::health_route::print_health_route()ä»£æ›¿crate::routes::health_route::print_health_routeï¼š\n1 2 3 4 5 6 7 pub fn print_user_route() { // crate::routes::health_route::print_health_route(); // can also be called using super::health_route::print_health_route(); println!(\"user_route\"); } Useå…³é”®å­— åœ¨è°ƒç”¨å…¶ä»–æ¨¡å—æ—¶ï¼Œå¤§éƒ¨åˆ†æ—¶å€™ä¸ä¼šæ¯æ¬¡éƒ½å†™å®Œæ•´çš„è°ƒç”¨é“¾è·¯ï¼Œè€Œæ˜¯ä¼šä½¿ç”¨useå…³é”®å­—å…ˆå¯¼å…¥æŸä¸ªæ¨¡å—ã€‚å°±ä¸Šé¢çš„è·¯å­ï¼Œå¯ä»¥æ”¹æˆå¦‚ä¸‹çš„ä»£ç ï¼š\n1 2 3 4 5 6 7 8 // å¯¼å…¥ use crate::routes::health_route::print_health_route; pub fn print_user_route() { // ä½¿ç”¨ print_health_route(); println!(\"user_route\"); } ä¸‰æ–¹åŒ… åœ¨ä½¿ç”¨ä¸‰æ–¹åŒ…æ—¶ï¼Œéœ€è¦åœ¨Cargo.tomlä¸­å£°æ˜[dependencies]ã€‚å£°æ˜ä¹‹åçš„ä¸‰æ–¹åŒ…æ¨¡å—ä¼šåœ¨å·¥ç¨‹æ‰€æœ‰çš„æ¨¡å—ä¸­è‡ªåŠ¨ç”Ÿæ•ˆã€‚\nä¸¾ä¾‹ï¼šå¦‚æœæˆ‘ä»¬åœ¨[dependencies]ä¸­ä½¿ç”¨äº†randåŒ…ï¼Œåœ¨ä»»æ„ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨è¯¥æ¨¡å—ï¼š\n1 2 3 4 5 6 pub fn print_health_route() { // ç›´æ¥ä½¿ç”¨å³å¯ let random_number: u8 = rand::random(); println!(\"{}\", random_number); println!(\"health_route\"); } å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å…ˆuseï¼Œç„¶åå†ä½¿ç”¨ï¼š\n1 2 3 4 5 6 7 use rand::random; pub fn print_health_route() { let random_number: u8 = random(); println!(\"{}\", random_number); println!(\"health_route\"); } æ€»ç»“ Rustä¸­çš„æ¨¡å—ç³»ç»Ÿéœ€è¦æ˜¾å¼åœ°å»å£°æ˜ç»“æ„ åœ¨å£°æ˜ä¸€ä¸ªæ¨¡å—æ—¶ï¼Œéœ€è¦åœ¨å®ƒçš„çˆ¶çº§å£°æ˜ï¼Œè€Œä¸æ˜¯åœ¨è¿™ä¸ªæ–‡ä»¶æœ¬èº«ï¼ˆä¸Šé¢çš„main.rsç›¸å½“äºæ˜¯config.rsçš„çˆ¶çº§ï¼ŒåŒæ ·ï¼Œmod.rsä¹Ÿæ˜¯ç›¸å½“äºæ˜¯åŒçº§çš„health_score.rsçš„çˆ¶çº§ï¼‰ modå…³é”®å­—ç”¨äºå£°æ˜å­æ¨¡å— å¦‚æœæƒ³è¦ä¸€ä¸ªå‡½æ•°ã€ç»“æ„ä½“ç­‰è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼Œå¿…é¡»ä½¿ç”¨pubå…³é”®å­—å£°æ˜å…¶ä¸ºpublic ä½¿ç”¨useå…³é”®å­—å¯ä»¥å¯¼å…¥æ¨¡å—ä»¥å‡å°‘é‡å¤ä»£ç  ä¸‰æ–¹åŒ…ä¸å¿…æ˜¾å¼åœ°å£°æ˜ ","description":"","tags":["Rust"],"title":"Rust's Module System","uri":"/posts/engineering/rusts-module-system/"},{"categories":null,"content":"Learning Rust - 4 Rustçš„ä»£ç ç»„ç»‡ é¦–å…ˆäº†è§£ä¸€äº›æ¦‚å¿µï¼š\nPackageï¼šå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä»£ç åº“ï¼ŒåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªcrateï¼Œä»¥åŠå¦‚ä½•ç”Ÿæˆè¿™äº›crateçš„ä¿¡æ¯ï¼ˆcargo.tomlï¼‰ Crateï¼šç¼–è¯‘å•å…ƒï¼Œæ¯ä¸ªcrateå¯ç¼–è¯‘æˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–ä¸€ä¸ªåº“ï¼ˆlibï¼‰ã€‚Crateä¸­åŒ…å«éšå¼çš„é¡¶å±‚Module Moduleï¼šä»£ç ç»„ç»‡çš„å•ä½ï¼Œä»£ç æ¨¡å— Packageå’ŒCrate ä½¿ç”¨cargo new my-projectç”Ÿæˆçš„å°±æ˜¯ä¸€ä¸ªPackageã€‚åœ¨é»˜è®¤ç”Ÿæˆçš„å·¥ç¨‹ä¸­ï¼Œæœ‰ä¸€ä¸ªcargo.tomlï¼Œè¿™ä¸ªå°±æ˜¯Packageçš„é…ç½®ã€‚æ­¤å¤–ï¼Œé»˜è®¤è¿˜æœ‰ä¸€ä¸ªsrc/main.rsï¼Œè¿™ä¸ªå°±æ˜¯å½“å‰Packageçš„é»˜è®¤Crateã€‚å¦‚æœä¸€ä¸ªPackageä¸­åŒ…å«src/main.rså’Œsrc/lib.rsï¼Œé‚£ä¹ˆè¿™ä¸ªåŒ…é‡Œé¢å°±æœ‰ä¸¤ä¸ªCrateï¼Œä¸€ä¸ªæ˜¯å¯æ‰§è¡Œæ–‡ä»¶çš„ï¼Œä¸€ä¸ªæ˜¯åº“çš„ï¼Œä»–ä»¬çš„åç§°éƒ½å’ŒPackageç›¸åŒã€‚\nå¦‚æœä½ è¿˜æƒ³æ·»åŠ æ›´å¤šçš„å¯æ‰§è¡Œæ–‡ä»¶çš„Crateï¼Œé‚£ä¹ˆå°±åœ¨src/binç›®å½•ä¸‹æ·»åŠ æ–‡ä»¶å³å¯ï¼Œæ¯ä¸ªæ–‡ä»¶éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„Binary Crateã€‚\nModule Moduleæ˜¯Rustä¸­ä»£ç ç»„ç»‡çš„é€»è¾‘å•å…ƒã€‚åœ¨ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œå¯ä»¥å£°æ˜å¾ˆå¤šä¸œè¥¿ï¼š\nå¸¸é‡ ç±»å‹åˆ«å å‡½æ•° ç»“æ„ æšä¸¾ Traits impl å— å…¶ä»–æ¨¡å— åœ¨æ¨¡å—ä¸­ï¼Œè¿˜èƒ½è®¾ç½®å…¶æˆå‘˜çš„å¯è§æ€§ï¼Œå¦‚æœæœ‰pubä¿®é¥°ï¼Œé‚£ä¹ˆå°±æ˜¯æ¨¡å—å¤–éƒ¨å¯è§çš„ï¼Œå¦åˆ™ä¸å¯è§ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 mod authentication { pub struct User { username: String, password_hash: u64, } impl User { pub fn new(username: \u0026str, password: \u0026str) -\u003e User { User { username: username.to_string(), password_hash: hash_password(password), } } } fn hash_password(input: \u0026str) -\u003e u64 { /*...*/ } } fn main() { let user = authentication::User::new(\"jeremy\", \"super-secret\"); println!(\"The username is: {}\", user.username); println!(\"The password is: {}\", user.password_hash); } æ¨¡å—authenticationä¸­æœ‰ä¸€ä¸ªç»“æ„ä½“Userå’Œä¸€ä¸ªå‡½æ•°has_passwordï¼Œç„¶åUserè¿˜å®šä¹‰äº†ä¸€ä¸ªnewå‡½æ•°ã€‚æ³¨æ„ä¸‹é¢è°ƒç”¨æ—¶ï¼Œè°ƒç”¨newå‡½æ•°ä½¿ç”¨çš„æ˜¯authentication::User::new()ï¼Œ::ç¬¦å·å°±æ˜¯ç”¨æ¥è·å–moduleæˆ–structçš„æˆå‘˜çš„ã€‚\n::å’Œ.çš„åŒºåˆ« å½“å·¦è¾¹æ˜¯ä¸€ä¸ªmoduleæˆ–è€…ä¸€ä¸ªstructç±»å‹çš„æ—¶å€™ï¼Œä½¿ç”¨::ï¼Œå½“å·¦è¾¹æ˜¯ä¸€ä¸ªå€¼çš„æ—¶å€™ï¼Œä½¿ç”¨.ã€‚\næ·»åŠ ä¸‰æ–¹Crate å¦‚æœæƒ³ä½¿ç”¨ä¸‰æ–¹Crateï¼Œç›´æ¥åœ¨cargo.tomlé‡Œé¢æ·»åŠ dependencyå³å¯ï¼š\n1 2 [dependencies] regex = \"1.4.2\" ä¸Šé¢å°±æ˜¯æ·»åŠ äº†ä¸€ä¸ªåä¸ºregexçš„ä¸‰æ–¹Crateï¼Œç‰ˆæœ¬ä¸º1.4.2ã€‚\nåœ¨ä»£ç ä¸­ï¼Œå°±å¯ä»¥ä½¿ç”¨useå…³é”®å­—æ¥ä½¿ç”¨Crateä¸­çš„ç»“æ„ã€Moduleç­‰ï¼š\n1 2 3 4 5 6 use regex::Regex; fn main() { let re = Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap(); println!(\"Did our date match? {}\", re.is_match(\"2014-01-01\")); } Test å•å…ƒæµ‹è¯• åœ¨Rustä¸­ï¼Œå¯ä»¥ä½¿ç”¨#[test]æ ‡æ³¨å•å…ƒæµ‹è¯•ï¼š\n1 2 3 4 5 6 7 8 9 10 fn add(a: i32, b: i32) -\u003e i32 { a + b } #[test] fn add_works() { assert_eq!(add(1, 2), 3); assert_eq!(add(10, 12), 22); assert_eq!(add(5, -2), 3); } ç„¶åï¼Œä½¿ç”¨cargo testå¯ä»¥è¿è¡Œæ‰€æœ‰çš„å•å…ƒæµ‹è¯•ã€‚\nå¦‚æœæˆ‘å¸Œæœ›æˆ‘çš„å•å…ƒæµ‹è¯•æ˜¯å¤±è´¥çš„ï¼Œæˆ–è€…æµ‹è¯•æŸç§äº§ç”Ÿpanicçš„æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨#[should_panic]æ ‡æ³¨ï¼š\n1 2 3 4 5 #[test] #[should_panic] fn add_fails() { assert_eq!(add(2, 2), 7); } å¦‚æœå¸Œæœ›è·³è¿‡æŸäº›å•å…ƒæµ‹è¯•ï¼Œåˆ™éœ€è¦ä½¿ç”¨#[ignore]ï¼š\n1 2 3 4 5 #[test] #[ignore = \"not yet reviewed by the Q.A. team\"] fn add_negatives() { assert_eq!(add(-2, -2), -4) } æµ‹è¯•æ¨¡å— ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œéœ€è¦æŠŠå•å…ƒæµ‹è¯•éƒ½å†™å…¥æµ‹è¯•æ¨¡å—ï¼Œå¦‚æœä¸€ä¸ªModuleæ˜¯æµ‹è¯•æ¨¡å—ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨#[cfg(test)]æ ‡æ³¨ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fn add(a: i32, b: i32) -\u003e i32 { a + b } #[cfg(test)] mod add_function_tests { use super::*; #[test] fn add_works() { assert_eq!(add(1, 2), 3); assert_eq!(add(10, 12), 22); assert_eq!(add(5, -2), 3); } #[test] #[should_panic] fn add_fails() { assert_eq!(add(2, 2), 7); } #[test] #[ignore] fn add_negatives() { assert_eq!(add(-2, -2), -4) } } æµ‹è¯•æ¨¡å—ä¼šåœ¨cargo testæ—¶ç¼–è¯‘å¹¶ä¸”è¿è¡Œ\næ–‡æ¡£æµ‹è¯• Rustä¸­æœ‰ä¸€ç§æ³¨é‡Šå«åšæ–‡æ¡£æ³¨é‡Šï¼Œä»¥///æ ‡è®°ã€‚æ–‡æ¡£æ³¨é‡Šçš„æ‰€æœ‰å†…å®¹ä¼šè¢«å†™å…¥Markdownä¸­ï¼Œå¹¶ä¸”æ–‡æ¡£æ³¨é‡Šä¸­çš„Markdownä»£ç å—å¯ä»¥è¢«ç¼–è¯‘å’Œæµ‹è¯•ï¼Œè¿™å°±æ˜¯æ–‡æ¡£æµ‹è¯•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /// Generally, the first line is a brief summary describing the function. /// /// The next lines present detailed documentation. /// Code blocks start with triple backticks. The code has an implicit `fn main()` inside and `extern crate \u003ccratename\u003e`, /// which means you can just start writing code. /// /// ``` /// let result = basic_math::add(2, 3); /// assert_eq!(result, 5); /// ``` /// /// ```rust,should_panic /// panic!(\"panic\"); /// ``` pub fn add(a: i32, b: i32) -\u003e i32 { a + b } ä½¿ç”¨cargo teståŒæ ·ä¼šè·‘æ–‡æ¡£æ³¨é‡Šä¸­çš„ä»£ç å—\né›†æˆæµ‹è¯• Rustè¿˜æ”¯æŒæŠŠCrateä½œä¸ºä¸€ä¸ªæ•´ä½“æ¥æµ‹è¯•ï¼Œè¿™äº›æµ‹è¯•åœ¨å•ç‹¬çš„ç›®å½•å’Œæ–‡ä»¶ä¸­ï¼štests/xxx.rsã€‚\n","description":"","tags":["rust"],"title":"Learning Rust - 4","uri":"/posts/engineering/learning-rust-4/"},{"categories":null,"content":"Learning Rust - 3 æ³›å‹ æ³›å‹æ˜¯éå¸¸å¸¸è§çš„è¯­è¨€ç‰¹æ€§ã€‚ä½¿ç”¨æ³›å‹ç±»å‹æ—¶ï¼Œå¯ä»¥æŒ‡å®šæ‰€éœ€æ“ä½œï¼Œè€Œä¸å¿…è€ƒè™‘å®šä¹‰ç±»å‹æŒæœ‰çš„å†…éƒ¨ç±»å‹ã€‚åœ¨Rustä¸­ï¼Œä½¿ç”¨å°–æ‹¬å·\u003c\u003eæ¥å£°æ˜ä¸€ä¸ªç»“æ„ä½“çš„æ³›å‹ç±»å‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 struct Point\u003cT\u003e { x: T, y: T, } fn main() { let boolean = Point { x: true, y: false }; let integer = Point { x: 1, y: 9 }; let float = Point { x: 1.7, y: 4.3 }; let string_slice = Point { x: \"high\", y: \"low\" }; } ä¸Šé¢ä»£ç ä¸­ï¼ŒTå°±æ˜¯æ³›å‹çš„ç±»å‹ï¼Œåœ¨å®ä¾‹åŒ–çš„æ—¶å€™ï¼ŒTå¯ä»¥è¢«ä»»ä½•ç¡®å®šçš„ç±»å‹ä»£æ›¿ã€‚åœ¨ä¸Šé¢çš„å®šä¹‰ä¸­ï¼Œå®é™…ä¸Šå°±æ˜¯å£°æ˜äº†xå’Œyå±äºåŒä¸€ç§æ•°æ®ç±»å‹ï¼Œä½†æ˜¯å…·ä½“ç±»å‹æœªæŒ‡å®šã€‚å¦‚æœæƒ³æŠŠxå’Œyå£°æ˜ä¸ºä¸åŒçš„ç±»å‹ï¼Œå¯ä»¥ä½¿ç”¨ï¼š\n1 2 3 4 struct Point\u003cT, U\u003e { x: T, y: U, } ç‰¹æ€§ ç‰¹æ€§ï¼ˆtraitï¼‰æŒ‡ä¸€ç»„å¯ä»¥è¢«å„ç§æ•°æ®ç±»å‹å®ç°çš„é€šç”¨æ¥å£ï¼Œå®ƒå®šä¹‰äº†ä¸€ç»„é€šç”¨çš„è¡Œä¸ºã€‚æ¯”å¦‚æˆ‘ä»¬ä¹‹å‰é‡åˆ°çš„Copyç‰¹æ€§ï¼Œå°±æ˜¯ä»£è¡¨ç€ä¸€ä¸ªç±»å‹æ˜¯é»˜è®¤è¢«å¤åˆ¶è€Œä¸æ˜¯è¢«ç§»åŠ¨çš„ã€‚å¦‚æœä½ æƒ³è¦è‡ªå·±å®šä¹‰çš„ç±»å‹é»˜è®¤è¢«å¤åˆ¶ï¼Œé‚£ä¹ˆåªéœ€è¦å®ç°Copyç‰¹æ€§å³å¯ã€‚è¿™ä¸ªå®šä¹‰å’Œgolangä¸­çš„æ¥å£éå¸¸ç›¸ä¼¼ï¼ŒåŒºåˆ«åœ¨äºgolangä¸­çš„æ¥å£æ˜¯éšå¼å®ç°çš„ï¼Œè€Œåœ¨Rustä¸­æˆ‘ä»¬å¿…é¡»æ˜¾å¼å£°æ˜æŸä¸ªç±»å‹å®ç°äº†æŸä¸ªç‰¹æ€§ã€‚\næˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨traitå…³é”®å­—è‡ªå·±å»å®šä¹‰ç‰¹æ€§ï¼š\n1 2 3 trait Area { fn area(\u0026self) -\u003e f64; } ä¸Šé¢çš„ä»£ç å°±å®šä¹‰äº†â€æœ‰é¢ç§¯â€œçš„è¿™ä¹ˆä¸€ä¸ªç‰¹æ€§ï¼Œä¸­é—´å®šä¹‰çš„å‡½æ•°å°±ä»£è¡¨ç€ï¼Œå¦‚æœä¸€ä¸ªç±»å‹æœ‰è¯¥ç‰¹æ€§ï¼Œé‚£ä¹ˆéœ€è¦å®ç°è®¡ç®—å…¶é¢ç§¯çš„areaæ–¹æ³•ã€‚æ¯”å¦‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªçŸ©å½¢çš„ç»“æ„ï¼š\n1 2 3 4 struct Rectangle { width: f64, height: f64, } æˆ‘ä»¬å°±å¯ä»¥ä¸ºRectangleç»“æ„å®ç°Areaç‰¹æ€§ï¼Œæ¥è®¡ç®—å…¶é¢ç§¯ï¼š\n1 2 3 4 5 impl Area for Rectangle { fn area(\u0026self) -\u003e f64 { self.width * self.height } } ä¸ºå®ç°æŸç§ç±»å‹çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬ä½¿ç”¨å…³é”®å­— impl Trait for Typeï¼Œå…¶ä¸­ Trait æ˜¯è¦å®ç°çš„ç‰¹å¾çš„åç§°ï¼ŒType æ˜¯å®ç°å™¨ç»“æ„æˆ–æšä¸¾çš„åç§°ã€‚\nå®ç°äº†æŸç§ç‰¹æ€§ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥æŒ‰ç…§å¸¸è§„æ–¹æ³•è°ƒç”¨çš„æ–¹å¼æ¥ä½¿ç”¨ç‰¹æ€§é‡Œé¢å®šä¹‰çš„æ–¹æ³•ï¼š\n1 2 3 4 5 6 let rectangle = Rectangle { width: 10.0, height: 20.0, }; println!(\"Rectangle area: {}\", rectangle.area()); æ´¾ç”Ÿ è¿˜æœ‰ä¸€ç§æƒ…å†µï¼Œæ¯”å¦‚æˆ‘å®šä¹‰äº†ä¸‹é¢çš„ç±»å‹ï¼š\n1 2 3 4 struct Point { x: i32, y: i32, } Pointä¸­çš„æ‰€æœ‰æˆå‘˜éƒ½å·²ç»å®ç°äº†Copyç‰¹æ€§ï¼Œä½†æ˜¯Pointæœ¬èº«æ²¡æœ‰å®ç°Copyç‰¹æ€§ï¼Œæ‰€ä»¥é»˜è®¤æƒ…å†µä¸‹ï¼ŒPointè¿˜æ˜¯ä¼šè¢«ç§»åŠ¨ã€‚é‚£ä¹ˆè¿™ç§æƒ…å†µä¸‹å¦‚ä½•å¿«é€Ÿå®ç°Pointçš„Copyç‰¹æ€§å‘¢ï¼ŸRustæä¾›äº†deriveæ³¨è§£ï¼Œå¯ä»¥ä¸ºç±»å‹å¿«é€Ÿåœ°è‡ªåŠ¨ç”Ÿæˆæ–°ç‰¹æ€§ï¼š\n1 2 3 4 5 #[derive(Copy)] struct Point { x: i32, y: i32, } å¦‚æœä¸€ä¸ªç»“æ„çš„æ¯ä¸€ä¸ªå­—æ®µéƒ½å·²ç»å®ç°äº†æŸä¸ªç‰¹æ€§ï¼Œé‚£ä¹ˆä½¿ç”¨#[derive(trait)]å°±èƒ½å¤Ÿè‡ªåŠ¨åœ°ä¸ºæŸä¸ªç»“æ„å®ç°è¯¥ç‰¹æ€§ã€‚\nä½¿ç”¨ç‰¹æ€§ æœ‰äº†ç‰¹æ€§è¿™ä¹ˆä¸€ä¸ªå·¥å…·ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¦æ±‚æŸäº›å‡½æ•°çš„å‚æ•°å®ç°ç‰¹å®šçš„ç‰¹æ€§ã€‚æ¢å¥è¯è¯´ï¼Œåªè¦å®ç°æŸç‰¹æ€§çš„ç»“æ„éƒ½å¯ä»¥ä½œä¸ºè¯¥å‡½æ•°çš„å‚æ•°ã€‚æ¯”å¦‚æˆ‘ä»¬æœ‰å¦‚ä¸‹ç‰¹æ€§ï¼Œè¡¨æ˜å¯ä»¥è¢«è½¬æ¢ä¸ºjsonå­—ç¬¦ä¸²ï¼š\n1 2 3 trait AsJson { fn as_json(\u0026self) -\u003e String; } ç„¶åæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å¯ä»¥æŠŠä»»æ„å¯ä»¥è½¬æ¢ä¸ºjsonçš„ç±»å‹æ‰“å°å‡ºæ¥ï¼š\n1 2 3 fn print_data_as_json(value: \u0026impl AsJson) { println!(\"{}\", value.as_json()); } å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å£°æ˜æŸä¸ªç‰¹æ€§ä¸ºå‡½æ•°å‚æ•°ç±»å‹çš„æ—¶å€™ï¼Œå‰é¢éœ€è¦åŠ implï¼Œæ„æ€å°±æ˜¯è¿™é‡Œå®é™…ä¸Šæ˜¯è¿™ä¸ªç‰¹æ€§çš„å…·ä½“å®ç°è€…ã€‚\nå½“ç„¶ï¼Œé€šè¿‡æ³›å‹æˆ‘ä»¬ä¹Ÿå¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š\n1 fn print_data_as_json\u003cT: AsJson\u003e(value: \u0026T) { ... } è¿™é‡Œå°±è§„å®šäº†ä¸€ä¸ªæ³›å‹ç±»å‹ï¼Œè¿™ä¸ªæ³›å‹ç±»å‹éœ€è¦å®ç°AsJsonç‰¹æ€§æ‰èƒ½è¢«æ¥æ”¶ã€‚ä¸Šé¢çš„ä¸¤ç§å®ç°æ˜¯ç­‰ä»·çš„ã€‚\nå®ä¾‹ï¼šå®ç°ä¸€ä¸ªè¿­ä»£å™¨ Iteratoræ˜¯ä¸€ä¸ªRustè‡ªå¸¦çš„ç‰¹æ€§ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š\n1 2 3 4 trait Iterator { type Item; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e; } ä¸‹é¢æ˜¯ä¸€äº›è§£é‡Šï¼š\nIterator å…·æœ‰æ–¹æ³• nextï¼Œè°ƒç”¨æ—¶å®ƒå°†è¿”å› Option\u003cItem\u003eã€‚ åªè¦æœ‰å…ƒç´ ï¼Œnext æ–¹æ³•å°±ä¼šè¿”å› Some(Item)ã€‚ ç”¨å°½æ‰€æœ‰å…ƒç´ åï¼Œå®ƒå°†è¿”å› None ä»¥æŒ‡ç¤ºè¿­ä»£å·²å®Œæˆã€‚\næ­¤å®šä¹‰ä½¿ç”¨ä¸€äº›æ–°è¯­æ³•ï¼štype Item å’Œ Self::Itemï¼Œå®ƒä»¬ä½¿ç”¨æ­¤ç‰¹å¾å®šä¹‰å…³è”çš„ç±»å‹ã€‚ æ­¤å®šä¹‰æ„å‘³ç€ Iterator ç‰¹å¾çš„æ¯ä¸€æ¬¡å®ç°è¿˜éœ€è¦å®šä¹‰å…³è”çš„ Item ç±»å‹ï¼Œè¯¥ç±»å‹ç”¨ä½œ next æ–¹æ³•çš„è¿”å›ç±»å‹ã€‚ æ¢å¥è¯è¯´ï¼ŒItem ç±»å‹å°†æ˜¯ä» for å¾ªç¯å—å†…çš„è¿­ä»£å™¨è¿”å›çš„ç±»å‹ã€‚\nå‡è®¾æˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªCounterï¼Œç”¨ä½œè¿­ä»£å™¨ä¸”è¿›è¡Œè®¡æ•°ï¼Œé¦–å…ˆä¸‹é¢æ˜¯structçš„å£°æ˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #[derive(Debug)] // ç»§æ‰¿Rustè‡ªå¸¦çš„Debugç‰¹æ€§ struct Counter { length: usize, count: usize, } impl Counter { // Counteræœ‰ä¸€ä¸ªnewå‡½æ•°ï¼Œç”¨äºåˆå§‹åŒ–ä¸€ä¸ªæ–°çš„Counter fn new(length: usize) -\u003e Counter { Counter { count: 0, length, } } } ç„¶åï¼Œæˆ‘ä»¬å°±å®ç°Counterç»“æ„çš„Iteratorç‰¹å¾ã€‚æ­¤å¤„éœ€è¦ä½¿ç”¨impl Trait for Structæ ¼å¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 impl Iterator for Counter { type Item = usize; // æˆ‘ä»¬å°†é€šè¿‡ usize è¿›è¡Œè®¡æ•°ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å£°æ˜ç›¸å…³ Item ç±»å‹åº”ä¸ºè¯¥ç±»å‹ã€‚ // nextæ–¹æ³•æ˜¯å®ç°è¿­ä»£å™¨çš„å¿…é¡»æ–¹æ³• fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { self.count += 1; if self.count \u003c= self.length { Some(self.count) } else { None } } } åˆ°è¿™é‡Œæˆ‘ä»¬å°±ä¸ºCounterå®ç°äº†Iteratorç‰¹å¾ã€‚è¿˜è®°å¾—æˆ‘ä»¬å¯ä»¥å¯¹ä¸€ä¸ªIteratorä½¿ç”¨for item in Iteratorçš„è¯­æ³•å—ï¼Ÿè¿™é‡Œæˆ‘ä»¬å¯¹Counterä¹Ÿå¯ä»¥è¿™æ ·ç”¨äº†ï¼š\n1 2 3 4 5 fn main() { for number in Counter::new(10) { println!(\"{}\", number); } } ","description":"","tags":["rust"],"title":"Learning Rust - 3","uri":"/posts/engineering/learning-rust-3/"},{"categories":null,"content":"Learning Rust - 2 æ‰€æœ‰æƒå’Œå€Ÿç”¨ æ‰€æœ‰æƒï¼ˆownershipï¼‰ç³»ç»Ÿæ˜¯Rustæœ€ä¸ºä¸ä¼—ä¸åŒçš„ç‰¹æ€§ï¼Œå®ƒå¯ä»¥è®©Rustæ›´å¥½åœ°ç®¡ç†å†…å­˜ã€ä¿éšœå†…å­˜å®‰å…¨è€Œä¸éœ€è¦åƒåœ¾å›æ”¶ï¼ˆGCï¼‰\nä½œç”¨åŸŸ åœ¨Rustä¸­ï¼Œä½œç”¨åŸŸä½¿ç”¨å¤§æ‹¬å·{}è¡¨ç¤ºã€‚ä¸€ä¸ªä½œç”¨åŸŸå†…å®šä¹‰çš„å˜é‡åªåœ¨è¯¥ä½œç”¨åŸŸå†…æœ‰æ•ˆï¼š\n1 2 3 4 5 { let mascot = String::from(\"ferris\"); println!(\"{}\", mascot); // æœ‰æ•ˆ } println!(\"{}\", mascot); // ç¼–è¯‘é”™è¯¯ï¼mascotåªåœ¨ä¸Šé¢{}å†…çš„ä½œç”¨åŸŸæœ‰æ•ˆ æ¯å½“è¶…å‡ºå˜é‡çš„èŒƒå›´æ—¶ï¼Œå˜é‡åŠå…¶å¯¹åº”çš„å†…å­˜ä¼šè¢«é‡Šæ”¾ã€‚\næ‰€æœ‰æƒè½¬ç§» åœ¨å®šä¹‰ä¸€ä¸ªå˜é‡çš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯æŠŠä¸€ä¸ªæ•°æ®ç»‘å®šåœ¨ä¸€ä¸ªå˜é‡åä¸Šã€‚å¦‚let a = String::from(\"str\");ï¼Œå®é™…ä¸Šå°±æ˜¯æŠŠä¸€ä¸ªæ•´æ•°ç»‘å®šåœ¨å˜é‡åaä¸Šé¢ã€‚å› æ­¤ï¼Œåœ¨Rustä¸­ï¼Œå˜é‡ä¹Ÿè¢«ç§°ä¸ºâ€œç»‘å®šâ€ã€‚ç»‘å®šæœ‰æ—¶å€™ä¼šæ›´ä¸ºè´´åˆ‡ä¸€ç‚¹ï¼Œå› ä¸ºRustä¸­çš„å˜é‡ï¼Œé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼ˆè¿˜è®°å¾—mutå…³é”®å­—å—ï¼‰ã€‚\nå¯¹äºä¸€ä¸ªç»‘å®šæ¥è¯´ï¼Œå…¶æ•°æ®å°±æ˜¯ç”±è¢«ç»‘å®šåâ€œæ‹¥æœ‰â€çš„ï¼Œè¿™å°±æ˜¯Rustä¸­æ‰€æœ‰æƒçš„ç®€å•ç†è§£ã€‚å¦‚ä¸Šé¢let a = String::from(\"str\");;çš„ä¾‹å­ï¼Œå°±å¯ä»¥ç®€å•ç†è§£ä¸ºå˜é‡åaæ‹¥æœ‰æ•°æ®strã€‚\né‚£ä¹ˆï¼Œçœ‹ä¸‹é¢çš„è¯­å¥ï¼š\n1 let b = a; è¿™ä¸ªè¯­å¥å°±æ˜¯æŠŠaæ‰€æ‹¥æœ‰çš„æ•°æ®1è½¬ç§»ç»™äº†å˜é‡bï¼Œè¿™å°±å«æ‰€æœ‰æƒçš„è½¬ç§»ã€‚ä¹‹åï¼Œaå°±ä¸å†æ‹¥æœ‰æ•°æ®1äº†ï¼Œä¸‹é¢çš„ä»£ç å°†ä¼šæŠ¥é”™ï¼š\n1 2 3 let a = String::from(\"str\"); // æŠŠ str ç»‘å®šç»™ a let b = a; // æŠŠ a æ‹¥æœ‰çš„æ•°æ®è½¬ç§»ç»™äº† b println(\"{}\", a); // ç¼–è¯‘é”™è¯¯ï¼açš„å€¼å·²ç»è¢«ç§»èµ°äº† ç±»ä¼¼çš„äº‹æƒ…ä¹Ÿå‘ç”Ÿåœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn process(input: String) {} fn caller() { let s = String::from(\"Hello, world!\"); process(s); // Ownership of the string in `s` moved into `process` process(s); // Error! ownership already moved. } // æŠ¥é”™ä¿¡æ¯ error[E0382]: use of moved value: `s` --\u003e src/main.rs:6:13 | 4 | let s = String::from(\"Hello, world!\"); | - move occurs because `s` has type `String`, which does not implement the `Copy` trait 5 | process(s); // Transfers ownership of `s` to `process` | - value moved here 6 | process(s); // Error! ownership already transferred. | ^ value used here after move ç¬¬äºŒä¸ªprocess(s)å°†ä¼šæŠ¥é”™ã€‚\nåœ¨ Rust ä¸­ï¼Œæ‰€æœ‰æƒè½¬ç§»ï¼ˆå³ç§»åŠ¨ï¼‰æ˜¯é»˜è®¤è¡Œä¸ºã€‚æ­¤æ¨¡å¼å¯¹ç¼–å†™ Rust ä»£ç çš„æ–¹å¼æœ‰ç€æ·±è¿œçš„å½±å“ã€‚ å®ƒæ˜¯ Rust æå‡ºçš„å†…å­˜å®‰å…¨æ‰¿è¯ºçš„æ ¸å¿ƒã€‚\nå¤åˆ¶ é‚£ä¹ˆï¼Œå¦‚æœæˆ‘æƒ³å¤åˆ¶ä¸€ä¸ªå€¼è€Œä¸æ˜¯ç§»åŠ¨å®ƒå‘¢ï¼Ÿ\nä½ å¯èƒ½å·²ç»æ³¨æ„åˆ°ä¸Šé¢çš„æŠ¥é”™ä¿¡æ¯ï¼Œæœ‰æåˆ°ä¸€ä¸ªå«Copyçš„ç‰¹æ€§ï¼ˆtraitï¼‰ã€‚ç‰¹æ€§å¯ä»¥å¤§æ¦‚ç†è§£ä¸ºgolangé‡Œé¢çš„æ¥å£interfaceï¼Œåªè¦å®ç°äº†è¯¥ç‰¹æ€§é‚£ä¹ˆå°±èƒ½åœ¨ç›¸åº”çš„åœ°æ–¹ä½¿ç”¨ã€‚åœ¨è¿™é‡Œï¼Œå¦‚æœä¸€ä¸ªå¯¹è±¡å®ç°äº†Copyç‰¹æ€§ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šè¢«å¤åˆ¶è€Œä¸æ˜¯è¢«ç§»åŠ¨ã€‚ä¾‹å­å°±æ˜¯u32ç±»å‹ï¼Œu32ç±»å‹é»˜è®¤å·²ç»å®ç°äº†Copyçš„ç‰¹æ€§ï¼Œå› æ­¤ï¼Œä¸‹é¢çš„ä»£ç ä¸ä¼šæŠ¥é”™ï¼š\n1 2 3 4 5 6 7 fn process(input: u32) {} fn caller() { let s = 1u32; process(s); // Ownership of the number in `n` copied into `process` process(s); // `n` can be used again because it wasn't moved, it was copied. } æ˜¾å¼å…‹éš† è¿˜æœ‰ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œæ˜¾å¼åœ°å¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œè¿™æ ·å¤åˆ¶å‡ºæ¥çš„æ•°æ®è¢«ç§»åŠ¨ï¼Œæ—§çš„å€¼è¿˜åœ¨ã€‚è¿™ä¸ªæ—¶å€™è°ƒç”¨.clone()å‡½æ•°å³å¯ï¼š\n1 2 3 4 5 6 7 fn process(s: String) {} fn main() { let s = String::from(\"Hello, world!\"); process(s.clone()); // Passing another value, cloned from `s`. process(s); // s was never moved and so it can still be used. } ä½†æ˜¯ï¼Œæ¯æ¬¡æ˜¾å¼å…‹éš†éƒ½éœ€è¦å®Œæ•´å¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œé€Ÿåº¦ä¼šå¾ˆæ…¢ï¼Œè€Œä¸”æµªè´¹å†…å­˜\næœ‰æ²¡æœ‰æ›´ä¼˜é›…çš„åŠæ³•å‘¢ï¼Ÿ ç­”æ¡ˆè‚¯å®šæ˜¯æœ‰çš„ï¼Œè¿™å°±æ¶‰åŠåˆ°Rustä¸­å¦å¤–ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µï¼šå€Ÿç”¨ï¼ˆborrowï¼‰\nå€Ÿç”¨ å€Ÿç”¨çš„æ„æ€ä¹Ÿå¾ˆç›´æ¥ï¼šæ‰€æœ‰æƒè¿˜æ˜¯ä½ çš„ï¼Œæˆ‘å°±å€Ÿè¿‡æ¥ç”¨ä¸€ä¸‹ã€‚åœ¨Rustä¸­ï¼Œå€Ÿç”¨æ˜¯é€šè¿‡å¼•ç”¨æä¾›çš„ï¼š\n1 2 3 let greeting = String::from(\"hello\"); let greeting_reference = \u0026greeting; // We borrow `greeting` but the string data is still owned by `greeting` println!(\"Greeting: {}\", greeting); // We can still use `greeting` å’ŒC++çš„å¼•ç”¨ä¸€æ ·ï¼Œå‰é¢åŠ ä¸ª\u0026å³è¡¨ç¤ºæ˜¯è¯¥å˜é‡çš„å¼•ç”¨ã€‚\nåœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ \u0026 å€Ÿç”¨äº† greetingã€‚ greeting_reference çš„ç±»å‹ä¸º \u0026Stringã€‚ ç”±äºæˆ‘ä»¬åªå€Ÿç”¨äº† greetingï¼Œå¹¶æ²¡æœ‰ç§»åŠ¨æ‰€æœ‰æƒï¼Œå› æ­¤ï¼Œåœ¨æˆ‘ä»¬åˆ›å»º greeting_reference ä¹‹åä»ç„¶å¯ä»¥ä½¿ç”¨ greetingã€‚\næ—¢ç„¶æ˜¯å€Ÿç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ§åˆ¶ä½¿ç”¨è€…å¦‚ä½•ä½¿ç”¨ï¼š\nå¦‚æœæˆ‘ä»¬ä¸æƒ³ä½¿ç”¨è€…ä¿®æ”¹å€¼ï¼Œé‚£ä¹ˆå°±ä¼ ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œå³\u0026T å¦‚æœå…è®¸ä½¿ç”¨è€…ä¿®æ”¹ï¼Œé‚£ä¹ˆä¼ ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå³\u0026mut T å¯¹äºä¸€ä¸ªå˜é‡æ¥è¯´ï¼Œåªèƒ½æœ‰ä¸€ç§ç±»å‹çš„å¼•ç”¨ï¼ˆå¯å˜æˆ–ä¸å¯å˜ï¼‰ã€‚å¯¹äºä¸å¯å˜å¼•ç”¨æ¥è¯´ï¼Œå¤šå°‘éƒ½è¡Œï¼›ä½†æ˜¯å˜é‡çš„åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚\nå¦‚ä½•ç†è§£å‘¢ï¼Ÿå‡è®¾æˆ‘æŠŠå˜é‡å€Ÿç”¨å‡ºå»ï¼Œå¦‚æœæˆ‘ä¸å…è®¸ä½¿ç”¨è€…ä¿®æ”¹ï¼Œé‚£ä¹ˆæˆ‘å€Ÿç»™å¤šå°‘äººéƒ½æ— æ‰€è°“ï¼Œåæ­£ä¸ä¼šå˜ï¼›å¦‚æœæˆ‘å…è®¸ä½¿ç”¨è€…ä¿®æ”¹ï¼Œé‚£ä¹ˆåœ¨åŒä¸€æ—¶åˆ»æˆ‘åªèƒ½å€Ÿç»™ä¸€ä¸ªäººï¼Œå¦åˆ™ä¸€ä¸ªå˜é‡å¯èƒ½ä¼šè¢«å¤šä¸ªä½¿ç”¨è€…åœ¨ä¸åŒåœ°æ–¹åŒæ—¶ä¿®æ”¹ï¼Œä¼šå‡ºé—®é¢˜ã€‚\nè¿™ä¹Ÿæ˜¯å…¶ä»–è¯­è¨€ç»å¸¸ä¼šäº§ç”Ÿbugçš„åœ°æ–¹ï¼šæŸä¸ªå˜é‡åœ¨æ„æƒ³ä¸åˆ°çš„åœ°æ–¹è¢«ä¿®æ”¹äº†ï¼Œä½†æ˜¯æˆ‘ä¸çŸ¥é“ï¼Œè¿˜æŒ‰ç…§æ²¡æœ‰è¢«ä¿®æ”¹çš„æƒ…å†µä½¿ç”¨ã€‚Ruståœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ï¼šä¸æƒ³è®©ä½ æ”¹ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨ä¸å¯å˜å¼•ç”¨ã€‚\nç”Ÿå‘½å‘¨æœŸ ä½¿ç”¨å¼•ç”¨è¿˜ä¼šå‡ºç°å¦å¤–ä¸€ä¸ªé—®é¢˜ï¼šå¼•ç”¨çš„é¡¹å¦‚æœè¢«é‡Šæ”¾äº†ï¼Œé‚£ä¹ˆæˆ‘è¿™ä¸ªå¼•ç”¨å°±æŒ‡å‘äº†ä¸€å—æ— æ•ˆçš„å†…å­˜ï¼Œè¿™å°±æ˜¯æ‚¬å‚æŒ‡é’ˆã€‚\n1 2 3 4 5 6 7 8 fn main() { let x; { let y = 42; x = \u0026y; // We store a reference to `y` in `x` but `y` is about to be dropped. } println!(\"x: {}\", x); // `x` refers to `y` but `y has been dropped! } C/C++ç»å¸¸ä¼šé‡åˆ°è¿™ç§é—®é¢˜ï¼Œä½†æ˜¯Rusté€šè¿‡ç”Ÿå‘½å‘¨æœŸä¿è¯äº†æ‰€æœ‰å¼•ç”¨éƒ½å§‹ç»ˆå¼•ç”¨æœ‰æ•ˆçš„é¡¹ã€‚ä¸Šé¢çš„ä»£ç ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œå› ä¸ºyåœ¨å…¶ä½œç”¨åŸŸç»“æŸæ—¶å·²ç»è¢«é‡Šæ”¾ã€‚ç”¨'aå’Œ'båˆ†åˆ«è¡¨ç¤ºxå’Œyçš„ç”Ÿå‘½å‘¨æœŸï¼Œå¯ä»¥çœ‹åˆ°xæ´»å¾—æ›´ä¹…ï¼Œç”Ÿå‘½å‘¨æœŸæ›´é•¿ï¼š\n1 2 3 4 5 6 7 8 fn main() { let x; // -------------------+--'aï¼šxçš„ç”Ÿå‘½å‘¨æœŸ { // | let y = 42; // -+-- 'bï¼šyçš„ç”Ÿå‘½å‘¨æœŸ | x = \u0026y; // | | } // -+ | println!(\"x: {}\", x); // | } å‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ å¤§éƒ¨åˆ†æ—¶å€™ç”Ÿå‘½å‘¨æœŸæ˜¯éšå«å¹¶å¯ä»¥æ¨æ–­çš„ï¼Œä½†æ˜¯æœ‰æ—¶å€™ç¼–è¯‘å™¨æ¨æ–­ä¸äº†ï¼Œæ¯”å¦‚ä¸‹é¢çš„è¿™ä¸ªå‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 // æ— æ³•ç¼–è¯‘é€šè¿‡ fn longest_word(x: \u0026String, y: \u0026String) -\u003e \u0026String { if x.len() \u003e y.len() { x } else { y } } ç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸï¼Œæˆ‘ä»¬ä¹Ÿä¸èƒ½ç¡®å®šï¼Œå› ä¸ºæ ¹æ®è¾“å…¥çš„å€¼ï¼Œxã€yå‡æœ‰å¯èƒ½ã€‚å¯¹äºè¿™ç§å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œæ¥æ˜¾å¼åœ°å£°æ˜è¿”å›å€¼å’Œå‡½æ•°å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»ï¼š\n1 2 3 fn longest_word\u003c'a\u003e(x: \u0026'a String, y: \u0026'a String) -\u003e \u0026'a String { ... } å…¶ä¸­ï¼Œ'aå°±æ˜¯ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œå…¶åç§°æ— æ‰€è°“ï¼Œ'bï¼Œ'xyzéƒ½è¡Œï¼Œåªéœ€è¦ä¿è¯å‡½æ•°å‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ä¸€æ ·å³å¯ã€‚å‡½æ•°åé¢\u003c'a\u003eçš„æ„æ€æ˜¯è¯¥å‡½æ•°å­˜åœ¨ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œåç§°ä¸º'aã€‚åé¢å¸¦'açš„å‚æ•°è¯´æ˜è¿™äº›å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸå’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³ã€‚\nä¸Šé¢ä»£ç çš„æ„æ€å°±æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œlongest_wordè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸï¼Œå’Œxã€yè¿™ä¸¤ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸæœ‰å…³ã€‚è¿™æ ·ï¼ŒRustç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼Œå°±ä¼šè‡ªåŠ¨å–æœ‰æ³¨è§£çš„å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸä¸­è¾ƒçŸ­çš„é‚£ä¸ªä½œä¸ºè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™æ ·ï¼Œå°±å¯ä»¥æ£€æŸ¥å‡ºä¸‹é¢çš„é”™è¯¯ï¼š\n1 2 3 4 5 6 7 8 9 10 // ç¼–è¯‘ä¸é€šè¿‡ fn main() { let magic1 = String::from(\"a!\"); let result; { let magic2 = String::from(\"shazam!\"); result = longest_word(\u0026magic1, \u0026magic2); // resultå¯èƒ½æ˜¯ magic2 } // magic2è¢«é‡Šæ”¾ println!(\"The longest magic word is {}\", result); // é¿å…äº†æ­¤å¤„å¯èƒ½å­˜åœ¨çš„æ‚¬å‚æŒ‡é’ˆ } ç»“æ„æˆ–æšä¸¾ä¸­çš„ç”Ÿå‘½å‘¨æœŸ å¦‚æœä¸€ä¸ªstructæˆ–ä¸€ä¸ªæšä¸¾åŒ…å«å¼•ç”¨ç±»å‹çš„å­—æ®µï¼Œé‚£ä¹ˆå®ƒä¹Ÿéœ€è¦åƒå‡½æ•°ä¸€æ ·æ˜¾å¼åœ°æ ‡è®°ç”Ÿå‘½å‘¨æœŸï¼š\n1 2 struct Highlight(\u0026str); // é”™è¯¯ struct Highlight\u003c'a\u003e(\u0026'a str); // æ­£ç¡® è¿™é‡Œï¼Œ'aå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªæé†’ï¼Œæé†’ Highlight ç»“æ„çš„ç”Ÿå­˜æœŸä¸èƒ½è¶…è¿‡å®ƒå€Ÿç”¨çš„ \u0026str çš„ç”Ÿå­˜æœŸã€‚ä¸‹é¢çš„ä»£ç å¯ä»¥è§£é‡Šä¸€ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #[derive(Debug)] struct Highlight\u003c'document\u003e(\u0026'document str); fn erase(_: String) { } fn main() { let text = String::from(\"The quick brown fox jumps over the lazy dog.\"); let fox = Highlight(\u0026text[4..19]); let dog = Highlight(\u0026text[35..43]); let moved_text = text; // ç¼–è¯‘ä¸é€šè¿‡ï¼Œä¸èƒ½æŠŠ text ç§»èµ°ï¼Œå› ä¸º Highlightç±»å‹çš„å¯¹è±¡ï¼ˆfox,dogï¼‰è¿˜åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†… println!(\"{:?}\", fox); println!(\"{:?}\", dog); } ","description":"","tags":["rust"],"title":"Learning Rust - 2","uri":"/posts/engineering/learning-rust-2/"},{"categories":null,"content":"Learning Rust - 1 å­¦ä¹ å¾®è½¯Rustæ•™ç¨‹çš„ç¬”è®°ã€‚\nRustçš„ç‰¹ç‚¹ Rust æ˜¯ç°æœ‰ç³»ç»Ÿè½¯ä»¶è¯­è¨€ï¼ˆå¦‚ C å’Œ C++ï¼‰çš„ä¸€ç§å®‰å…¨æ›¿ä»£è¯­è¨€ã€‚ ä¸ C å’Œ C++ ä¸€æ ·ï¼ŒRust æ²¡æœ‰å¤§å‹è¿è¡Œæ—¶æˆ–åƒåœ¾å›æ”¶å™¨ï¼Œè¿™å‡ ä¹ä¸æ‰€æœ‰å…¶ä»–ç°ä»£è¯­è¨€å½¢æˆäº†é²œæ˜å¯¹æ¯”ã€‚ ä½†æ˜¯ï¼Œä¸ C å’Œ C++ ä¸åŒçš„æ˜¯ï¼ŒRust ä¿è¯äº†å†…å­˜å®‰å…¨ã€‚ Rust å¯ä»¥é¿å…å¾ˆå¤šä¸åœ¨ C å’Œ C++ ä¸­é‡åˆ°çš„å†…å­˜ä½¿ç”¨é”™è¯¯ç›¸å…³çš„ bugã€‚\nRust æœ‰ä»¥ä¸‹ä¼˜ç‚¹ï¼Œéå¸¸é€‚åˆå„ç§åº”ç”¨ç¨‹åºï¼š\nç±»å‹å®‰å…¨ï¼šç¼–è¯‘å™¨å¯ç¡®ä¿ä¸ä¼šå°†ä»»ä½•æ“ä½œåº”ç”¨äºé”™è¯¯ç±»å‹çš„å˜é‡ã€‚ å†…å­˜å®‰å…¨ï¼šRust æŒ‡é’ˆï¼ˆç§°ä¸ºâ€œå¼•ç”¨â€ï¼‰å§‹ç»ˆå¼•ç”¨æœ‰æ•ˆçš„å†…å­˜ã€‚ æ— æ•°æ®äº‰ç”¨ï¼šRust çš„ borrow æ£€æŸ¥å™¨é€šè¿‡ç¡®ä¿ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†ä¸èƒ½åŒæ—¶æ›´æ”¹åŒä¸€å€¼æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚ é›¶æˆæœ¬æŠ½è±¡ï¼šRust å…è®¸ä½¿ç”¨é«˜çº§åˆ«æ¦‚å¿µï¼Œä¾‹å¦‚è¿­ä»£ã€æ¥å£å’Œå‡½æ•°ç¼–ç¨‹ï¼Œå°†æ€§èƒ½æˆæœ¬æ§åˆ¶åœ¨æœ€ä½ï¼Œç”šè‡³ä¸ä¼šäº§ç”Ÿæˆæœ¬ã€‚ è¿™äº›æŠ½è±¡çš„æ€§èƒ½ä¸æ‰‹å·¥ç¼–å†™çš„åº•å±‚ä»£ç ä¸€æ ·å‡ºè‰²ã€‚ æœ€å°è¿è¡Œæ—¶ï¼šRust å…·æœ‰éå¸¸å°çš„å¯é€‰è¿è¡Œæ—¶ã€‚ ä¸ºäº†æœ‰æ•ˆåœ°ç®¡ç†å†…å­˜ï¼Œæ­¤è¯­è¨€ä¹Ÿä¸å…·æœ‰åƒåœ¾å›æ”¶å™¨ã€‚ åœ¨è¿™ä¸€ç‚¹ä¸Šï¼ŒRust éå¸¸ç±»ä¼¼äº C å’Œ C++ ä¹‹ç±»çš„è¯­è¨€ã€‚ é¢å‘è£¸æœºï¼šRust å¯ä»¥ç”¨äºåµŒå…¥å¼å’Œâ€œè£¸æœºâ€ç¼–ç¨‹ï¼Œå› æ­¤é€‚åˆç”¨äºç¼–å†™æ“ä½œç³»ç»Ÿå†…æ ¸æˆ–è®¾å¤‡é©±åŠ¨ç¨‹åºã€‚ äº†è§£Cargo Cargoæ˜¯Rustè¯­è¨€çš„ç”Ÿæˆå·¥å…·å’Œä¾èµ–ç®¡ç†å™¨ï¼ŒCargoä¸ºç®¡ç†Rustç¨‹åºå¸¦æ¥äº†å¾ˆå¤šä¾¿åˆ©ã€‚\nCargo å¯ä»¥ä¸ºä½ åšè®¸å¤šäº‹æƒ…ï¼ŒåŒ…æ‹¬ï¼š\nä½¿ç”¨ cargo new å‘½ä»¤åˆ›å»ºæ–°çš„é¡¹ç›®æ¨¡æ¿ã€‚ ä½¿ç”¨ cargo build ç¼–è¯‘é¡¹ç›®ã€‚ ä½¿ç”¨ cargo run å‘½ä»¤ç¼–è¯‘å¹¶è¿è¡Œé¡¹ç›®ã€‚ ä½¿ç”¨ cargo test å‘½ä»¤æµ‹è¯•é¡¹ç›®ã€‚ ä½¿ç”¨ cargo check å‘½ä»¤æ£€æŸ¥é¡¹ç›®ç±»å‹ã€‚ ä½¿ç”¨ cargo doc å‘½ä»¤ç¼–è¯‘é¡¹ç›®çš„æ–‡æ¡£ã€‚ ä½¿ç”¨ cargo publish å‘½ä»¤å°†åº“å‘å¸ƒåˆ° crates.ioã€‚ å°è¯•Cargo é¦–å…ˆä½¿ç”¨Cargoåˆ›å»ºä¸€ä¸ªæ–°çš„Rustå·¥ç¨‹ï¼š\n1 cargo init \u003cproject-name\u003e åˆ›å»ºå®Œå·¥ç¨‹ä¹‹åï¼Œä½¿ç”¨VSCodeæ‰“å¼€åˆšæ‰åˆ›å»ºçš„æ–‡ä»¶å¤¹ï¼Œå¯ä»¥çœ‹åˆ°cargoå·²ç»è‡ªåŠ¨ä¸ºä½ ç”Ÿæˆäº†cargo.tomlå’Œsrc/main.rsä¸¤ä¸ªæ–‡ä»¶ã€‚\nCargo.toml æ˜¯ Rust ä»£ç åº“çš„é…ç½®æ–‡ä»¶ï¼Œç”¨äºç®¡ç†ä¾èµ–ç‰ˆæœ¬ç­‰ã€‚å¦‚æœä½ æœ‰å…¶ä»–è¯­è¨€çš„ç»éªŒï¼Œå¯ä»¥ç±»æ¯”package.jsonæˆ–è€…go.modç­‰ src å­ç›®å½•ä¸­çš„ main.rs æ–‡ä»¶ä¸ºå½“å‰å·¥ç¨‹çš„ä¸»å…¥å£æ–‡ä»¶ï¼Œé‡Œé¢çš„fn main()å³ä¸ºä¸»å…¥å£å‡½æ•° cargo initç”Ÿæˆçš„å·¥ç¨‹æ˜¯ä¸€ä¸ªå¯è¿è¡Œçš„Rustçš„HelloWorldå·¥ç¨‹ã€‚ä¸‹é¢è¿˜æœ‰ä¸€äº›å‘½ä»¤å¯ä»¥å°è¯•ï¼š\nè¿è¡Œå½“å‰å·¥ç¨‹ï¼š\n1 cargo run ç¼–è¯‘å½“å‰å·¥ç¨‹ï¼š\n1 cargo build ç¼–è¯‘å½“å‰å·¥ç¨‹ï¼ˆå‘å¸ƒä½¿ç”¨ï¼‰ï¼š\n1 cargo build --release ç¼–è¯‘å®Œæˆä¹‹åï¼Œä½ å¯ä»¥åœ¨target/debugå’Œtarget/releaseç›®å½•ä¸‹çœ‹åˆ°ç¼–è¯‘å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚\nè¯­è¨€åŸºç¡€ å˜é‡ å£°æ˜å˜é‡ ä½¿ç”¨å…³é”®å­—let\n1 2 3 4 5 6 7 8 9 10 11 // Declare a variable let a_number; // Declare a second variable and bind the value let a_word = \"Ten\"; // Bind a value to the first variable a_number = 10; println!(\"The number is {}.\", a_number); println!(\"The word is {}.\", a_word); å˜é‡çš„å¯å˜æ€§ å’Œä¸€èˆ¬çš„è¯­è¨€ä¸ä¸€æ ·ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼ŒRustçš„å˜é‡æ˜¯ä¸å¯å˜çš„ï¼š\n1 2 let a_number = 10; a_number = 15; // æ­¤è¡ŒæŠ¥é”™ï¼ å¦‚æœæƒ³è¦å˜é‡å¯å˜ï¼Œé‚£ä¹ˆéœ€è¦ä½¿ç”¨å…³é”®å­—mut:\n1 2 let mut a_number = 10; a_number = 15; // å¯ä»¥ ä¸ºä»€ä¹ˆè¦é»˜è®¤å˜é‡æ˜¯ä¸å¯å˜çš„å‘¢ï¼Ÿã€ŠThe Rust Programming Languageã€‹æœ‰å¦‚ä¸‹è§£é‡Šï¼š\nå¦‚æœä¸€éƒ¨åˆ†ä»£ç å‡è®¾ä¸€ä¸ªå€¼æ°¸è¿œä¹Ÿä¸ä¼šæ”¹å˜ï¼Œè€Œå¦ä¸€éƒ¨åˆ†ä»£ç æ”¹å˜äº†è¿™ä¸ªå€¼ï¼Œç¬¬ä¸€éƒ¨åˆ†ä»£ç å°±æœ‰å¯èƒ½ä»¥ä¸å¯é¢„æ–™çš„æ–¹å¼è¿è¡Œã€‚ä¸å¾—ä¸æ‰¿è®¤è¿™ç§ bug çš„èµ·å› éš¾ä»¥è·Ÿè¸ªï¼Œå°¤å…¶æ˜¯ç¬¬äºŒéƒ¨åˆ†ä»£ç åªæ˜¯ æœ‰æ—¶ ä¼šæ”¹å˜å€¼ã€‚\nRust ç¼–è¯‘å™¨ä¿è¯ï¼Œå¦‚æœå£°æ˜ä¸€ä¸ªå€¼ä¸ä¼šå˜ï¼Œå®ƒå°±çœŸçš„ä¸ä¼šå˜ã€‚è¿™æ„å‘³ç€å½“é˜…è¯»å’Œç¼–å†™ä»£ç æ—¶ï¼Œä¸éœ€è¦è¿½è¸ªä¸€ä¸ªå€¼å¦‚ä½•å’Œåœ¨å“ªå¯èƒ½ä¼šè¢«æ”¹å˜ï¼Œä»è€Œä½¿å¾—ä»£ç æ˜“äºæ¨å¯¼ã€‚\nä¸è¿‡å¯å˜æ€§ä¹Ÿæ˜¯éå¸¸æœ‰ç”¨çš„ã€‚å˜é‡åªæ˜¯é»˜è®¤ä¸å¯å˜ï¼›æ­£å¦‚åœ¨ç¬¬äºŒç« æ‰€åšçš„é‚£æ ·ï¼Œä½ å¯ä»¥åœ¨å˜é‡åä¹‹å‰åŠ  mut æ¥ä½¿å…¶å¯å˜ã€‚é™¤äº†å…è®¸æ”¹å˜å€¼ä¹‹å¤–ï¼Œmut å‘è¯»è€…è¡¨æ˜äº†å…¶ä»–ä»£ç å°†ä¼šæ”¹å˜è¿™ä¸ªå˜é‡å€¼çš„æ„å›¾ã€‚\n-- å˜é‡ä¸å¯å˜æ€§ - Rust ç¨‹åºè®¾è®¡è¯­è¨€\nä¸å¯å˜å˜é‡å’Œå¸¸é‡çš„åŒºåˆ«ï¼š å˜é‡ä¸å¯å˜æ€§ - Rust ç¨‹åºè®¾è®¡è¯­è¨€\næ€»ç»“ä¸€ä¸‹ï¼š\nä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨ mutã€‚å¸¸é‡ä¸å…‰é»˜è®¤ä¸èƒ½å˜ï¼Œå®ƒæ€»æ˜¯ä¸èƒ½å˜ã€‚ å£°æ˜å¸¸é‡ä½¿ç”¨ const å…³é”®å­—è€Œä¸æ˜¯ letï¼Œå¹¶ä¸” å¿…é¡» æ³¨æ˜å€¼çš„ç±»å‹ å¸¸é‡åªèƒ½è¢«è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œè€Œä¸èƒ½æ˜¯å‡½æ•°è°ƒç”¨çš„ç»“æœï¼Œæˆ–ä»»ä½•å…¶ä»–åªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—å‡ºçš„å€¼ å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸä¸­å£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸ å˜é‡éšè— å¯ä»¥é‡å¤ä½¿ç”¨letå£°æ˜åŒåçš„å˜é‡ï¼Œè¿™æ ·çš„è¯å˜é‡åä¼šè¢«ç»‘å®šåœ¨æ–°çš„å€¼ä¸Šé¢ï¼Œæ—§çš„å˜é‡å°±è¢«â€œéšè—â€äº†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ—§å˜é‡ä»ç„¶å­˜åœ¨ã€‚\n1 let a_number = 10;let a_number = 15; // éšè—ä¸Šé¢çš„å˜é‡ï¼Œä½†æ˜¯ä¸Šé¢çš„å˜é‡ä¸ä¼šè¢«åˆ é™¤ï¼Œä»å­˜åœ¨äºå†…å­˜ä¸­println!(\"{}\", a_number); // 15 æ•°æ®ç±»å‹ Rustæ˜¯é™æ€ç±»å‹è¯­è¨€ã€‚åœ¨å£°æ˜å˜é‡æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­å˜é‡ç±»å‹ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥ä½¿ç”¨:ï¼ˆç±»ä¼¼typescriptï¼‰æ‰‹åŠ¨æŒ‡å®šå˜é‡ç±»å‹ï¼š\n1 let number1 = 15; // é»˜è®¤æ˜¯i32ç±»å‹let number2: i64 = 15; // æ‰‹åŠ¨å£°æ˜i64æ•´å‹ æ•°å­—ç±»å‹ åˆ†ä¸ºæ•´æ•°ã€æµ®ç‚¹æ•°ã€‚å…·ä½“è¡¨è§ï¼šæ•°æ®ç±»å‹ - Rust ç¨‹åºè®¾è®¡è¯­è¨€\né»˜è®¤çš„æ•´å‹å’Œæµ®ç‚¹æ•°ç±»å‹ä¸ºï¼ši32å’Œf64\nå¸ƒå°”ç±»å‹ true or false\nå­—ç¬¦ å­—ç¬¦ç±»å‹ä¸ºcharï¼Œä½¿ç”¨å•å¼•å·æ‹¬ä½ï¼š\n1 let s = 's';let emoji = 'ğŸ˜ƒ'; å­—ç¬¦ä¸² Rustä¸­ï¼Œæœ‰å¥½å‡ ç§å­—ç¬¦ä¸²ç±»å‹ï¼š\u0026strï¼ˆå­—ç¬¦ä¸²å¼•ç”¨ï¼‰, Stringï¼ˆå †ä¸Šå­—ç¬¦ä¸²ï¼‰ç­‰ã€‚å…·ä½“ä½¿ç”¨è¿˜æ˜¯æœ‰åŒºåˆ«çš„ã€‚å¯ä»¥å‚è€ƒï¼šå­—ç¬¦ä¸² - Rust ç¨‹åºè®¾è®¡è¯­è¨€ã€‚ç°åœ¨ï¼Œå¯ä»¥å…ˆç®€å•åœ°è®¤ä¸º String æ˜¯å¯éšç¨‹åºè¿è¡Œè€Œæ›´æ”¹çš„æ–‡æœ¬æ•°æ®ã€‚ \u0026str å¼•ç”¨æ˜¯æ–‡æœ¬æ•°æ®çš„ä¸å¯å˜è§†å›¾ï¼Œä¸ä¼šéšç€ç¨‹åºè¿è¡Œè€Œæ”¹å˜ã€‚\nå…ƒç»„tuple å…ƒç»„æ˜¯å›ºå®šé•¿åº¦çš„åˆ†ç»„ï¼Œä½¿ç”¨(\u003cvalue1\u003e, \u003cvalue2\u003e, ...)è¡¨ç¤ºã€‚æ¯ä¸ªvalueçš„ç±»å‹å¯ä»¥ä¸ä¸€æ ·ã€‚è·å–å…ƒç»„ä¸­çš„å…ƒç´ ï¼Œå¯ä½¿ç”¨tuple.index\n1 // Declare a tuple of three elementslet tuple_e: (char, i32, bool) = ('E', 5i32, true);// Use tuple indexing and show the values of the elements in the tupleprintln!(\"Is '{}' the {}th letter of the alphabet? {}\", tuple_e.0, tuple_e.1, tuple_e.2); æ§åˆ¶æµ if else è¯­æ³•å¾ˆç®€å•ï¼š\n1 if condition { } else if another_condition { } else { } ç”¨çš„æ—¶å€™ï¼Œifelseå—è¿˜å¯ä»¥å……å½“è¡¨è¾¾å¼ï¼š\n1 let formal = true;let greeting = if formal { // if used here as an expression \"Good day to you.\" // æ³¨æ„ï¼Œæ­¤å¤„æ²¡æœ‰åˆ†å·ç»“å°¾ï¼Œå³ \"Good day to you.\" ä¸ºè¿™ä¸ªifå—çš„è¿”å›å€¼} else { \"Hey!\" // è¿”å› â€œHey!\"};println!(\"{}\", greeting) // prints \"Good day to you.\" å¤æ‚æ•°æ®ç»“æ„ ç»“æ„ä½“ ä½¿ç”¨å…³é”®å­—structå®šä¹‰ï¼Œç»“æ„ç±»å‹åç§°é‡‡ç”¨å¤§å†™å½¢å¼ã€‚\nRust æ”¯æŒä¸‰ç§ç»“æ„ç±»å‹ï¼šç»å…¸ç»“æ„ã€å…ƒç»„ç»“æ„å’Œå•å…ƒç»“æ„ã€‚ è¿™äº›ç»“æ„ç±»å‹æ”¯æŒä½¿ç”¨å„ç§æ–¹å¼å¯¹æ•°æ®è¿›è¡Œåˆ†ç»„å’Œå¤„ç†ã€‚\nâ€œç»å…¸ C ç»“æ„â€æœ€ä¸ºå¸¸ç”¨ã€‚ ç»“æ„ä¸­çš„æ¯ä¸ªå­—æ®µéƒ½å…·æœ‰åç§°å’Œæ•°æ®ç±»å‹ã€‚ å®šä¹‰ç»å…¸ç»“æ„åï¼Œå¯ä»¥ä½¿ç”¨è¯­æ³• \u003cstruct\u003e.\u003cfield\u003e è®¿é—®ç»“æ„ä¸­çš„å­—æ®µã€‚ å…ƒç»„ç»“æ„ç±»ä¼¼äºç»å…¸ç»“æ„ï¼Œä½†å­—æ®µæ²¡æœ‰åç§°ã€‚ è¦è®¿é—®å…ƒç»„ç»“æ„ä¸­çš„å­—æ®µï¼Œè¯·ä½¿ç”¨ç´¢å¼•å…ƒç»„æ—¶æ‰€ç”¨çš„è¯­æ³•ï¼š\u003ctuple\u003e.\u003cindex\u003eã€‚ ä¸å…ƒç»„ä¸€æ ·ï¼Œå…ƒç»„ç»“æ„ä¸­çš„ç´¢å¼•å€¼ä» 0 å¼€å§‹ã€‚ â€œå•å…ƒç»“æ„â€æœ€å¸¸ç”¨ä½œæ ‡è®°ã€‚ æˆ‘ä»¬å°†åœ¨äº†è§£ Rust çš„ç‰¹å¾åŠŸèƒ½æ—¶ï¼Œå°†æ·±å…¥äº†è§£å•å…ƒç»“æ„ä¹‹æ‰€ä»¥å®ç”¨çš„åŸå› ã€‚ ä»¥ä¸‹ä»£ç æ˜¾ç¤ºä¸‰ç§ç»“æ„ç±»å‹å˜ä½“çš„ç¤ºä¾‹å®šä¹‰ï¼š\n1 2 3 4 5 6 7 8 // Classic struct with named fields struct Student { name: String, level: u8, pass: bool } // Tuple struct with data types only struct Grades(char, char, char, char, f32); // Unit struct struct Unit; ç»“æ„ä½“å®ä¾‹åŒ–ï¼š\n1 2 3 4 5 6 7 // Instantiate classic struct, specify fields in random order, or in specified order let user_1 = Student { name: String::from(\"Constance Sharma\"), remote: true, level: 2 }; let user_2 = Student { name: String::from(\"Dyson Tan\"), level: 5, remote: false }; // Instantiate tuple structs, pass values in same order as types defined let mark_1 = Grades('A', 'A', 'B', 'A', 3.75); let mark_2 = Grades('B', 'A', 'A', 'C', 3.25); å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºç»“æ„ä½“å®šä¹‰æˆå‘˜å‡½æ•°ï¼Œä½¿ç”¨implå…³é”®å­—å³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 // Classic struct with named fields struct Student { name: String, level: u8, pass: bool } impl Student { fn get_name(\u0026self) -\u003e \u0026String { return \u0026self.name; } } fn main() { let s = Student{name: \"n\".to_string(), level:1, pass:true}; println!(\"{}\", s.get_name()); } æšä¸¾ å…³é”®å­—enumã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒRustçš„æšä¸¾ä¸­ï¼Œæ¯ä¸ªå€¼å¯ä»¥æœ‰ä¸åŒçš„ç±»å‹ã€‚è¿™æ ·çš„è¯ï¼Œåœ¨ä½¿ç”¨æŸä¸ªæšä¸¾ç±»å‹æ—¶ï¼Œå¿…é¡»æ¥å—å…¶ä¸‹é¢æ‰€æœ‰å€¼çš„ç±»å‹ï¼š\n1 2 3 4 5 6 7 8 enum WebEvent { // An enum variant can be like a unit struct without fields or data types WELoad, // An enum variant can be like a tuple struct with data types but no named fields WEKeys(String, char), // An enum variant can be like a classic struct with named fields and their data types WEClick { x: i64, y: i64 } } ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬ä¸ç›´æ¥åœ¨æšä¸¾é‡Œé¢å®šä¹‰ä¸€ä¸ªå¤æ‚çš„ç»“æ„ï¼Œè€Œæ˜¯åœ¨å¤–é¢å®šä¹‰å¥½ç›¸åº”çš„ç»“æ„ä½“ä¹‹åï¼Œåœ¨æšä¸¾é‡Œé¢ä½¿ç”¨ï¼š\n1 2 3 4 5 6 7 8 9 // Define a tuple struct struct KeyPress(String, char); // Define a classic struct struct MouseClick { x: i64, y: i64 } // Redefine the enum variants to use the data from the new structs // Update the page Load variant to have the boolean type enum WebEvent { WELoad(bool), WEClick(MouseClick), WEKeys(KeyPress) } åœ¨ä½¿ç”¨æšä¸¾æ—¶ï¼Œé‡‡ç”¨è¿ç®—ç¬¦::æ¥æŒ‡å®šå…·ä½“çš„æšä¸¾å€¼ï¼š\n1 2 3 4 5 6 7 // bool let we_load = WebEvent::WELoad(true); // Instantiate a MouseClick struct and bind the coordinate values let click = MouseClick { x: 100, y: 250 }; // Set the WEClick variant to use the data in the click struct let we_click = WebEvent::WEClick(click); Rustå‡½æ•° Rustçš„å‡½æ•°ä½¿ç”¨å…³é”®å­—fnå£°æ˜ï¼š\n1 2 3 fn main() { println!(\"Hello, world!\"); } å‡½æ•°çš„è¿”å›å€¼ç”±-\u003eç¡®å®šï¼Œå‚æ•°å¡«åœ¨()é‡Œé¢ï¼Œä½¿ç”¨:æŒ‡å®šç±»å‹ï¼š\n1 2 3 fn is_divisible_by(dividend: u32, divisor: u32) -\u003e bool { ... } åœ¨å‡½æ•°ä½“ä¸­ï¼Œå¤§å¤šæ•°çš„è¯­å¥æ˜¯åˆ†å·;ç»“å°¾çš„ã€‚å¦‚æœä¸æ˜¯åˆ†å·ç»“å°¾çš„è¯­å¥ï¼Œåˆ™æœ‰å¯èƒ½æ˜¯å‡½æ•°çš„è¿”å›å€¼ï¼\n1 2 3 4 5 6 7 8 fn getFive() -\u003e i32 { 5 } // ç­‰åŒäº fn getFive() -\u003e i32 { return 5; } ###é›†åˆç±»å‹\nRustä¸­è‡ªå¸¦äº†ä¸€äº›å¸¸è§çš„é›†åˆç±»å‹ï¼šæ•°ç»„ã€å‘é‡ã€HashMapç­‰\næ•°ç»„ Rustä¸­çš„æ•°ç»„æ˜¯å…·æœ‰ç›¸åŒæ•°æ®ç±»å‹å’Œå›ºå®šé•¿åº¦çš„å¯¹è±¡é›†åˆã€‚å®šä¹‰å’Œç´¢å¼•ï¼š\n1 2 3 4 5 6 7 // Declare array, initialize all values, compiler infers length = 7 let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]; // Declare array, first value = \"0\", length = 5 let bytes = [0; 5]; // Set first day of week let first = days[0]; å‘é‡ Rustä¸­çš„å‘é‡æ˜¯é•¿åº¦å¯å˜çš„ç›¸åŒæ•°æ®ç±»å‹çš„å¯¹è±¡é›†åˆã€‚å‘é‡å£°æ˜ï¼š\n1 2 3 4 // Declare vector, first value = \"0\", length = 5 let zeroes = vec![0; 5]; // Create empty vector, declare vector mutable so it can grow and shrink let mut fruit = Vec::new(); æ³¨æ„ï¼Œä»£ç ä¸­çš„vec!æ˜¯ä¸€ä¸ªå®ï¼Œè€ŒVec::new()ä¸ºè°ƒç”¨Vecä¸­çš„new()æ–¹æ³•\nç´¢å¼•ã€æ·»åŠ å’Œåˆ é™¤å€¼ï¼š\n1 2 3 4 5 6 fruit.push(\"Apple\"); fruit.push(\"Banana\"); fruit.push(\"Cherry\"); let cherry = fruit.pop(); let apple = fruit[0]; let banana = fruit[-1]; HashMap Rustä¸­çš„HashMapå®šä¹‰åœ¨æ ‡å‡†åº“ä¸­ï¼Œå› æ­¤åœ¨ä½¿ç”¨å‰éœ€è¦ä½¿ç”¨\n1 use std::collections::HashMap; å¼•å…¥ã€‚useå…³é”®å­—å’Œå…¶ä»–è¯­è¨€ä¸­çš„importç±»ä¼¼ï¼Œç”¨äºå¯¼å…¥ã€‚\nåˆå§‹åŒ–ï¼Œæ·»åŠ ã€è·å–ã€åˆ é™¤å…ƒç´ ï¼š\n1 2 3 4 5 6 7 8 9 let mut reviews: HashMap\u003cString, String\u003e = HashMap::new(); reviews.insert(\"Ancient Roman History\".to_string(), \"Very accurate.\".to_string()); reviews.insert(\"Programming in Rust\".to_string(), \"Great examples.\".to_string()); let key: \u0026str = \"Programming in Rust\"; let v = reviews.get(key); reviews.remove(key); å¾ªç¯ Rustä¸­ï¼Œæä¾›äº†ä¸‰ç§å¾ªç¯ï¼šloop, while, for\nloop Rustä¸­çš„loopä¸ºæ— é™å¾ªç¯ï¼Œåªèƒ½ä½¿ç”¨breakè·³å‡ºã€‚ä½¿ç”¨breakæ—¶ï¼Œè¿˜èƒ½é¡ºå¸¦è¿”å›ä¸€ä¸ªå€¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 let mut counter = 1; // stop_loop is set when loop stops let stop_loop = loop { counter *= 2; if counter \u003e 100 { // Stop loop, return counter value break counter; } }; // Loop should break when counter = 128 println!(\"Break the loop at counter = {}.\", stop_loop); å¦‚æœloopä¸­æœ‰å¤šä¸ªbreakï¼Œé‚£ä¹ˆæ¯å¤„è¿”å›çš„ç±»å‹éœ€è¦ä¸€è‡´ã€‚\nwhile å’Œå…¶ä»–è¯­è¨€çš„whileæ²¡ä»€ä¹ˆåŒºåˆ«ï¼š\n1 2 3 while condition { ... } for å¯¹äºæ•°ç»„ä¹‹ç±»çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨for \u003cvalue\u003e in \u003clist\u003e\n1 2 3 4 5 6 7 8 let big_birds = [\"ostrich\", \"peacock\", \"stork\"]; for bird in big_birds { ... } // ä¹Ÿå¯ä½¿ç”¨iter() for bird in big_birds.iter() { ... } å¦å¤–ä¸€ç§å¸¸è§çš„ç”¨æ³•æ˜¯for idx in a...bï¼Œå…¶ä¸­ï¼Œa...bè¡¨ç¤ºä»aå¼€å§‹ï¼Œæ­¥é•¿ä¸º1è¿­ä»£åˆ°bï¼ˆä¸åŒ…å«b)ï¼š\n1 2 3 for number in 0..5 { // 0, 1, 2, 3, 4 } é”™è¯¯å¤„ç† panic panic æ˜¯ Rust ä¸­æœ€ç®€å•çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚å‘ç”Ÿpanicæ—¶ï¼ŒRustä¼šè¾“å‡ºä¸€æ¡é”™è¯¯æ¶ˆæ¯ã€æ¸…ç†èµ„æºï¼Œç„¶åé€€å‡ºç¨‹åºã€‚å¯ä»¥è°ƒç”¨panic!å®æ¥ä½¿å½“å‰è¿›ç¨‹panicã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåªæœ‰åœ¨ç¨‹åºé‡åˆ°æ— è®ºå¦‚ä½•éƒ½æ¢å¤ä¸äº†çš„é”™è¯¯æ—¶ä½¿ç”¨ï¼š\n1 2 3 fn main() { panic!(\"Farewell!\"); } Option åœ¨Rustä¸­ï¼Œä½¿ç”¨Option\u003cT\u003eå¤„ç†å¯èƒ½ä¸ºç©ºçš„å€¼ã€‚å…¶ä»–è¯­è¨€ä¸­ï¼Œä¼šæœ‰null, nil, Noneä¹‹ç±»çš„å€¼è¡¨ç¤ºç©ºå€¼ï¼Œåœ¨Rustä¸­ï¼Œé™¤äº†ä¸å…¶ä»–è¯­è¨€ï¼ˆæ¯”å¦‚Cï¼‰äº¤äº’æ—¶ï¼Œå…¶ä»–æƒ…å†µä¸‹åŸºæœ¬éƒ½ä¸ä¼šä½¿ç”¨nullã€‚\nOption\u003cT\u003eæ˜¯ä¸€ä¸ªå¸¦æ³›å‹çš„æšä¸¾ï¼š\n1 2 3 4 enum Option\u003cT\u003e { None, // The value doesn't exist Some(T), // The value exists } é‚£ä»€ä¹ˆæ—¶å€™ä¼šç”¨åˆ°Optionå‘¢ï¼Ÿä¸‹é¢å°±æ˜¯ä¸€ä¸ªä¾‹å­ï¼š\nåœ¨å‰é¢çš„å•å…ƒä¸­ï¼Œæˆ‘ä»¬æåˆ°å°è¯•è®¿é—®çŸ¢é‡çš„ä¸å­˜åœ¨çš„ç´¢å¼•ä¼šå¯¼è‡´ç¨‹åº panicï¼Œä½†ä½ å¯ä»¥é€šè¿‡ä½¿ç”¨ Vec::get æ–¹æ³•ï¼ˆè¯¥æ–¹æ³•è¿”å› Option ç±»å‹ï¼Œè€Œä¸æ˜¯ panicï¼‰æ¥é¿å…è¿™ç§æƒ…å†µã€‚ å¦‚æœè¯¥å€¼å­˜åœ¨äºæŒ‡å®šçš„ç´¢å¼•å¤„ï¼Œç³»ç»Ÿä¼šå°†å…¶åŒ…è£…åœ¨ Option::Some(value) å˜ä½“ä¸­ã€‚ å¦‚æœç´¢å¼•è¶…å‡ºç•Œé™ï¼Œåˆ™å®ƒä¼šæ”¹ä¸ºè¿”å› Option::None å€¼ã€‚\n1 2 3 4 5 6 7 8 9 let fruits = vec![\"banana\", \"apple\", \"coconut\", \"orange\", \"strawberry\"]; // pick the first item: let first = fruits.get(0); println!(\"{:?}\", first); // Some(\"banana\") // pick the 99th item, which is non-existent: let non_existent = fruits.get(99); println!(\"{:?}\", non_existent); // None Rustæä¾›äº†å¤šç§æ–¹æ³•æ¥å¤„ç†Optionå€¼ï¼š\nmatchï¼šç±»ä¼¼å…¶ä»–è¯­è¨€çš„switchï¼Œé’ˆå¯¹Optionä¸­çš„æ¯ç§æƒ…å†µåˆ†åˆ«å¤„ç†\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 match Option\u003cT\u003e { Some(value) =\u003e { ... } None =\u003e {... } } // ä¸‹é¢æ˜¯ä¸€ä¸ªå®ä¾‹ let fruits = vec![\"banana\", \"apple\", \"coconut\", \"orange\", \"strawberry\"]; for \u0026index in [0, 2, 99].iter() { // fruits.get(index)è¿”å›ä¸€ä¸ªOption\u003cString\u003e match fruits.get(index) { Some(\u0026\"coconut\") =\u003e println!(\"Coconuts are awesome!!!\"), Some(fruit_name) =\u003e println!(\"It's a delicious {}!\", fruit_name), None =\u003e println!(\"There is no fruit! :(\"), } } if letï¼šå¦‚æœåªå…³å¿ƒOptionä¸­çš„æŸä¸€ä¸ªç‰¹å®šå€¼\n1 2 3 4 5 6 let a_number: Option\u003cu8\u003e = Some(7); // å¦‚æœæˆ‘åªå…³å¿ƒè¿™ä¸ªæ•°å­—ä¸º7çš„æƒ…å†µï¼Œæ­¤æ—¶é€‚åˆä½¿ç”¨if let if let Some(7) = a_number { println!(\"That's my lucky number!\"); } unwrap()/expect()ï¼šç›´æ¥è·å–Optionä¸­çš„Someå€¼ï¼Œä½†æ˜¯Optionä¸ºNoneï¼Œä¼šç›´æ¥panicã€‚åŒºåˆ«åœ¨äºexpect()å¯ä»¥è‡ªå®šä¹‰panicçš„æŠ¥é”™ä¿¡æ¯\n1 2 3 4 5 6 let a: i32 = Some(1).unwrap(); let empty_gift: Option\u003c\u0026str\u003e = None; empty_gift.unwrap(); // panic! empty_gift.expect(\"the gift is none!\"); // panic with given message! // thread 'main' panicked at 'the gift is none!' unwrap_or(\u003cdefault_value\u003e)ï¼šå¦‚æœOptionä¸ºNoneï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼\nResult Rustçš„Optionæä¾›äº†å¯¹ç©ºå€¼çš„å¤„ç†ï¼Œè€Œå¯¹äºå¯èƒ½å‡ºç°çš„ç¨‹åºçš„é”™è¯¯ï¼ŒRustæä¾›äº†Result\u003cT, E\u003eæšä¸¾æ¥å¤„ç†ï¼š\n1 2 3 4 enum Result\u003cT, E\u003e { Ok(T): // A value T was obtained. Err(E): // An error of type E was encountered instead. } Resultæšä¸¾ä¹Ÿéå¸¸å¥½ç†è§£ï¼šè¦ä¹ˆç¨‹åºè¿è¡ŒOKï¼Œè¿”å›ä¸€ä¸ªTç±»å‹çš„å€¼ï¼›è¦ä¹ˆç¨‹åºè¿è¡ŒErrï¼Œè¿”å›ä¸€ä¸ªEç±»å‹çš„é”™è¯¯ã€‚å’ŒOptionç±»ä¼¼ï¼ŒResultä¹Ÿæä¾›äº†unwrap()å’Œexpect()æ–¹æ³•ç›´æ¥è·å–OK()åŒ…çš„å€¼ã€‚å¦‚æœè¿”å›çš„æ˜¯Errï¼Œåˆ™ä¼španicã€‚\nèƒ½å¤Ÿç”¨äºOptionçš„matchå’Œif letï¼Œä¹Ÿå¯ä»¥ç”¨äºResult\n","description":"","tags":["rust"],"title":"Learning Rust - 1","uri":"/posts/engineering/learning-rust-1/"},{"categories":null,"content":"XLNet Introduction ç°åœ¨ä¸»æµçš„é¢„è®­ç»ƒæ¨¡å‹å¯ä»¥è¢«åˆ†ä¸ºä¸¤ç±»ï¼šautoregressive(AR)å’Œautoencoding(AE)\nARï¼šrecurrent model\nå•å‘æ¨¡å‹\nAEï¼šreconstruct the original data\ngap between pretraining and finetuning\nå‡è®¾ï¼šè¢«maskçš„è¯æ— å…³\nXLNetå°è¯•ä½¿ç”¨ä¸€ä¸ªæ–°çš„é¢„è®­ç»ƒä»»åŠ¡æ¥è§£å†³ARå’ŒAEé¢„è®­ç»ƒæ¨¡å‹ç°å­˜çš„ä¸€äº›é—®é¢˜ã€‚\nContributionï¼š\né¢„è®­ç»ƒä»»åŠ¡Permutationï¼šä¸ä½¿ç”¨å‰å‘/åå‘çš„é¡ºåºï¼Œè€Œæ˜¯ä½¿ç”¨æ‰“ä¹±åçš„å•è¯é¡ºåº ä½¿ç”¨Transformer-XLé‡Œé¢çš„segment recurrence mechainismå’Œrelative position encoding è°ƒæ•´Transformer-XLä½¿å¾—å…¶ç»“æ„é€‚ç”¨äºpermutation-based LM Objective: Permutation Language Modeling å¦‚æœåºåˆ—$\\textbf{x} = [x_1, ...,x_T]$, é‚£ä¹ˆä¸€å…±ä¼šæœ‰T!ç§æ’åˆ—æ–¹å¼ï¼Œè®°ä¸º $Z_T$ ã€‚é‚£ä¹ˆï¼Œ $z_t$ å’Œ $\\textbf{z}_{\u003ct}$ å°±æ˜¯permutation$\\textbf{z}\\in Z_t$ä¸­çš„ç¬¬tä¸ªå…ƒç´ ï¼Œå’Œå‰t-1ä¸ªå…ƒç´ ï¼ˆåœ¨åŸå§‹åºåˆ—çš„çš„ä½ç½®ï¼‰\né‚£ä¹ˆï¼Œå»ºæ¨¡çš„ç›®æ ‡å°±å¯ä»¥è®¾ç½®ä¸ºï¼š\nå…¶ä¸­ï¼Œ$\\theta$æ˜¯æ‰€æœ‰çš„permutationæ‰€å…±äº«çš„\nRemark è®­ç»ƒçš„ç›®æ ‡æ˜¯æŠŠè¾“å…¥åºåˆ—çš„é¡ºåºæ‰“ä¹±äº†çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦è®°ä½åŸå§‹åºåˆ—çš„é¡ºåºï¼špositional encodingåªä½¿ç”¨åŸå§‹åºåˆ—ä¸­çš„ä½ç½®\nå¦å¤–ï¼Œåœ¨finetuningçš„æ—¶å€™ï¼Œåªä½¿ç”¨åŸå§‹åºåˆ—\n?æ˜¯å¦ä»ç„¶å­˜åœ¨pretraining-finetuning gap?\nå¯¹Transformerçš„ä¿®æ”¹ ç”±äºXLNetæ˜¯permutation language modelingï¼Œå› æ­¤ä¸èƒ½ä½¿ç”¨ä¼ ç»Ÿçš„softmaxä½œä¸ºè¾“å‡ºå±‚ï¼š\nå…¶ä¸­$h_\\theta$æ˜¯X_z\u003ctçš„éšè—çŠ¶æ€ã€‚è¿™æ ·çš„è¯ï¼Œä¼šå¯¼è‡´å¯¹äºç›¸åŒå‰ç¼€çš„permutationï¼Œå…¶ä¸‹ä¸€ä¸ªtokençš„æ¦‚ç‡æ°¸è¿œæ˜¯ä¸€æ ·çš„ï¼š\n[1,2,3 | 4,5] vs [1,2,3 | 5,4]\nå› æ­¤éœ€è¦åŠ å…¥ä½ç½®ä¿¡æ¯$z_t$ï¼Œä¸Šå¼å˜ä¸ºï¼š\nè¿™é‡Œå°±æ˜¯æ‰€è°“çš„Two-Stream Self-Attentionçš„æ¥æºï¼šåŒæ—¶è€ƒè™‘$g_\\theta$å’Œ$h_\\theta$\nTwo-Stream Self-Attention è¿™é‡Œå¸¦æ¥äº†ä¸€ä¸ªé—®é¢˜ï¼šé¢„æµ‹$x_{z_t}$ï¼Œå°±åªèƒ½è€ƒè™‘ä½ç½®ä¿¡æ¯$z_t$ï¼›é¢„æµ‹$x_{z_j}, j \u003e t$ï¼Œé‚£ä¹ˆå°±å¯ä»¥è€ƒè™‘æ•´ä¸ªtä½ç½®ä¸Šé¢çš„contextä¿¡æ¯$x_{z_t}$\næ‰€ä»¥ï¼ŒXLNetæå‡ºåŒæ—¶ç»´æŠ¤ä¸¤å¥—éšçŠ¶æ€ï¼š$h_\\theta(x_{z_{\u003c=t}})$å’Œ$g_\\theta(x_{z_{\u003ct}}, z_t)$ï¼Œåé¢ä½¿ç”¨$h_{z_t}$å’Œ$g_{z_t}$è¡¨ç¤ºï¼Œå³content streamå’Œquery streamã€‚\nå¯¹äºç¬¬ä¸€å±‚ï¼Œg0è¢«è®¾ä¸ºä¸€ä¸ªå¯è®­ç»ƒçš„å‘é‡ï¼Œh0å°±ç›´æ¥ä½¿ç”¨ç¬¬ä¸€ä¸ªè¯çš„embeddingã€‚åœ¨è®­ç»ƒçš„æ—¶å€™ï¼Œä¸¤ä¸ªstreamå…±åŒä½¿ç”¨ä¸€å¥—å‚æ•°$\\theta$\næ•´ä½“æ¨¡å‹çš„ç»“æ„ï¼š\nPartial Prediction ç”±äºå®é™…è®­ç»ƒæ—¶ï¼Œpermutation LMæ”¶æ•›å¾ˆæ…¢ï¼Œå› æ­¤åœ¨æ¯ä¸€ä¸ªpermutationåºåˆ—ä¸­åªé¢„æµ‹ä¸€éƒ¨åˆ†è¯\nIncorporating Ideas from Transformer-XL ä»Transformer-XLä¸­å€Ÿé‰´äº†ä¸¤ä¸ªéå¸¸é‡è¦çš„æœºåˆ¶ï¼š\nrelative positional encoding\nç”¨æ¥è®°å½•åŸå§‹åºåˆ—ä¸­çš„é¡ºåº\nsegment recurrence mechanism\nModeling Multiple Segments å¯¹äºå¤šsegmentçš„è®­ç»ƒï¼ŒXLNetä¼šéšæœºé‡‡æ ·ä¸¤ä¸ªsegmentï¼Œç„¶åæŠŠå®ƒä»¬æ¥èµ·æ¥ - [CLS, A, SEP, B, SEP]ï¼Œä½œä¸ºPLMä¸­çš„ä¸€ä¸ªåºåˆ—æ¥è®­ç»ƒ\nRelative Segment Encoding åªè€ƒè™‘ä¸¤ä¸ªä½ç½®æ˜¯å¦åœ¨åŒä¸€ä¸ªsegmentä¸­ï¼Œè®°ä¸ºs_ij\nå¯¹äºä¸¤ä¸ªä½ç½®i,jï¼ŒAttention weight $a_{ij}=(q_i+b)^Ts_{ij}$ ï¼Œå…¶ä¸­q_iæ˜¯Transformerçš„queryï¼Œbæ˜¯bias\nExperiment Setup tokenizer: sentencepiece\nPretraining sequence length: 512\n512TPU v3, 500K steps\noptimizer: Adam weight decay optimizer\nBatch size: 8192\npretraininig cost 5.5 days\nPerformance å¥½äºBERT/RoBERTa\n","description":"","tags":["xlnet","paper note"],"title":"XLNet","uri":"/posts/deep-learning/xlnet/"},{"categories":null,"content":"Introduction Main contributions:\nIntroduce GPT-C, a multi-layer generative transformer model, which is a variant of the GPT-2 Propose and deploy a novel end-to-end code sequence completion system, and an efficient client-side caching system Introduce MultiGPT-C â€“ a multilingual version of GPT-C Dataset 1.2 billion lines of source code in Python, C#, JS and TS;\n4.7 million files\nApproach Model definition\nwhere $W_e$ is the input token embedding matrix, $C$ is the context vector of tokens, $W_p$ is the position embedding matrix.\nThe input token embedding matrix is reused in output layout, which removes large fully connected layout and reduces the number of parameters by 25%\nPreprocessing AST/CST/CFG is not used in this paper.\nThe input code is normalized using a custom tokenizer to overcome the style issues. Also, the token type is extracted in both training and inference procedure to help the normalization, extract subtoken vocabulary and encode the sequences.\nVocabulary Two tokenization methods:\nBPE casing convention, including camelCase, PascalCase and snake_case Several special tokens are added to vocabulary: \u003cBOF\u003e, \u003cEOF\u003e, \u003cEOL\u003e, \u003cINDENT\u003e, \u003cDEDENT\u003e\nSensitive Data Processing To avoid the leaking of sensitive data, IntelliCode Compose uses \u003cNUM_LIT\u003e, \u003cSTR_LIT\u003e and \u003cCOMMENT\u003e to replace numeric literals, string literals and comments.\nNote that not all literals are replaced, there are some literals in each language are kept. For example, \u003cSTR_LIT:__main__\u003e means this token is a string literal \"__main__\".\nModel Training In training, IntelliCode Compose uses a decreasing learning rate with several warm-up perioids. The training is scaled up using synchronous data-parallel distributed training algorithm with local gradient accumulation.\nThe authors use 5 Lambda V100 boxes, each having sixteen V100 GPUs with 32 GB HBM2 memory, eight 100 GB InfiniBand, and one 100 GB Ethernet connection, managed with Kubernetes\nThe best model has 24 layers, 16 heads and the bpe vocabulary size is 50000.\nThe hyper parameters are set as the following table:\nIn training, base learning rate is set to 6.25*10^-5, batch size 128, learning rate decay of 0.98 per epoch.\nSequence Decoding Beam search, ending with \u003cEOL\u003e or other language specific tokens\nBatched inference is performed, the batch size is set to beam size k, which reduces L*k inference calls to L, where L is the sequence length.\nClient-Side Post-Processing Caching The suggestion results are cached as a trie with score. The key is the preceding context. If the user continues typing, the trie is pruned and then the suggestion is calculated by traversing the trie using a greedy search.\nThe trie traversing will be terminated early if none of the child nodes has a score that is larger than the score of its parent multiplied by a ratio ğ‘…:\nWhere L is the position in sequence. $\\alpha$ And $k$ are two parameters, $\\alpha$ controls the overall average length, and $k$ controls the speed than R decreases. In the practice, the authors select ğ›¼ = 0.8 and ğœ… = 10 to gain a balance between suggestion length and relevance.\nSuggestion Processing The special tokens are removed or replaced case by case.\nMulti-Lingual Model The authors tests four approaches:\nLanguage-agnostic baseline\nLanguage-type embedding\nLanguage control code\nDouble heads multilingual model\nAdd a programming language classification task during model pretraining\nEvaluation ","description":"","tags":["paper-note","code-completion"],"title":"IntelliCode Compose","uri":"/posts/code-intelligence/intellicode-compose/"},{"categories":null,"content":"Dockerfile A brief introduction to docker æœ€ç®€å•çš„ç†è§£ï¼Œå…¶å®å°±æ˜¯åœ¨ä½ æœºå™¨ä¸Šé¢è·‘çš„ä¸€ä¸ªè½»é‡åŒ–çš„è™šæ‹Ÿæœºã€‚å’Œè™šæ‹Ÿæœºä¸åŒçš„æ˜¯ï¼Œdockerå¯ä»¥æ›´é«˜æ•ˆåœ°åˆ©ç”¨ç³»ç»Ÿèµ„æºã€æœ‰ç€æ›´å¿«é€Ÿçš„å¯åŠ¨æ—¶é—´ã€‚åŒæ—¶ï¼Œè¿˜å¯ä»¥ç»™å¼€å‘è€…æä¾›ä¸€è‡´çš„è¿è¡Œç¯å¢ƒï¼Œå®ç°ä¸€æ¬¡åˆ›å»ºå’Œé…ç½®ï¼Œåœ¨ä»»æ„åœ°æ–¹æ­£å¸¸è¿è¡Œï¼Œæœ‰åˆ©äºæŒç»­äº¤ä»˜å’Œéƒ¨ç½²ã€‚\nåŸºç¡€æ¦‚å¿µ DockeråŒ…æ‹¬ä¸‰ä¸ªåŸºç¡€æ¦‚å¿µï¼šé•œåƒã€å®¹å™¨å’Œä»“åº“\né•œåƒ\næˆ‘ä»¬éƒ½çŸ¥é“ï¼Œæ“ä½œç³»ç»Ÿåˆ†ä¸ºå†…æ ¸å’Œç”¨æˆ·ç©ºé—´ã€‚å¯¹äº Linux è€Œè¨€ï¼Œå†…æ ¸å¯åŠ¨åï¼Œä¼šæŒ‚è½½ root æ–‡ä»¶ç³»ç»Ÿä¸ºå…¶æä¾›ç”¨æˆ·ç©ºé—´æ”¯æŒã€‚è€Œ Docker é•œåƒï¼ˆImageï¼‰ï¼Œå°±ç›¸å½“äºæ˜¯ä¸€ä¸ª root æ–‡ä»¶ç³»ç»Ÿã€‚æ¯”å¦‚å®˜æ–¹é•œåƒ ubuntu:18.04 å°±åŒ…å«äº†å®Œæ•´çš„ä¸€å¥— Ubuntu 18.04 æœ€å°ç³»ç»Ÿçš„ root æ–‡ä»¶ç³»ç»Ÿã€‚\nå®¹å™¨\né•œåƒï¼ˆImageï¼‰å’Œå®¹å™¨ï¼ˆContainerï¼‰çš„å…³ç³»ï¼Œå°±åƒæ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­çš„ ç±» å’Œ å®ä¾‹ ä¸€æ ·ï¼Œé•œåƒæ˜¯é™æ€çš„å®šä¹‰ï¼Œå®¹å™¨æ˜¯é•œåƒè¿è¡Œæ—¶çš„å®ä½“ã€‚å®¹å™¨å¯ä»¥è¢«åˆ›å»ºã€å¯åŠ¨ã€åœæ­¢ã€åˆ é™¤ã€æš‚åœç­‰ã€‚\nä»“åº“\né•œåƒæ„å»ºå®Œæˆåï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„åœ¨å½“å‰å®¿ä¸»æœºä¸Šè¿è¡Œï¼Œä½†æ˜¯ï¼Œå¦‚æœéœ€è¦åœ¨å…¶å®ƒæœåŠ¡å™¨ä¸Šä½¿ç”¨è¿™ä¸ªé•œåƒï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªé›†ä¸­çš„å­˜å‚¨ã€åˆ†å‘é•œåƒçš„æœåŠ¡ï¼ŒDocker Registry å°±æ˜¯è¿™æ ·çš„æœåŠ¡ã€‚\nä¸€ä¸ª Docker Registry ä¸­å¯ä»¥åŒ…å«å¤šä¸ª ä»“åº“ï¼ˆRepositoryï¼‰ï¼›æ¯ä¸ªä»“åº“å¯ä»¥åŒ…å«å¤šä¸ª æ ‡ç­¾ï¼ˆTagï¼‰ï¼›æ¯ä¸ªæ ‡ç­¾å¯¹åº”ä¸€ä¸ªé•œåƒã€‚\nä½¿ç”¨é•œåƒ åœ¨Docker Hubä¸­ï¼Œæœ‰å¾ˆå¤šå®˜æ–¹ç»´æŠ¤çš„é«˜è´¨é‡é•œåƒï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è·å–æŸä¸ªé•œåƒï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨docker pullï¼Œå¦‚æˆ‘æƒ³è¦æ‹‰å–ubuntuçš„å®˜æ–¹é•œåƒï¼Œé‚£ä¹ˆç›´æ¥ä½¿ç”¨ï¼š\n1 docker pull ubuntu:18.04 Dockerfile What's dockerfile å¦‚æœæˆ‘ä»¬æƒ³è¦å®šåˆ¶ä¸€ä¸ªé•œåƒç»™å…¶ä»–äººå»ä½¿ç”¨ï¼Œé‚£ä¹ˆå°±éœ€è¦æŠŠæ‰€æœ‰çš„ä¿®æ”¹ã€é…ç½®ç­‰éƒ½å†™å…¥ä¸€ä¸ªè„šæœ¬ä¸­ï¼Œç„¶åç”¨è¿™ä¸ªè„šæœ¬æ¥æ„å»ºæˆ‘ä»¬çš„å®šåˆ¶é•œåƒã€‚è¿™ä¸ªè„šæœ¬å°±æ˜¯Dockerfileã€‚\nDockerçš„é•œåƒæœ‰ä¸€ä¸ªåˆ†å±‚çš„æœºåˆ¶ï¼Œå°±æ˜¯è¯´ï¼Œåœ¨Dockerfileé‡Œé¢çš„æ¯ä¸€æ¡å‘½ä»¤æ˜¯ä¸€å±‚ã€‚åœ¨æ„å»ºé•œåƒçš„æ—¶å€™ï¼Œæ˜¯ä¸€å±‚ä¸€å±‚åœ°æ„å»ºçš„ï¼Œå‰ä¸€å±‚æ˜¯åä¸€å±‚çš„åŸºç¡€ï¼Œæ¯ä¸€å±‚æ„å»ºå®Œæ¯•ä¹‹åå°±ä¸ä¼šå†æ”¹å˜ï¼Œåä¸€å±‚çš„ä»»ä½•ä¿®æ”¹åªä¼šä½œç”¨äºå½“å‰è¿™ä¸€å±‚ã€‚\nç”¨ä¸€ä¸ªä¾‹å­æ¥è¾…åŠ©ç†è§£ï¼šå¦‚æœæˆ‘åœ¨ä¸Šä¸€å±‚æ·»åŠ äº†ä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶ååœ¨ä¸‹ä¸€å±‚åˆ é™¤ï¼Œé‚£ä¹ˆæœ€ç»ˆåœ¨å®¹å™¨è¿è¡Œçš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯çœ‹ä¸åˆ°è¿™ä¸ªè¢«åˆ é™¤çš„æ–‡ä»¶çš„ï¼Œä½†æ˜¯å®é™…ä¸Šè¿™ä¸ªæ–‡ä»¶æ˜¯ä¸€ç›´å­˜åœ¨åœ¨é•œåƒé‡Œé¢çš„æŸä¸€å±‚çš„ï¼Œåªæ˜¯åœ¨ä¸‹ä¸€å±‚ä¸­ï¼Œè¿™ä¸ªæ–‡ä»¶è¢«æ ‡è®°ä¸ºå·²åˆ é™¤ã€‚\nå› æ­¤ï¼Œåœ¨æ„å»ºé•œåƒçš„æ—¶å€™ï¼Œæ¯ä¸€å±‚å°½é‡åªåŒ…å«è¯¥å±‚éœ€è¦æ·»åŠ çš„ä¸œè¥¿ï¼Œä»»ä½•å…¶ä»–é¢å¤–çš„ä¸œè¥¿åº”è¯¥åœ¨è¯¥å±‚æ„å»ºç»“æŸä¹‹å‰æ¸…ç†æ‰ã€‚\næ„å»ºé•œåƒ åœ¨Dockerfileæ‰€åœ¨çš„ç›®å½•æ‰§è¡Œï¼š\n1 2 3 4 docker build [é€‰é¡¹] [ä¸Šä¸‹æ–‡è·¯å¾„] # ä¾‹å­ï¼š docker build -t nginx:v3 . æ„å»ºä¸Šä¸‹æ–‡Context å¯ä»¥çœ‹åˆ°docker buildå‘½ä»¤æœ€åæœ‰ä¸€ä¸ª.ï¼Œè¿™ä¸ªè¡¨ç¤ºå½“å‰æ„å»ºçš„ä¸Šä¸‹æ–‡æ˜¯å½“å‰ç›®å½•ã€‚ä¸ºä»€ä¹ˆéœ€è¦æŒ‡å®šä¸Šä¸‹æ–‡ç›®å½•å‘¢ï¼Ÿé¦–å…ˆéœ€è¦äº†è§£docker buildçš„å·¥ä½œåŸç†\nDocker åœ¨è¿è¡Œæ—¶åˆ†ä¸º Docker å¼•æ“ï¼ˆä¹Ÿå°±æ˜¯æœåŠ¡ç«¯å®ˆæŠ¤è¿›ç¨‹ï¼‰å’Œå®¢æˆ·ç«¯å·¥å…·ã€‚Docker çš„å¼•æ“æä¾›äº†ä¸€ç»„ REST APIï¼Œè¢«ç§°ä¸º Docker Remote APIï¼Œè€Œå¦‚ docker å‘½ä»¤è¿™æ ·çš„å®¢æˆ·ç«¯å·¥å…·ï¼Œåˆ™æ˜¯é€šè¿‡è¿™ç»„ API ä¸ Docker å¼•æ“äº¤äº’ï¼Œä»è€Œå®Œæˆå„ç§åŠŸèƒ½ã€‚å› æ­¤ï¼Œè™½ç„¶è¡¨é¢ä¸Šæˆ‘ä»¬å¥½åƒæ˜¯åœ¨æœ¬æœºæ‰§è¡Œå„ç§ docker åŠŸèƒ½ï¼Œä½†å®é™…ä¸Šï¼Œä¸€åˆ‡éƒ½æ˜¯ä½¿ç”¨çš„è¿œç¨‹è°ƒç”¨å½¢å¼åœ¨æœåŠ¡ç«¯ï¼ˆDocker å¼•æ“ï¼‰å®Œæˆã€‚\næ‰€ä»¥ï¼Œå½“éœ€è¦ç”¨åˆ°æœ¬åœ°çš„ä¸€äº›æ–‡ä»¶çš„æ—¶å€™ï¼Œå°±éœ€è¦æŠŠè¿™äº›æ–‡ä»¶æ·»åŠ åˆ°ä¸Šä¸‹æ–‡ç›®å½•ä¸­ï¼Œåœ¨æ‰§è¡Œdocker buildçš„æ—¶å€™ï¼Œä¸Šä¸‹æ–‡ç›®å½•ä¸‹çš„æ–‡ä»¶éƒ½ä¼šè¢«æ‰“åŒ…ï¼Œç„¶åå‘ç»™dockerå¼•æ“ã€‚\nå› æ­¤ï¼Œåœ¨Dockerfileé‡Œé¢ï¼Œå¦‚æœæœ‰ä»¥ä¸‹ä¸€æ¡å‘½ä»¤ï¼š\n1 COPY ./package.json /app/ å…¶COPYçš„æ–‡ä»¶å®é™…ä¸Šæ˜¯ä¸Šä¸‹æ–‡ç›®å½•ä¸‹é¢çš„package.jsonï¼Œè€Œéæ‰§è¡Œdocker buildçš„ç›®å½•ï¼Œæˆ–è€…Dockerfileæ‰€åœ¨ç›®å½•ã€‚\nå¸¸ç”¨Dockerfileå‘½ä»¤ FROM æ‰€è°“å®šåˆ¶é•œåƒï¼Œé‚£ä¸€å®šæ˜¯ä»¥ä¸€ä¸ªé•œåƒä¸ºåŸºç¡€ï¼Œåœ¨å…¶ä¸Šè¿›è¡Œå®šåˆ¶ã€‚FROMå‘½ä»¤å°±æ˜¯ç”¨æ¥æŒ‡å®šåŸºç¡€é•œåƒçš„ã€‚å› æ­¤ï¼Œä¸€ä¸ªDockerfileä¸­ï¼ŒFROMæ˜¯å¿…å¤‡å‘½ä»¤ï¼Œå¹¶ä¸”å¿…é¡»æ˜¯ç¬¬ä¸€æ¡å‘½ä»¤ã€‚\nåœ¨DockerHubä¸Šæœ‰å¾ˆå¤šé«˜è´¨é‡å®˜æ–¹é•œåƒï¼Œæœ‰å¯ä»¥ç›´æ¥ä½¿ç”¨çš„æœåŠ¡ç±»é•œåƒï¼Œå¦‚nginxã€redisç­‰ï¼Œä¹Ÿæœ‰æ–¹ä¾¿å¼€å‘æ„å»ºè¿è¡Œå„ç§è¯­è¨€çš„é•œåƒï¼Œå¦‚openjdkã€pythonç­‰ï¼Œå½“ç„¶ä¹Ÿæœ‰åŸºç¡€çš„æ“ä½œç³»ç»Ÿé•œåƒï¼Œå¦‚ubuntuã€centosç­‰ã€‚æˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­é€‰æ‹©ä¸€ä¸ªæœ€ç¬¦åˆæˆ‘ä»¬æœ€ç»ˆç›®æ ‡çš„åŸºç¡€é•œåƒå¼€å§‹å®šåˆ¶ã€‚\nRUN RUNæŒ‡ä»¤æ˜¯ç”¨æ¥æ‰§è¡Œå‘½ä»¤è¡Œå‘½ä»¤çš„ï¼Œæœ‰ä¸¤ç§å½¢å¼ï¼š\nshellæ ¼å¼ï¼šRUN \u003cå‘½ä»¤\u003e execæ ¼å¼ï¼šRUN [\"å¯æ‰§è¡Œæ–‡ä»¶\", \"å‚æ•°1\", \"å‚æ•°2\"] éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨Dockerfileä¸­æœ€å¥½ä¸è¦æ¯ä¸€æ¡å‘½ä»¤éƒ½ä½¿ç”¨ä¸€ä¸ªRUNï¼Œè€Œæ˜¯æŠŠä¸€ä¸ªç›®çš„çš„å‘½ä»¤ç»“åˆåˆ°ä¸€èµ·ï¼Œä½¿ç”¨åˆ†è¡Œç¬¦\\å’Œè¿æ¥ç¬¦\u0026\u0026è¿åˆ°ä¸€èµ·ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # é”™è¯¯ç”¨æ³• FROM debian:stretch RUN apt-get update RUN apt-get install -y gcc libc6-dev make wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install # æ­£ç¡®ç”¨æ³• FROM debian:stretch RUN set -x; buildDeps='gcc libc6-dev make wget' \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y $buildDeps \\ \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ \u0026\u0026 mkdir -p /usr/src/redis \\ \u0026\u0026 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ \u0026\u0026 make -C /usr/src/redis \\ \u0026\u0026 make -C /usr/src/redis install \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* \\ \u0026\u0026 rm redis.tar.gz \\ \u0026\u0026 rm -r /usr/src/redis \\ \u0026\u0026 apt-get purge -y --auto-remove $buildDeps COPY COPYæ˜¯æŠŠä¸Šä¸‹æ–‡ç›®å½•ä¸‹çš„æ–‡ä»¶å¤åˆ¶åˆ°æ–°çš„ä¸€å±‚é•œåƒå†…çš„\u003cç›®æ ‡è·¯å¾„\u003eä½ç½®ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n1 2 COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003cæºè·¯å¾„\u003e... \u003cç›®æ ‡è·¯å¾„\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003cæºè·¯å¾„1\u003e\",\"\u003cæºè·¯å¾„2\u003e\",... \"\u003cç›®æ ‡è·¯å¾„\u003e\"] æ³¨æ„ï¼šå¦‚æœæºè·¯å¾„æ˜¯æ–‡ä»¶å¤¹ï¼Œé‚£ä¹ˆå¤åˆ¶çš„æ—¶å€™ä¸æ˜¯ç›´æ¥å¤åˆ¶æ–‡ä»¶å¤¹ï¼Œè€Œæ˜¯å¤åˆ¶æ–‡ä»¶å¤¹ä¸­çš„å†…å®¹åˆ°ç›®æ ‡è·¯å¾„\nADD ADDç›¸å½“äºæ˜¯æ›´é«˜çº§çš„COPYï¼Œåœ¨COPYçš„åŸºç¡€ä¸Šå¢åŠ äº†ä¸€äº›åŠŸèƒ½ã€‚å¦‚ï¼Œ\u003cæºè·¯å¾„\u003eæ˜¯ä¸€ä¸ªurlçš„æ—¶å€™ï¼ŒADDä¼šè¯•å›¾ä¸‹è½½è¿™ä¸ªé“¾æ¥é‡Œçš„æ–‡ä»¶æ”¾åˆ°\u003cç›®æ ‡è·¯å¾„\u003eå»ã€‚ä½†æ˜¯ï¼Œè¿™æ ·åšéœ€è¦é¢å¤–çš„ä¸€ä¸ªRUNå‘½ä»¤å»è°ƒæ•´æƒé™/è§£å‹ç¼©ç­‰ï¼Œæ‰€ä»¥ä¸æ¨èè¿™æ ·ä½¿ç”¨ã€‚\nç„¶è€Œï¼å½“\u003cæºè·¯å¾„\u003eæ˜¯ä¸€ä¸ªtaråŒ…ï¼Œä¸”å‹ç¼©æ ¼å¼ä¸ºgzipï¼Œbzip2æˆ–xzçš„æƒ…å†µä¸‹ï¼ŒADDä¼šè‡ªåŠ¨è§£å‹ç¼©åˆ°\u003cç›®æ ‡è·¯å¾„\u003eä¸‹ï¼Œå¯èƒ½ä¼šå¾ˆæœ‰ç”¨ã€‚\næ‰€ä»¥ï¼Œdockerå®˜æ–¹æ¨èï¼Œæ‰€æœ‰çš„æ–‡ä»¶å¤åˆ¶æ“ä½œå°½é‡å°±åªç”¨COPYã€‚å½“ä¸”åªå½“ç”¨åˆ°è‡ªåŠ¨è§£å‹ç¼©çš„æ—¶å€™ï¼Œæ‰ç”¨ADDã€‚\nENV ENVæ˜¯è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œæ¯”è¾ƒç®€å•ã€‚ç”¨æ³•ï¼š\n1 2 ENV \u003ckey\u003e \u003cvalue\u003e ENV \u003ckey1\u003e=\u003cvalue1\u003e \u003ckey2\u003e=\u003cvalue2\u003e... è®¾ç½®å®Œä¹‹åï¼Œ\u003ckey\u003eå°±å¯ä»¥åƒæ­£å¸¸shellè„šæœ¬é‡Œé¢çš„ç¯å¢ƒå˜é‡ä¸€æ ·åœ°ä½¿ç”¨äº†\nARG ARGæ˜¯æ„å»ºå‚æ•°ï¼Œä¸åŒäºENVçš„æ˜¯ï¼ŒARGæ‰€è®¾ç½®çš„æ˜¯æ„å»ºç¯å¢ƒçš„ç¯å¢ƒå˜é‡ã€‚æ‰€ä»¥åœ¨æœªæ¥å®¹å™¨è¿è¡Œçš„æ—¶å€™ï¼ŒARGè®¾ç½®çš„å‚æ•°æ˜¯ä¸ä¼šå­˜åœ¨çš„ã€‚ç”¨æ³•ï¼š\n1 ARG \u003cå‚æ•°å\u003e[=\u003cé»˜è®¤å€¼\u003e] æ³¨æ„\nä¸è¦ç”¨ARGä¿å­˜ç”¨æˆ·å¯†ç ä¹‹ç±»çš„å€¼ï¼Œå› ä¸ºåœ¨docker historyé‡Œé¢è¿˜æ˜¯å¯ä»¥çœ‹åˆ°æ‰€æœ‰å€¼çš„ã€‚\nARGæŒ‡ä»¤æœ‰ç”Ÿæ•ˆçš„èŒƒå›´ã€‚å¦‚æœåœ¨FROMä¹‹å‰æŒ‡å®šï¼Œé‚£ä¹ˆåªèƒ½ä½œç”¨äºFROMæŒ‡ä»¤ã€‚åœ¨å¤šé˜¶æ®µæ„å»ºæ—¶ï¼Œéœ€è¦æ³¨æ„è¿™ä¸ªé—®é¢˜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ARG DOCKER_USERNAME=library # ä¸Šé¢è®¾ç½®çš„ARGåªåœ¨FROMä¸­ç”Ÿæ•ˆ FROM ${DOCKER_USERNAME}/alpine # echoæ— æ³•è¾“å‡ºï¼ RUN set -x ; echo ${DOCKER_USERNAME} # ç”Ÿæ•ˆå“¦ FROM ${DOCKER_USERNAME}/alpine # åœ¨FROMä¹‹åä½¿ç”¨å˜é‡ï¼Œå¿…é¡»åœ¨æ¯ä¸ªé˜¶æ®µåˆ†åˆ«æŒ‡å®š ARG DOCKER_USERNAME=library # echoå¯ä»¥è¾“å‡º RUN set -x ; echo ${DOCKER_USERNAME} WORKDIR WORKDIRç”¨æ¥æŒ‡å®šå·¥ä½œç›®å½•ï¼Œç”¨æ³•å¾ˆç®€å•ï¼š\n1 WORKDIR \u003cå·¥ä½œç›®å½•è·¯å¾„\u003e åˆå­¦è€…å¸¸è§é”™è¯¯ï¼š\n1 2 3 RUN cd /app # /app/world.txtä¸å­˜åœ¨ï¼ RUN echo \"hello\" \u003e world.txt æ­£ç¡®ç”¨æ³•ï¼š\n1 2 3 4 5 # WORKDIRæŒ‡å®šå·¥ä½œç›®å½• WORKDIR /app # å†™å…¥åˆ°/app/world.txt RUN echo \"hello\" \u003e world.txt WORKDIRä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼š\n1 2 3 4 5 WORKDIR /a WORKDIR b WORKDIR c RUN pwd # è¾“å‡ºï¼š/a/b/c ","description":"","tags":["docker","dockerfile"],"title":"Get Started with Docker \u0026 Dockerfile","uri":"/posts/engineering/dockerfile/"},{"categories":null,"content":"Paper link: https://www.kdd.org/kdd2019/accepted-papers/view/pythia-ai-assisted-code-completion-system\nAbstract This paper proposes an end-to-end code completion approach call Pythia, which has been deployed as part of Intellicode extension in Visual Studio Code. Pythia is trained on 2700+ Python open source software GitHub repositories and achieves SOTA performance. Pythia uses LSTM to learn the long distance dependencies in code context sequences, which is extracted using in-order depth-first AST traversal. The parameter tuning and deployment related issues are also discussed in the later parts of the paper.\nDataset The authors collected 2700 top-starred Github Python projects in various domains. The dataset contains over 15.8 million method calls. The following is the most method call occurrences:\nThe dataset is divided to development set and test set with a 70-30 ratio on the repo level. Then the development set is split into training and validation sets in the proportion 80-20.\nThe online model is trained using the entire dataset.\nCode Representations The Pythia exploits the partial AST which is derived from code snippets containing method calls and member access expression. The ASTs are serialized to token sequence using in-order depth-first traversal. When extracting training sequence, for each method call, T preceding tokens are used, where T is a tunable parameter.\nFurther, the AST token sequence must be converted to numeric vector to be consumed by LSTM. Word2Vec is used to train the embedding of tokens.\nEmbedding training All tokens are mapped to integers from 1 to V, while the infrequent tokens are removed in order to reduce the vocabulary size. During training, OOVs are mapped to an integer greater than V. . is used as the EOS character.\nMethod names are one-hot encoded as the labels. The task is to predict method names using given code snippets. All tokens are mapped to low-dimentsional vectors with semantic relationships preserved.\nTricks The type of variables is inferred using static analysis methods Import alias is ignored Variable names are normalized to var:\u003cvariable type\u003e format Nerual Code Completion Model LSTM is used to predict completion.\nThe input embedding matrix is reused as the output classification matrix to reduce the number of parameters. Hence, the fully connected layer in before the output is no longer needed.\nModel Training Parallel backpropagation through time algorithm with adam optimizer and mini-batch is used to train the LSTM. In the training, the sequences are split into three buckets by sequence lengths. In each bucket, the lengths of sequences are padded to the maximum sequence length in this bucket.\nAs for the learning rate, the authors scale the learning rate up proportionally to the number of works during the first 4 epochs:\nModel Evaluation Model Deployment To deploy the model to lightweight client devices, the neural network quantization method is used to reduce the number of stored weights. The original Pythia model is trained in IEEE 754 numeric format, which is based on 32-bit float. The numeric format of published model is quantized into 8-bit unsigned integer. For Pythia, the model size is reduced from 152MB to 38MB with quantization. The top-5 accuracy is reduced from 92% to 89%.\n","description":"","tags":["paper-note","code-completion"],"title":"Pythia: AI Assisted Code Completion System","uri":"/posts/deep-learning/pythia-ai-assisted-code-completion-system/"},{"categories":null,"content":"A Self-Attentional Neural Architecture for Code Completion with Multi-Task Learning Introduction Current code completion algorithms sufferes from 3 major drawbacks:\nHierarchical structural information of the program is not fully utilized\nIn programs, the semantic relationships can be very long\nUnderuse of the information from related tasks\nIn AST, node's type and value are two closely related attributes - but existing methods predict them separately\nContribution Multi-task learning model for code completion Exploit the hierarchical structure information of program Introduce Transformer-XL to capture long-distance dependencies Motivating example Predicting break Predicting node's type \u0026 value NOTE: borrows the idea from code2vec?\nBackground Language modeling Probability of S:\nN-gram:\nRNN: capture longer dependencies than N-gram\nLSTM/GRU: ease the vanishing gradient problem - uses about 200 context words on average\nTransformer: fixed-length context\nğŸ‘Transformer-XL: captures longer context\nMulti-task learning MTL can improve generalization and reduce the risk of over-fitting\nMethod: parameter sharing of hidden layers\nsoft parameter sharing: use the distance of parameters\nhard parameter sharing: hidden layers are shared among tasks, output layers are task-specific\nProposed model Task: predict the probability of next node in AST\nPartial AST encoder: Transformer-XL\nPath2root encoder:\nMTL: hard parameter sharing\noutput layers are specfic\nProgram representation program -\u003e AST -\u003e sequence of nodes\nâ€‹\t- in-order depth-first traversal\nNode -\u003e type[value] -\u003e $x = [T;V]$\nPartial AST encoder Transformer-XL is used to encode partial AST. It's a standard Transformer-XL.\nPath2Root encoder The path from predicting node to the root node is extracted. In the above example, the extracted path is {BinOp, Return, body, FunctionDef} in order to predict NameLoad[b]\nIn this part, a bidirectional-LSTM is used as the encoder. The two hidden vectors are concatenated.\nTask-specific output layers Two tasks: predict next node's type and value\nOutput layers: the output of partial AST encoder and path2root encoder are concatenated. Softmax is used to generate the prediction\nTraining loss Because there are multiple tasks, the final loss is calculated using a weighted sum over the task-specific losses\nExperiments Dataset \u0026 Metrics dataset: java/python/js\nMetrics: accuracy\nExperimental setup Vocab size: 50000\nembedding size: type[300], value[1200], total[1500]\n6-layer Transformer-XL, 6 heads, d_h = 64\nSegment length = 50\nPerformance Ablation study Weights ","description":"","tags":["code completion","paper note"],"title":"A Self-Attentional Neural Architecture for Code Completion with Multi-Task Learning","uri":"/posts/code-intelligence/a-self-attentional-neural-architecture-for-code-completion-with-multi-task-learning/"},{"categories":null,"content":"å‘½å å˜é‡/å¸¸é‡å‘½åï¼šé©¼å³°\næ¥å£åï¼šXXXer\nGetter/Setterï¼šå¯¹äºobj.fieldï¼Œgetterç”¨obj.Field()ï¼Œsetterç”¨obj.SetField()\næ§åˆ¶ç»“æ„ if å¯ä»¥åœ¨ifä¸­å®šä¹‰å˜é‡ï¼š\n1 2 3 4 5 6 7 8 9 10 if ok:=isOk();ok { // OK } var v string var err error if v, err = doSomething(); err != nil { // å¤„ç†é”™è¯¯ } // ç»§ç»­ for/switch foræœ‰ä¸‰ç§æƒ…å†µ\n1 2 3 4 5 6 7 8 // å¦‚åŒCçš„forå¾ªç¯ for init; condition; post { } // å¦‚åŒCçš„whileå¾ªç¯ for condition { } // å¦‚åŒCçš„for(;;)å¾ªç¯ for { } switchå¯ä»¥æ›¿ä»£å¤šä¸ªif-else\n1 2 3 4 5 6 7 8 9 10 11 func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } ä¸€ä¸ªcaseå¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶\n1 2 3 4 switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } ç±»å‹åˆ¤æ–­çš„å…¸å‹ç”¨æ³•\n1 2 3 4 5 6 7 8 9 10 11 12 13 t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T è¾“å‡º t æ˜¯ä»€ä¹ˆç±»å‹ case bool: fmt.Printf(\"boolean %t\\n\", t) // t æ˜¯ bool ç±»å‹ case int: fmt.Printf(\"integer %d\\n\", t) // t æ˜¯ int ç±»å‹ case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t æ˜¯ *bool ç±»å‹ case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t æ˜¯ *int ç±»å‹ } å‡½æ•° è¿”å›çš„ç»“æœå˜é‡å¯ä»¥å…ˆå‘½å\n1 2 3 4 5 6 func nextInt(b []byte, pos int) (value int, nextPos int) { // ç›´æ¥ç”¨ nextPos = 1 // ä¸å¸¦å‚æ•°çš„è¿”å›ï¼Œé»˜è®¤è¿”å›å½“å‰å€¼ï¼Œå³0å’Œ1 return } defer defer function(param)å¯ä»¥æŠŠfunctionæ¨è¿Ÿåˆ°å½“å‰å‡½æ•°ç»“æŸçš„æ—¶å€™æ‰§è¡Œã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœparamä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆparamè¿™ä¸ªå‡½æ•°ä¼šå…ˆæ‰§è¡Œ\n1 2 3 4 5 func function(p int) { // notDeferred(p)ä¼šå…ˆè¢«æ‰§è¡Œ // functionæ¨å‡ºå‰ï¼Œdeferred()æ‰ä¼šè¢«æ‰§è¡Œ defer deferred(notDeferred(p)) } åˆ‡ç‰‡Slice å¦‚æœæŠŠSliceå½“åšå‚æ•°ä¼ å…¥æŸå‡½æ•°ï¼Œé‚£ä¹ˆå‡½æ•°å¯¹sliceçš„ä¿®æ”¹ï¼Œå¯¹ä¸Šå±‚æ˜¯å¯è§çš„ã€‚å³ï¼Œä¼ è¿›å»çš„ç±»ä¼¼ä¸€ä¸ªå¼•ç”¨ï¼Œè€Œä¸æ˜¯å½¢å‚ã€‚\n1 2 // å…¸å‹ä¾‹å­ï¼ŒReadç»“æœä¼šè¢«å­˜åœ¨bufä¸­ func (file *File) Read(buf []byte) (n int, err error) ä½†æ˜¯ï¼šåˆ‡ç‰‡è‡ªèº«ï¼ˆå…¶è¿è¡Œæ—¶æ•°æ®ç»“æ„åŒ…å«æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ï¼‰æ˜¯é€šè¿‡å€¼ä¼ é€’çš„ã€‚å‚è€ƒmySlice = append(mySlice, item)\nMap å¦‚æœé€šè¿‡ä¸å­˜åœ¨çš„é”®æ¥å–å€¼ï¼Œä¼šè¿”å›å¯¹åº”ç±»å‹çš„é›¶å€¼ã€‚\nå¦‚æœéœ€è¦åŒºåˆ†æ˜¯ä¸å­˜åœ¨ï¼Œè¿˜æ˜¯å­˜çš„å€¼æœ¬æ¥å°±æ˜¯é›¶å€¼ï¼Œå¯ä»¥ä½¿ç”¨é€—å·OKæ³•ï¼š\n1 2 3 if re, ok := myMap[key]; ok { // å­˜åœ¨å€¼ } Goä¸­æ²¡æœ‰é›†åˆï¼Œä¸€èˆ¬æ˜¯ä½¿ç”¨map[string]boolä½œä¸ºé›†åˆç±»å‹\næŒ‡é’ˆ 1 2 3 4 5 6 7 type ByteSlice []byte // å¿…é¡»è¿”å›[]byteé‡æ–°å¯¹sliceèµ‹å€¼ï¼Œå³s = s.Append(data) func (slice ByteSlice) Append(data []byte) []byte { } // åŒºåˆ«åœ¨äºï¼Œè¿™ä¸ªAppendå¯ä»¥ä¸ç”¨èµ‹å€¼ï¼Œç›´æ¥å¯ä»¥ä¿®æ”¹ByteSliceï¼šs.Append(data) func (p *ByteSlice) Append(data []byte) { } åœ¨ç”¨çš„æ—¶å€™ï¼Œå…¶å®éƒ½æ˜¯s.Append()ï¼Œè¿™æ˜¯å› ä¸ºä½¿ç”¨æŒ‡é’ˆä½œä¸ºæ¥æ”¶è€…çš„å£°æ˜å½¢å¼ä¼šè¢«è‡ªåŠ¨è¯†åˆ«ï¼Œåœ¨è°ƒç”¨çš„æ—¶å€™ä¼šè¢«è‡ªåŠ¨æ”¹æˆ(\u0026s).Append()\næ¥å£ Goé‡Œé¢çš„æ¥å£æ˜¯æ¾æ•£çš„ï¼Œåªè¦å®ç°äº†ä¸€ä¸ªæ¥å£é‡Œé¢å®šä¹‰çš„æ–¹æ³•ï¼Œå°±ç›¸å½“äºå®ç°äº†è¿™ä¸ªæ¥å£ã€‚ä¸éœ€è¦æ˜¾å¼åœ°å£°æ˜XXXå®ç°äº†æŸinterface\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type MyInterface { Do() } type MyType struct {} // å®ç°äº†Do()ï¼Œè¿™é‡Œå°±éšå¼å®ç°äº†MyInterfaceæ¥å£ func (p *MyType) Do() { } // Do2()å¯èƒ½æ˜¯å…¶ä»–æ¥å£é‡Œé¢çš„å‡½æ•° func (p *MyType) Do2() { } å¹¶å‘ åœ¨goé‡Œé¢ï¼Œå¤šä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä»æ¥ä¸ä¼šä¸»åŠ¨å…±äº«ï¼š\nDo not communicate by sharing memory; instead, share memory by communicating.\nä¸è¦é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡ï¼Œè€Œåº”é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜ã€‚\nGoroutines goroutineæ˜¯å¹¶å‘çš„ã€è½»é‡çº§çš„ï¼Œä½¿ç”¨ä¹Ÿå¾ˆç®€å•ï¼šgo\n1 go list.Sort() // å¹¶å‘è¿è¡Œ list.Sortï¼Œæ— éœ€ç­‰å®ƒç»“æŸã€‚ Channels Channelå°±æ˜¯ä¸Šé¢æåˆ°çš„ï¼Œgoroutineé—´é€šä¿¡çš„æ–¹å¼ã€‚Channeléœ€è¦ä½¿ç”¨makeæ¥åˆ†é…å†…å­˜ï¼š\n1 2 ci := make(chan int) // æ•´æ•°ç±»å‹çš„æ— ç¼“å†²ä¿¡é“ cs := make(chan *os.File, 100) // æŒ‡å‘æ–‡ä»¶æŒ‡é’ˆçš„å¸¦ç¼“å†²ä¿¡é“ è¿™é‡Œï¼Œç¼“å†²æ˜¯ç”¨æ¥é˜»å¡å‘é€è€…çš„ï¼Œå¦‚æœæ²¡æœ‰ç¼“å†²ï¼Œé‚£ä¹ˆåœ¨æ¥æ”¶è€…æ¥æ”¶åˆ°å€¼ä¹‹å‰ï¼Œå‘é€è€…å°±ä¸€ç›´é˜»å¡ï¼›å¦‚æœæœ‰ç¼“å†²ï¼Œé‚£ä¹ˆå‘é€è€…ä»…åœ¨å€¼è¢«å¤åˆ¶åˆ°ç¼“å†²åŒºå‰é˜»å¡ã€‚\næ¥æ”¶è€…åœ¨æ¥æ”¶åˆ°ç›¸åº”çš„å€¼ä¹‹å‰ä¼šä¸€ç›´é˜»å¡ã€‚ä»¥ä¸Šé¢çš„Sortä¸ºä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 c := make(chan bool) // åˆ†é…ä¸€ä¸ªä¿¡é“ // åœ¨Goç¨‹ä¸­å¯åŠ¨æ’åºã€‚å½“å®ƒå®Œæˆåï¼Œåœ¨ä¿¡é“ä¸Šå‘é€ä¿¡å·ã€‚ go func() { list.Sort() c \u003c- true // å‘é€ä¿¡å·ï¼Œä»€ä¹ˆå€¼æ— æ‰€è°“ã€‚ fmt.Print(\"sorted\") // æ¥æ”¶è€…æ¥æ”¶åˆ°ä¿¡å·ä¹‹å‰ï¼Œä¸ä¼šprint }() doSomethingForAWhile() success \u003c-c // ç­‰å¾…æ’åºç»“æŸï¼Œæ¥æ”¶åˆ°true ","description":"","tags":["go"],"title":"Effective Go","uri":"/posts/engineering/effective-go/"},{"categories":null,"content":"Git commands This post records some powerful git commands which I was not familiar with.\nMerge a specific commit to another branch 1 2 3 4 5 6 7 8 # Merge a commit to current branch git cherry-pick COMMIT_ID # Merge commits in a range(without start commit) git cherry-pick START_COMMIT_ID..END_COMMIT_ID # Merge commits in a range(with start commit) git cherry-pick START_COMMIT_ID^..END_COMMIT_ID In the commands above, the first 6 chars of START_COMMIT_ID and END_COMMIT_ID are enough.\nFor example, commandgit cherry-pick 496986^...acc9bb is same as git cherry-pick 49698603a9c7d1dfdfef0505b52ab2cd4f7ed1a7^...acc9bb290a39275b59cb18e5eb661563fbf08c43.\n--patch If you want to commit some specific changes, you can use --patch option:\n1 git add --patch \u003cfilename\u003e --patch(or -p for short) is a powerful option, which allows you to pick your interested changes in a file or a commit.\nIf you use --patch or -p, the system will ask you whether to stage changes at every chunk:\nApply this hunk to index and worktree [y,n,q,a,d,j,J,g,/,e,?]? The explanation of those options:\ny - apply this hunk to index and worktree n - do not apply this hunk to index and worktree q - quit; do not apply this hunk or any of the remaining ones a - apply this hunk and all later hunks in the file d - do not apply this hunk or any of the later hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk e - manually edit the current hunk ? - print help The most commonly used options are y(accept this chunk) and n(ignore this chunk).\n","description":"","tags":["git"],"title":"Powerful Git Commands","uri":"/posts/others/git-commands/"},{"categories":null,"content":"Overview Language Server Protocol (LSP) defines how the development tools and language servers communicate. The development tool performs as a client while all computation is done in backend language server. In LSP, the communication uses JSON-RPC format.\nHow LSP Works? The following image shows how LSP works:\nAs you can see, the communication between the development tool and the language server can be classified into three types: Notification, Request and Response.\nA request requires a response, while the notification does not.\nA response is sent only after the server or the development tool receives a request.\nIf there is no result for a request, a response is still needed, with the result property set to null\nBase Protocol The base protocol contains a header and a content part. The header and content are seperated by \\r\\n\nHere is an example of LSP message:\n1 2 3 4 5 6 7 8 9 10 Content-Length: ...\\r\\n \\r\\n { \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"textDocument/didOpen\", \"params\": { ... } } Header Part The header consists of header fields, which is a k-v pair seperated by :. Each field ends with \\r\\n.\nFor now, there are only two supported header fields, Content-length: number and Content-type: string, in which the first one is mandatory.\nFor the details of headers, check https://microsoft.github.io/language-server-protocol/specifications/specification-3-14\nContent Part Content part uses JSON-RPC to describe requests, responses and notifications. The charset used is specified in Content-type field in header. By default it's utf-8.\nThe following is the format of messages in TypeScript\nAbstract message First, notification, request and response extend an abstract message format:\n1 2 3 interface Message { jsonrpc: string; } where the LSP uses \"2.0\" as the value of jsonrpc, which is the used JSON-RPC version.\nRequest message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface RequestMessage extends Message { /** * The request id. */ id: number | string; /** * The method to be invoked. */ method: string; /** * The method's params. */ params?: Array\u003cany\u003e | object; } Response message 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface ResponseMessage extends Message { /** * The request id. */ id: number | string | null; /** * The result of a request. This member is REQUIRED on success. * This member MUST NOT exist if there was an error invoking the method. */ result?: string | number | boolean | object | null; /** * The error object in case a request fails. */ error?: ResponseError\u003cany\u003e; } There is an optional error field, the response error is defined as the following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // ResponseError definition interface ResponseError\u003cD\u003e { /** * A number indicating the error type that occurred. */ code: number; /** * A string providing a short description of the error. */ message: string; /** * A Primitive or Structured value that contains additional * information about the error. Can be omitted. */ data?: D; } // Error codes export namespace ErrorCodes { // Defined by JSON RPC export const ParseError: number = -32700; export const InvalidRequest: number = -32600; export const MethodNotFound: number = -32601; export const InvalidParams: number = -32602; export const InternalError: number = -32603; export const serverErrorStart: number = -32099; export const serverErrorEnd: number = -32000; export const ServerNotInitialized: number = -32002; export const UnknownErrorCode: number = -32001; // Defined by the protocol. export const RequestCancelled: number = -32800; export const ContentModified: number = -32801; } Notification message 1 2 3 4 5 6 7 8 9 10 11 interface NotificationMessage extends Message { /** * The method to be invoked. */ method: string; /** * The notification's params. */ params?: Array\u003cany\u003e | object; } Beware that a processed notification message must not send a response back.\n$ Notifications and Requests Notifications and requests which start with $/ are protocol implementation dependent, which means this type of notifications and requests might not be implementated in some LSPs. A server or client would ignore the $ notification or send an error message with error code MethodNotFound as the response of $ request.\nActual Protocol There are some examples for the actual protocol used in LSP\nServer Lifetime The lifetime of a server is managed by the client, that is, the client decides when to start and shutdown the server.\nInitialize request This should be the first request sent from client, and before the client receives InitializeResult response from server, no more request and notification should be sent.\nThe initialize request may only be sent once.\nRequest:\nmethod: 'initialize' params: InitializeParams Response:\nresult: InitializeResult error.code error.data Initialized notification The initialized notification is sent from client to server after the client receives the result of initialize request. This notification is used by server to dynamically register capabilities.\nThe initialized notification may only be sent once as well.\nNotification:\nmethod: 'initialized' params: initializedParams Shutdown request The server uses this request to request the server to shutdown(but to not exit). After this request, the client must not send any notifications or request other than exit notification.\nRequest:\nmethod: 'shutdown' params: void Response:\nresult: null error: code and message set in case an exception happens during shutdown request Exit notification A notification to ask the server to exit its process.\nNotification:\nmethod: 'exit' params: void Language Features Completion Request This request is sent from the client to the server to compute completion items at a given cursor position.\nRequest:\nmethod: 'textDocument/completion' params: CompletionParams 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 export interface CompletionParams extends TextDocumentPositionParams { /** * The completion context. This is only available if the client specifies * to send this using `ClientCapabilities.textDocument.completion.contextSupport === true` */ context?: CompletionContext; } export interface CompletionContext { /** * How the completion was triggered. */ triggerKind: CompletionTriggerKind; /** * The trigger character (a single character) that has trigger code complete. * Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter` */ triggerCharacter?: string; } /** * How a completion was triggered */ export namespace CompletionTriggerKind { /** * Completion was triggered by typing an identifier (24x7 code * complete), manual invocation (e.g Ctrl+Space) or via API. */ export const Invoked: 1 = 1; /** * Completion was triggered by a trigger character specified by * the `triggerCharacters` properties of the `CompletionRegistrationOptions`. */ export const TriggerCharacter: 2 = 2; /** * Completion was re-triggered as the current completion list is incomplete. */ export const TriggerForIncompleteCompletions: 3 = 3; } export type CompletionTriggerKind = 1 | 2 | 3; Response:\nresult:CompletionItem[] | CompletionList | null. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 interface CompletionItem { /** * The label of this completion item. By default * also the text that is inserted when selecting * this completion. */ label: string; /** * The kind of this completion item. Based of the kind * an icon is chosen by the editor. The standardized set * of available values is defined in `CompletionItemKind`. */ kind?: number; /** * A human-readable string with additional information * about this item, like type or symbol information. */ detail?: string; /** * A human-readable string that represents a doc-comment. */ documentation?: string | MarkupContent; /** * Indicates if this item is deprecated. */ deprecated?: boolean; /** * Select this item when showing. * * *Note* that only one completion item can be selected and that the * tool / client decides which item that is. The rule is that the *first* * item of those that match best is selected. */ preselect?: boolean; /** * A string that should be used when comparing this item * with other items. When `falsy` the label is used. */ sortText?: string; /** * A string that should be used when filtering a set of * completion items. When `falsy` the label is used. */ filterText?: string; /** * A string that should be inserted into a document when selecting * this completion. When `falsy` the label is used. * * The `insertText` is subject to interpretation by the client side. * Some tools might not take the string literally. For example * VS Code when code complete is requested in this example `con\u003ccursor position\u003e` * and a completion item with an `insertText` of `console` is provided it * will only insert `sole`. Therefore it is recommended to use `textEdit` instead * since it avoids additional client side interpretation. */ insertText?: string; /** * The format of the insert text. The format applies to both the `insertText` property * and the `newText` property of a provided `textEdit`. If ommitted defaults to * `InsertTextFormat.PlainText`. */ insertTextFormat?: InsertTextFormat; /** * An edit which is applied to a document when selecting this completion. When an edit is provided the value of * `insertText` is ignored. * * *Note:* The range of the edit must be a single line range and it must contain the position at which completion * has been requested. */ textEdit?: TextEdit; /** * An optional array of additional text edits that are applied when * selecting this completion. Edits must not overlap (including the same insert position) * with the main edit nor with themselves. * * Additional text edits should be used to change text unrelated to the current cursor position * (for example adding an import statement at the top of the file if the completion item will * insert an unqualified type). */ additionalTextEdits?: TextEdit[]; /** * An optional set of characters that when pressed while this completion is active will accept it first and * then type that character. *Note* that all commit characters should have `length=1` and that superfluous * characters will be ignored. */ commitCharacters?: string[]; /** * An optional command that is executed *after* inserting this completion. *Note* that * additional modifications to the current document should be described with the * additionalTextEdits-property. */ command?: Command; /** * A data entry field that is preserved on a completion item between * a completion and a completion resolve request. */ data?: any } /** * The kind of a completion entry. */ namespace CompletionItemKind { export const Text = 1; export const Method = 2; export const Function = 3; export const Constructor = 4; export const Field = 5; export const Variable = 6; export const Class = 7; export const Interface = 8; export const Module = 9; export const Property = 10; export const Unit = 11; export const Value = 12; export const Enum = 13; export const Keyword = 14; export const Snippet = 15; export const Color = 16; export const File = 17; export const Reference = 18; export const Folder = 19; export const EnumMember = 20; export const Constant = 21; export const Struct = 22; export const Event = 23; export const Operator = 24; export const TypeParameter = 25; } ","description":"","tags":["lsp","language server protocol","code completion","type script"],"title":"Language Server Protocol","uri":"/posts/code-intelligence/language-server-protocol/"},{"categories":null,"content":"Reference: https://liiked.github.io/VS-Code-Extension-Doc-ZH\nI'm working on improve the performance of code completion tools. Recently, I turned to node.js completion. Hence, I have to learning somethings about extension development in visual studio code, in order to develop a demo to validate and test the model.\nGet Started First, install Yeoman and VS Code Extension Generator\n1 npm install -g yo generator-code Then, run yo code and fill out the necessary information, Yeoman will generate a source folder for VSC extension automatically.\nThen, open VSC and enter the plugin folder, press F5, a test VSC window will be opened. Open VSC command window(shift + command(ctrl) + p) and enter Hello World, the VSC will show a notification which says \"Hello World\" in the right-bottom of the test window:\nCongrats! You've successfully run your first extension!\nBut how does it work? We check the created source folder of the VSC extension first:\n. â”œâ”€â”€ .vscode â”‚ â”œâ”€â”€ launch.json // Config for launching and debugging the extension â”‚ â””â”€â”€ tasks.json // Config for build task that compiles TypeScript â”œâ”€â”€ .gitignore // Ignore build output and node_modules â”œâ”€â”€ README.md // Readable description of your extension's functionality â”œâ”€â”€ src â”‚ â””â”€â”€ extension.ts // Extension source code â”œâ”€â”€ package.json // Extension manifest â”œâ”€â”€ tsconfig.json // TypeScript configuration Each VSC extension must have a package.json, in which we stores information about the extension, such as name, publisher, activationEvents, etc. Some important keywords are listed here:\nname and publisher: VSC uses publisher.name as the identifier of the extension main: entrance file of the extension activationEvents: the event used to activate the extension contributes: configurations, including user defined configurations In the generated source folder, the entry file is extension.js, now let's have a look:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // The module 'vscode' contains the VS Code extensibility API import * as vscode from 'vscode'; // this method is called when your extension is activated // your extension is activated the very first time the command is executed export function activate(context: vscode.ExtensionContext) { // Use the console to output diagnostic information (console.log) and errors (console.error) // This line of code will only be executed **once** when your extension is activated console.log('Congratulations, your extension \"node-completion\" is now active!'); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand('extension.helloWorld', () =\u003e { // The code you place here will be executed every time your command is executed // Display a message box to the user vscode.window.showInformationMessage('Hello VS World!'); }); context.subscriptions.push(disposable); } // this method is called when your extension is deactivated export function deactivate() {} The entry file exports two functions: activate and deactivate. activate will be executed when the activationEvents are triggered, while deactivate is used to clear in workspace before the extension is closed.\nOur first extension contains three parts actually:\nonCommand activationEvents\nThis is defined in package.json's activationEvents field. After defining this, the user can enter Hello World to activate the extension.\n1 2 3 \"activationEvents\": [ \"onCommand:extension.helloWorld\" ] contributes.commands\nThis is also defined in package.json. This field is used to bind the command ID extension.helloWorld with keyword Hello World. With this we can use Hello World command in VSC's command window.\n1 2 3 4 5 6 7 8 \"contributes\": { \"commands\": [ { \"command\": \"extension.helloWorld\", \"title\": \"Hello World\" } ] } vscode.commands.registerCommand\nThis is the VSC API which binds a function with the command ID extension.helloWorld.\nIn the example above, the command extension.helloWorld is registered with a function of lambda expression\n","description":"","tags":["vscode","extension","typescript","node.js"],"title":"VS Code Extension Development(1) - Get Started","uri":"/posts/engineering/vs-code-extension/"},{"categories":null,"content":"Content Source Organization The top level of content folder is ./content/. Under this folder, the contents can be organized and nested at any level. The following is an example:\nThe page origanization conforms to the content source organization. However, each type of pages has an index page, which is the front page when you goes to this category. For instance, the index page of tags looks like: The correspondence between source file paths and site urls is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Content file path . url . âŠ¢--^-âŠ£ . path slug . âŠ¢--^-âŠ£âŠ¢---^---âŠ£ . filepath . âŠ¢------^------âŠ£ content/posts/_index.md # Site urls url (\"/posts/\") âŠ¢-^-âŠ£ baseurl section (\"posts\") âŠ¢--------^---------âŠ£âŠ¢-^-âŠ£ permalink âŠ¢----------^-------------âŠ£ https://example.com/posts/index.html Override Destination Paths in Front Matter In front matter, the slug, url, and layour can be overridden. For example, if a post's path is content/posts/old-post.md, by default, its url would be https://example.com/posts/old-post/. We can set the slug in front matter to change the url:\n1 2 title: New Post slug: \"new-post\" Then the url is changed to https://example.com/posts/new-post/\nThe url can be also overridden by url option in front matter:\n1 2 3 4 title: New Post url: https://example.com/blog/new-url/ # OR url: /blog/new-url/ In the second case, the url will be changed to baseUrl + /blog/new-url/.\nFor more information about url configuration, see URL Management\nSection A section is a collection of pages. Sections are organized under the content/ folder. By default, all first-level folder under content/ are sections. In deeper level, we can create a section by creating a folder with a _index.md file, which indicates that this folder is a section.\nA section cannot be defined or overridden by a front matter parameter â€“ it is strictly derived from the content organization structure.\nHugo provides page variables:\n.CurrentSection .FirstSection .Parent .Section: First path element in the directory .Sections: Sections below this content Content Section vs Content Type Content section is a organization-level concept, while content type is the template of a page, such as draft, post, etc.\nConfig Markdown Renderer The default markdown renderer in Hugo is Blackfriday. There are lots of configurations in config.toml about Blackfriday:\nConfig name Default value Explanation taskLists true Markdown TO-DO List smartypants true Smart punctuation subsitutions, such as (c)-\u003e Â© fractions true Render fractions in a collapsed format extensions [] Enable Blackfriday's Markdown extensions HrefTargetBlank false Open absolute links in a new window or tab ","description":"","tags":["Hugo"],"title":"Learning Hugo(1)","uri":"/posts/others/learning-hugo/"},{"categories":null,"content":"What's Gremlin? Gremlin is used as the graph traversal language on Apache TinkerPop, which is a graph computing framework.\nBasic Concepts Graph:\nCollection of Vertex and Edge.\nElement:\nCollection of Property.\nVertex:\nInherits from Element. Vertex is generally used to store the Property of entities.\nEdge:\nInherits from Element. Edge is generally used to store the Property of relationship.\nProperty\nA k-v pair, where the key is just like the column name in relational database, and the value is stored data in the Edge or Vertex.\nNote that the key must be a string.\nLabel\nThe class for Vertex or Edge. Vertexes and Edges having the same label means they have the same properties. Label can be regarded as the table name in a workplace in relational database.\nUsage of Gremlin Graph, Edge and Vertex All query must start with a graph.\n1 2 3 4 5 6 7 8 // g represents the whole graph // Get all edges g.E() // Get all vertexes g.V() // Get 100 vertexes g.V().limit(100) Property 1 2 3 4 5 6 7 // Get all properties' names for all vertexes g.V().properties().key() // Get property value of all vertexes with property called \"time\" g.V().properties('time').value() // Same, but simpler g.V().values('time') ID Get vertex or edge by id, or get id\n1 2 3 4 // Get vertexes using id g.V('id1') // Get id for all vertexes g.V().id() Label Get vertex or edge by label\n1 2 3 4 // Get vertexes which have label \"software\" g.V().hasLabel('software') // Get out-edge with label \"develops\" of vertex with id \"46\" g.V('46').outE('develops') Filter In Gremlin, we can use hasXXX to filter specific edges or vertexes. Gremlin provides the following commands:\nhas(key, value): filter by property's key and value\nhas(label, key, value): filter by label, and property's key and value\nhas(key, expr): filter by label and an expr. For example, using g.V().has('age', gt(20)) we can get vertexes which have age property and whose value of age is larger than 20.\nhasLabel(label1, label2, ...): filter by label. Elements with label in any one of the label list will pass the filter.\nhasId(id1, id2, ...): filter by id, similar with hasLabel\nhasKey(key1, key2, ...) and has(key): filter by key\n","description":"","tags":["Gremlin","TinkerPop","Graph Database"],"title":"Get Started With Gremlin","uri":"/posts/others/get-started-with-gremlin/"},{"categories":null,"content":"Learning Alfred workflow python sdk.\nInstall Alfred workflow python sdk first: https://www.deanishe.net/alfred-workflow/installation.html\nAdd script runner There are two components in Alfred which can execute a python script: script filter and run script. There are a few differences between script filter and run script, we'll talk about it later.\nThe usage of both components is similar: Note that the Alfred workflow python sdk supports only Python2, since the built-in Python interpreter in Mac OS is Python2.\nYour first python script The following is a simple example of Alfred Python script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/python # -*- coding: utf-8 -*- from __future__ import print_function import sys import os def main(wf): # If the input {query} is not null if len(wf.args): # pass {query} to downstream print(wf.args) if __name__ == '__main__': wf = Workflow3() sys.exit(wf.run(main)) This script passes the input {query} to downstream. In Alfred, all contents which is printed to stdout will be passed to downstream as {query}.\nVariables If we want to pass more information to downstream, Alfred variable is what we need.\nSet variables There are two types of variables: general variable and environment variable. Alfred Python sdk provides difference methods to set different variables. What's more, variable setting is different in run script component and script filter component.\nSet environment variable Alfred Python provides set_config in workflow.util to set environment variables. Here is the API doc, which is quite easy to understand and use.\n1 2 3 4 5 6 7 from workflow.util import set_config, unset_config # Set environment variable set_config(var_name, var_value, bundleid, exportable=False) # Unset environment variable unset_config(var_name, bundleid) Set variables in script filter component In the upstream script filter, root variable and item variable can be used to pass variables to downstream.\n1 2 3 4 5 6 # Add item variable it = wf.add_item(title, subtitle, arg, valid) it.setvar(var_name, var_value) # Add root variable wf.setvar(var_name, var_value) wf.add_item adds an item, which is a collection of variables as well as one candidate in alfred window. When the candidate is chosen, the item is actioned.\nWhen an item is actioned, all variables in arg is passed as {query} to downstream\ntitle and subtitle is the text appears in the alfred window.\nSet variables in run script component In run script component, Variables should be used to store and pass variables.\nHere is an example, we initialize a variable called fail, and pass it to downstream:\n1 2 3 4 5 6 from workflow import Variables if not success: v = Variables() v[\"fail\"] = \"Fail to run script\" print(v) return Get variables In the downstream script, os.getenv(var_name) is used to get variables:\n1 2 import os var_value = os.getenv(var_name) In other components of Alfred, we can use {var:var_name}.\nThe following is an example:\nIf the variable called fail is empty, the downstream component \"open file\" will be executed with the input {query}, where {query} is the file path.\nLogger In Alfred Python, we cannot use print to debug because the printed content will be passed to downstream as {query}. But don't worry, the sdk provdes a logger wf.logger\nLogger initialization:\n1 2 3 4 5 6 7 8 from workflow import Workflow3 log = None if __name__ == '__main__': wf = Workflow3() log = wf.logger sys.exit(wf.run(main)) Then we can use log.error(), log.warn(), log.debug(), log.info() to debug. All info will be printed in debug window when the script is running:\n","description":"","tags":["alfred"],"title":"Alfred Workflow Python Development","uri":"/posts/others/alfred-workflow-python/"},{"categories":null,"content":"Create SSH key First, create ssh key:\n1 ssh-keygen -t rsa -C \"yourmail@mail.com\" Then add the created private key to ssh-agent, and store it in keychain:\n1 ssh-add -K ~/.ssh/id_rsa -K can make sure that the ssh key will always be valid after restart. You can use ssh-add -l to check added ssh keys\nConfig We can use different ssh keys to connect different servers.\nThe configuration file is ~/.ssh/config\nHere is an example config file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Use id_rsa_github to connect to git@github.com Host myhost HostName github.com User git PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github # Use default ssh key to connect to git@gitlab.com Host myhost2 HostName gitlab.com User git PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # Use id_rsa_myserver to connect root@12.34.56.78 Host myhost3 HostName 12.34.56.78 User root PreferedAuthentications publickey IdentityFile ~/.ssh/id_rsa_myserver If the server is not in config file, the default ssh key is ~/.ssh/id_rsa\nGithub setting Please refer to Github Help\n","description":"","tags":["linux"],"title":"SSH on Mac OS","uri":"/posts/engineering/ssh/"},{"categories":null,"content":"Before we start to develop an Alfred workflow, we should learn some basic concepts first.\nPrerequisites: https://www.alfredapp.com/help/workflows/\nWorkflow development basics There are five categories of workflow node in Alfred: Triggers, Inputs, Actions, Utilities, Outputs\nThe two most important categories are Inputs and Actions. The first one read inputs from various sources, and the latter one are what does the workflow do.\nInputs There are 5 types of inputs:\nKeyword\nFile filter\nFind a file, pass file_path as the {query}\nDictionary Filter\nList filter\nScript Filter\nFile Filter File types in file filter is used to narrow the scope of searched files. For example, a png file's file types tree (from precise classification to broadest classification) can be:\npublic.png -\u003e public.image -\u003e public.data -\u003e public.item -\u003e public.content\nScript Filter The most used input filter. A bash script is used to process the input, including execute a python/ruby/perl/go/... program. Hence, in most cases, we can do all what we want to do in script filter.\nActions There are 12 actions in Alfred, including open file/app/url, run system command, terminal command, etc. If the given actions cannot satisfy your requirement, Alfred also provide an action called run script. Just like a script filter. But there are a few differences between script filter and run script. We'll talk about it latter.\nVariables Please read https://www.alfredapp.com/help/workflows/advanced/variables/ as the prerequisites first.\nVariables are just like variables in programming, which stores values, results and informations.\nIn Alfred, we can use {var:var_name} to get the value of variable var_name. BTW, {query} can be also regarded as a special variable.\nA general variable is valid for node in downstream, and the environment variable is always valid in the workflow.\nPlaceholder Alfred offers dynamic placeholders, which allow you to insert dynamically-created content. All variables can be accessed using placeholder. The placeholder's format is {placeholder:variation}, where variation is used to specify the advanced options when Alfred replaces the placeholder with the dynamic content.\nThere are some useful placeholders, all of them have variations, for those details, pls refer to this page\n{query} {var:var_name}, {allvars} {date}, {time}, {datetime} {clipboard:0}, {clipboard:n}: n-th item in clipboard {random} What's more, placeholders have modifiers, which provides more possibilities. The modifiers follow this format: {placeholder:variation.modifier}\nThe following are allowed modifiers:\nuppercase, lowercase, captitals, capitalcase\ntrim\nreverse\nstripdiacritics: remove accented characters\nstripnonalphanumeric: remove non-alphanumeric characters\nDebugger Debugger is quite useful in the workflow development. It prints values you want to debug window. By default, it prints {query} and {allvars}.\n","description":"","tags":["alfred"],"title":"Alfred Workflow Basics","uri":"/posts/others/alfred-workflow-basics/"},{"categories":null,"content":"å¸¸ç”¨å‘½ä»¤ Normal Mode æŒ‰é”® å«ä¹‰ \u003e\u003e å‘å³ç¼©è¿› \u003c\u003c å‘å·¦ç¼©è¿› ctrl w + hjkl è·³è½¬çª—å£åˆ°æ–¹å‘ ctrl w + w ä¸‹ä¸€ä¸ªçª—å£ Command Mode å‘½ä»¤ å«ä¹‰ :sp ä¸Šä¸‹æ‹†åˆ†çª—å£ :vsp å·¦å³æ‹†åˆ†çª—å£ æœç´¢å’Œæ›¿æ¢ æ›¿æ¢çš„è¯­æ³•ï¼šèŒƒå›´s/original_text/replacement/æ›¿æ¢é€‰é¡¹\næ›¿æ¢å½“å‰è¡Œï¼šs/orginal_text/replacement/gï¼Œgä¸ºglobalå…¨å±€æ›¿æ¢ï¼Œå³æ›¿æ¢èŒƒå›´å†…çš„æ‰€æœ‰ç›®æ ‡\næ›¿æ¢èŒƒå›´ æ›¿æ¢æ‰€æœ‰è¡Œåªéœ€è¦åœ¨å‰é¢åŠ ä¸ª%ï¼Œå³%s/orginal_text/replacement/g\né€‰æ‹©åŒºåŸŸæ›¿æ¢ï¼šå…ˆctrl+vè¿›å…¥Visual Modeï¼Œé€‰æ‹©å®ŒåŒºåŸŸåè¾“å…¥:è¿›å…¥å‘½ä»¤è¡Œæ¨¡å¼ï¼ŒèŒƒå›´å°±è‡ªåŠ¨æ·»åŠ äº†ï¼Œåé¢ä¸€æ ·ã€‚ä¹Ÿå¯ä»¥æ‰‹åŠ¨æŒ‡å®šï¼Œå¦‚ï¼š2,12s/original_text/replacement/gæœç´¢2åˆ°12è¡Œï¼›.,+5s/original_text/replacement/gè¡¨ç¤ºæœç´¢å½“å‰è¡Œ.å’Œæ¥ä¸‹æ¥5è¡Œ+5\næ›¿æ¢é€‰é¡¹ gï¼šglobalæ›¿æ¢\ni/Iï¼šå¤§å°å†™ä¸æ•æ„Ÿ/æ•æ„Ÿ\ncï¼šéœ€è¦ç¡®è®¤\nCoC ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨coc.nvimä¸­ï¼Œtabé€‰æ‹©ï¼Œå›è½¦æˆ–è€…ç»§ç»­æ‰“å­—ç¡®å®š\nä¸€äº›å…¶ä»–çš„å¢å¼ºåŠŸèƒ½å¦‚ä¸‹è¡¨ï¼š\næ³¨æ„ï¼Œå…¶ä¸­\\ä¸º\u003cleader\u003eé”®ï¼Œåœ¨vimrcä¸­ï¼Œ\u003cleader\u003erå³ä¸º\\rã€‚Leaderé”®ä¸€èˆ¬ç”¨æ¥è¡¨ç¤ºè‡ªå®šä¹‰çš„ä¸€äº›å¿«æ·é”®\næŒ‰é”® å«ä¹‰ gd è½¬åˆ°å®šä¹‰ gy è½¬åˆ°ç±»å‹çš„å®šä¹‰ gi è½¬åˆ°å®ç° gr è½¬åˆ°reference \\r æ›¿æ¢ä¸‹ä¸€ä¸ªå•è¯ \\f formaté€‰å®šçš„åŒºåŸŸ ","description":"","tags":["vim"],"title":"Vim å‘½ä»¤","uri":"/posts/others/vim/"},{"categories":null,"content":"What's Hugo? Hugo is a popular open-source static site generator. After my painful journey on trying Hexo and Jekyll, Hugo makes me happy.\nGet Started Install Hugo on Mac OS. 1 brew install hugo Initialize the first website. 1 hugo new site your-folder-name Set Github repo I'm using two repos for my blog: one stores all source files of hugo and the other stores generated websites.\nFirst, create a repo for source files in Github.\nFor example, my source repo is github.com/HaoboGu/source-haobogu.github.io.\nAfter the repo for source files is created, set local hugo folder to track the repo.\n1 2 3 4 5 6 7 8 9 10 cd your-folder-name # Git initialization git init # Commit hugo files git add . git commit -m \"first commit\" # Track your remote repo git remote add origin git@github.com:HaoboGu/source-haobogu.github.io.git git push -u origin master Add a theme Hugo doesn't have a built-in theme, so I decided to use hugo-nuo(my edited version). You can choose one from themes.gohugo.io/.\n1 2 3 4 5 # Import the hugo-nuo theme as a git submodule git submodule add git@github.com:HaoboGu/hugo-nuo.git themes/hugo-nuo # Add theme to config file echo 'theme = \"hugo-nuo\"' \u003e\u003e config.toml Add first page 1 hugo new posts/Hello-Hugo.md You may notice that there is a generated header in the markdown file. This header is called front matter. By default, this page will not be publised because draft = true option in front matter template.\nTest your site locally Run\n1 2 # -D means draft will be publised hugo server -D Then navigate to your site at http://localhost:1313/.\nDeploy site to Github Pages Create your Github Pages repo for hosting generated site.\nSuppose the site repo is github.com/HaoboGu/haobogu.github.io, then run\n1 2 3 4 # Delete generated public folder rm -rf public # Set public folder as a submodule which tracks Github Pages repo git submodule add -b master git@github.com:\u003cUSERNAME\u003e/\u003cUSERNAME\u003e.github.io.git public Create script deploy.sh, then run this script to deploy the website\n1 2 3 chmod +x deploy.sh ./deploy.sh DONE!\n","description":"","tags":["hugo"],"title":"Get Started with Hugo","uri":"/posts/others/get-started-with-hugo/"},{"categories":null,"content":"Blender å¸¸ç”¨å¿«æ·é”® æœ€å¸¸ç”¨ gï¼šç§»åŠ¨ rï¼šæ—‹è½¬ sï¼šç¼©æ”¾ xyzï¼šè½´å‘ã€‚æ¯”å¦‚æƒ³è¦æŒ‰ç…§xè½´ç§»åŠ¨ï¼Œé‚£ä¹ˆå°±gxå³å¯ï¼›å¦‚æœæƒ³è¦xè½´ä¸å˜ï¼Œåœ¨yzè½´å‘ä¸Šç§»åŠ¨ï¼Œåˆ™ç”¨g shift+x shift+rï¼šé‡å¤ä¸Šä¸€æ­¥æ“ä½œ æ¨¡å¼åˆ‡æ¢ tabï¼šè¿›å…¥ç½‘æ ¼ç¼–è¾‘æ¨¡å¼ æ¸¸æ ‡ shift + sï¼šè®¾å®šæ¸¸æ ‡åˆ°å½“å‰ä½ç½® ç¼–è¾‘æ¨¡å¼ åœ¨ç‰©ä½“æ¨¡å¼ï¼ˆé»˜è®¤æ¨¡å¼ï¼‰ä¸‹æŒ‰tabå¯ä»¥è¿›å…¥ç¼–è¾‘æ¨¡å¼ä¹‹åï¼Œå¯ä»¥åœ¨å·¦ä¸Šè§’é€‰æ‹©ç‚¹çº¿é¢æ¨¡å¼ã€‚å·¦ä¸Šè§’ä¼šæ˜¾ç¤ºå½“å‰æ‰€å¤„çš„æ¨¡å¼ï¼Œä¹Ÿå¯ä»¥æ‰‹åŠ¨åˆ‡æ¢ï¼š\nå¯ä»¥æŒ‰shiftåŒæ—¶é€‰æ‹©ç‚¹ã€çº¿ã€é¢æ¨¡å¼ã€‚\nç»Ÿè®¡ä¿¡æ¯ å¦‚æœæƒ³çœ‹å½“å‰è§†å›¾ä¸­é€‰æ‹©äº†å¤šå°‘ä¸ªç‚¹çº¿é¢çš„ç»Ÿè®¡ï¼Œå¯ä»¥åœ¨è§†å›¾å åŠ å±‚é€‰æ‹©ç»Ÿè®¡ä¿¡æ¯ï¼š\nå¦‚æœæ²¡æœ‰ç‰©ä½“è¢«é€‰æ‹©æ˜¾ç¤ºçš„æ˜¯æ‰€æœ‰ç‰©ä½“çš„å’Œã€‚å¦‚æœæœ‰ç‰©ä½“è¢«é€‰æ‹©ï¼Œé‚£ä¹ˆè¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼Œå°±æ˜¾ç¤ºå½“å‰é€‰ä¸­çš„æ‰€æœ‰ç‰©ä½“çš„ç»Ÿè®¡ä¿¡æ¯ã€‚\næŒ¤å‡º è¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼Œç„¶åæŒ‰å¿«æ·é”®Eï¼Œå³å¯æŒ¤å‡ºã€‚\nå¿«é€Ÿé€‰æ‹©æŒ¤å‡ºçš„é€‰é¡¹ï¼šalt(option)+E\nå€’è§’ é»˜è®¤å¿«æ·é”®æ˜¯ ctrl/cmd + Bï¼Œé¼ æ ‡æ»šè½®å¯ä»¥æ§åˆ¶åˆ†æ®µæ•°ã€‚æ³¨æ„å¯ä»¥åœ¨è¾¹æ¨¡å¼ä¸­å•ç‹¬å¯¹æŸä¸ªè¾¹åšå€’è§’ï¼Œåœ¨ç‚¹æ¨¡å¼å¯ä»¥å¯¹æŸä¸ªç‚¹/è§’åšå€’è§’ã€‚\nåœ¨å·¦é”®ç¡®è®¤ä¹‹åï¼Œä¼šå¼¹å‡ºèœå•ã€‚èœå•é‡Œé¢æœ‰ä¸€äº›å€’è§’çš„é€‰é¡¹ã€‚å¯ä»¥æ³¨æ„æœ‰3å¤§ä¸»è¦å‚æ•°ï¼šå®½åº¦ã€æ®µæ•°å’Œå½¢çŠ¶ã€‚å®½åº¦å°±æ˜¯å€’è§’çš„èŒƒå›´ï¼Œæ®µæ•°å°±æ˜¯åˆ†æˆå¤šå°‘æ®µï¼Œå½¢çŠ¶æ˜¯0~1çš„å‚æ•°ã€‚\nå‚æ•°ï¼š\nå®½åº¦ç±»å‹ï¼šçœ‹ä¸‹å›¾\næè´¨ï¼šå€’è§’çš„æè´¨ã€‚é»˜è®¤-1ä¼šé€‰æ‹©ç›¸é‚»çš„é¢çš„æè´¨ï¼Œå¤§æ¦‚æ˜¯è¿™æ ·ï¼š\næè´¨å¯ä»¥é€‰æ‹©0123è¿™æ ·çš„æ•°å­—ï¼Œè¿™ä¸ªæ•°å­—ä»£è¡¨åœ¨æè´¨ç•Œé¢çš„é¡ºåºã€‚\nç¡¬åŒ–å€’è§’ï¼šå…‰æ»‘å€’è§’ã€‚ç±»ä¼¼å³é”®-å¹³æ»‘ç€è‰²ã€‚å¯ä»¥è®©é¢å‘ç°å¤§äºxxåº¦çš„å€’è§’å…‰æ»‘èµ·æ¥\nå¤–æ–œæ¥ã€å†…æ–œæ¥ï¼šå€’è§’å’Œå…¶ä»–é¢ç›¸é‚»çš„æ—¶å€™çš„ç›¸äº¤å½¢çŠ¶\nåœ¨å€’è§’çš„æ—¶å€™ï¼Œéœ€è¦æ³¨æ„ç‰©ä½“æ˜¯å¦è¢«ç¼©æ”¾äº†ã€‚ç¼©æ”¾æœ‰å¯èƒ½å¯¼è‡´å¯¼è‡´å€’è§’çš„ä¸å‡åŒ€ã€‚å¦‚æœç¡®å®éœ€è¦æœ‰ç¼©æ”¾çš„ï¼Œåœ¨è°ƒæ•´å®Œä¹‹åå¯ä»¥å³é”®-å…¨éƒ¨åº”ç”¨ï¼Œè¿™æ ·å¯ä»¥çœ‹åˆ°å·¦è¾¹çš„ç¼©æ”¾éƒ½å˜æˆäº†1ï¼Œè¿™æ ·å†å€’è§’å°±å‡åŒ€äº†ã€‚\nå¾ªç¯åˆ‡å‰² ä¸€äº›åŸºç¡€æ¦‚å¿µ å¹¶æ’è¾¹ é¦–å…ˆï¼Œåªæœ‰å››è¾¹å½¢æœ‰å¹¶æ’è¾¹ï¼ˆå³å¯¹è¾¹ï¼‰ã€‚ä¸‰è§’å½¢æ²¡æœ‰ï¼Œè€Œå¤šè¾¹å½¢æ²¡æœ‰åŠæ³•ç¡®å®šå”¯ä¸€çš„å¯¹è¾¹ã€‚å› æ­¤åœ¨è€ƒè™‘å¹¶æ’è¾¹çš„æ—¶å€™åªè€ƒè™‘å››è¾¹å½¢ï¼ˆå››è¾¹é¢ï¼‰ã€‚\nå¾ªç¯è¾¹ åœ¨ç½‘æ ¼æ£‹ç›˜ä¸­ï¼Œä¸€æ¡è¾¹å¯ä»¥å¾€ä¸‹ä¼ é€’ï¼Œä¸ºå¾ªç¯è¾¹ã€‚ä¸€ä¸ªè¾¹çš„å¾ªç¯è¾¹ä¸èƒ½å’Œå½“å‰è¾¹ç›´æ¥ç»„æˆå››è¾¹å½¢ï¼ˆé‡Œé¢ä¸åŒ…å«å…¶ä»–è¾¹ï¼Œå¦‚ä¸‹å›¾å‚ç›´çš„è¾¹éƒ½ä¸è¡Œï¼‰ã€‚å¾ªç¯è¾¹é‡åˆ°æç‚¹æˆ–è¾¹ç•Œè¾¹çš„æ—¶å€™ä¼šåœæ­¢ï¼š\nç™½è‰²å…‰æ ‡çš„ä½ç½®å°±æ˜¯æç‚¹ï¼Œå¯ä»¥çœ‹åˆ°ä»æç‚¹æ²¡åŠæ³•å¾€ä¸‹ä¼ é€’äº†ï¼Œå› ä¸ºç³»ç»Ÿä¸çŸ¥é“æ˜¯é€‰æ‹©ç›´ç€ä¼ è¿˜æ˜¯å¾€å³ä¸Šè§’èµ°ã€‚\nå¾ªç¯è¾¹åˆ‡å‰² åœ¨æœ¬è´¨ä¸Šï¼Œå¾ªç¯åˆ‡å‰²å°±æ˜¯åœ¨å¯¹ä¸€å¯¹å¹¶æ’è¾¹è¿›è¡Œç»†åˆ†ï¼ˆåˆ†æˆä¸¤ä¸ªè¾¹ï¼‰ï¼Œç„¶åè¿æ¥ä¸¤ä¸ªç‚¹å¯¹å½“å‰é¢è¿›è¡Œåˆ‡å‰²ï¼Œç„¶åå†å¯¹åˆ‡å‰²çš„è¿™æ¡è¾¹è¿›è¡Œå¾ªç¯ä¼ é€’å°±æ˜¯å¾ªç¯åˆ‡å‰²ã€‚å¦‚ä¸‹ç¤ºæ„å›¾ï¼š\nå¯ä»¥çœ‹åˆ°æ©˜é»„è‰²æ ‡æ³¨çš„è¾¹éƒ½æ˜¯å¹¶æ’è¾¹ï¼Œè€Œäº®é»„è‰²çš„å°±æ˜¯å¾ªç¯è¾¹åˆ‡å‰²ã€‚åˆ‡å‰²çš„éƒ½æ˜¯å››è¾¹å½¢ã€‚\nç¯åˆ‡å·¥å…· é¦–å…ˆè¿˜æ˜¯å¿«æ·é”®ï¼šctrl/cmd + Rã€‚æŒ‰å·¦é”®ç¡®è®¤ï¼Œç„¶åå¯ä»¥è°ƒæ•´è¾¹çº¿ã€‚\nåœ¨blenderä¸­ï¼Œå¾ªç¯è¾¹åˆ‡å‰²å·¥å…·è¿˜æœ‰å…¶ä»–çš„ä¸€äº›é¢å¤–é€‰é¡¹ï¼š\nåˆ‡å‰²æ¬¡æ•°ï¼šå°±æ˜¯åˆ‡å‰²å¤šå°‘æ¬¡ï¼Œåˆ‡å‡ åˆ€ã€‚åœ¨é¢„åˆ‡å‰²çŠ¶æ€ï¼ˆæŒ‰å®Œcmd+Rï¼‰ï¼Œå¯ä»¥ä½¿ç”¨é¼ æ ‡çš„æ»šè½®è¿›è¡Œè°ƒæ•´ å¹³æ»‘åº¦ã€è¡°å‡ã€ç³»æ•°ï¼šåˆ‡å®Œä¹‹åä¼šå¯¹å½¢çŠ¶æœ‰å½±å“ã€‚è¿™äº›å‚æ•°å°±æ˜¯è°ƒæ•´åˆ‡å‰²åçš„å½¢çŠ¶çš„ é’³åˆ¶ï¼šå¼ºåˆ¶ç³»æ•°åœ¨-1~1ï¼Œå³ä¸ä¼šè¶…è¿‡å½“å‰çš„ç‰©ä½“è¾¹ç¼˜ã€‚å¦åˆ™å¯èƒ½ä¼šè¶…è¿‡ å‡åŒ€ã€ç¿»è½¬ï¼šæœ‰æ—¶å€™å¹¶æ’è¾¹å¹¶ä¸æ˜¯å‚ç›´çš„ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªé€‰é¡¹å¯ä»¥è®©åˆ‡å‰²çº¿å’Œå·¦è¾¹æˆ–è€…å³è¾¹ä¸€æ ·ã€‚ åæ ‡ç³» åœ¨blenderä¸­ï¼Œåæ ‡ç³»çš„é€‰æ‹©åœ¨é¡¶éƒ¨è¿™é‡Œï¼ˆå¿«æ·é”®ä¸º,ï¼‰\nåœ¨è¿™é‡Œæˆ‘ä»¬æœ‰è‹¥å¹²é€‰æ‹©ï¼Œä¸‹é¢åˆ†åˆ«è¯´æ˜ã€‚\nå…¨å±€ï¼šå°±æ˜¯å›ºå®šä¸å˜çš„åæ ‡ç³»ï¼Œç±»ä¼¼äºä¸œå—è¥¿åŒ—\nå±€éƒ¨ï¼šé’ˆå¯¹é€‰ä¸­ç‰©ä½“çš„æœå‘çš„åæ ‡ç³»ï¼Œç±»ä¼¼å‰åå·¦å³\næ³•å‘ï¼šæŸä¸ªé¢çš„æ³•çº¿æ–¹å‘ä¸ºä¸»çš„åæ ‡ç³»\nä¸‡å‘ï¼šå…¶ä¸­ä¸¤ä¸ªè½´æ˜¯å›ºå®šçš„ï¼Œç¬¬ä¸‰ä¸ªè½´å¯ä»¥æ—‹è½¬ã€‚æƒ³è±¡ä¸€ä¸‹ä¸‡å‘è½®ï¼ŒæŠŠxè½´å½“æˆæ—‹è½¬è½´ï¼Œè½®å­å°±ç»•ç€xè½´è½¬ï¼›ç„¶åzè½´æ˜¯è½¬å‘è½´ï¼Œè½¬åŠ¨çš„æ–¹å‘å¯ä»¥å˜\nå¯¹äºä¸‡å‘åæ ‡ç³»æ¥è¯´ï¼Œåœ¨å³ä¾§çš„å˜æ¢-æ¨¡å¼ä¸­å¯ä»¥é€‰æ‹©XYZçš„ç±»å‹ã€‚YXZçš„æ„æ€å°±æ˜¯ï¼Œyè½´ç»•xè½´æ—‹è½¬ï¼Œè€Œxyè½´ç»•zè½´æ—‹è½¬ã€‚\nè§†å›¾ï¼šä»¥å½“å‰è§†çª—ï¼ˆå±å¹•ï¼‰ä¸ºä¸»çš„åæ ‡è½´ã€‚å·¦å³ä¸ºxï¼Œä¸Šä¸‹ä¸ºyï¼Œå‰åä¸ºz\næ¸¸æ ‡ï¼šå°±æ˜¯blenderåˆšå¼€å§‹æœ€ä¸­å¿ƒçš„é‚£ä¸ªæ¸¸æ ‡çš„åæ ‡ç³»ã€‚æ¸¸æ ‡æ˜¯å¯ä»¥ç§»åŠ¨çš„ä¸”æœ‰æœå‘çš„ã€‚å¦‚æœé€‰æ‹©äº†æ¸¸æ ‡åæ ‡ç³»ï¼Œé‚£ä¹ˆå½“å‰ç‰©å“çš„åæ ‡ç³»å°±å’Œæ¸¸æ ‡æ˜¯ä¸€æ ·çš„äº†\nåŸç‚¹ æ¯ä¸ªç‰©å“éƒ½æœ‰ä¸€ä¸ªåŸç‚¹ã€‚å¯¹æ¨¡å‹çš„æ“ä½œï¼Œå¦‚ç¼©æ”¾ã€æ—‹è½¬ã€å½’é›¶ç­‰å®é™…ä¸Šéƒ½æ˜¯åŸºäºåŸç‚¹çš„ã€‚ä¸€èˆ¬æ¥è¯´æ˜¯ç‰©ä½“çš„è´¨å¿ƒã€‚åœ¨Blenderä¸­å¯ä»¥éšæ„ç§»åŠ¨åŸç‚¹ï¼Œåªéœ€è¦åœ¨å³ä¸Šè§’çš„é€‰é¡¹é‡Œé¢å‹¾é€‰ä»…å½±å“åŸç‚¹å³å¯ï¼š\nå½“ç„¶ï¼Œå¦‚æœä½ ä¸å°å¿ƒç§»åŠ¨äº†åŸç‚¹ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ é€‰ä¸­ç‰©ä½“ - å³é”®èœå• - è®¾ç½®è¿œç‚¹æ¥é‡è®¾åŸç‚¹\nè¾¹ç•Œæ¡†ä¸­å¿ƒ åœ¨blenderé‡Œé¢ï¼Œè¿˜æœ‰ä¸€ä¸ªè¾¹ç•Œæ¡†ä¸­å¿ƒæ¯”è¾ƒå®¹æ˜“å’ŒåŸç‚¹æ··æ·†ã€‚è¾¹ç•Œæ¡†ä¸­å¿ƒæ˜¯æ¯ä¸ªç‰©ä½“çš„è¾¹ç•Œæ¡†ï¼ˆç«‹æ–¹ä½“ï¼‰çš„ä¸­å¿ƒã€‚\nè½´å¿ƒç‚¹ å¸é™„ å¼€å…³ æ‰“å¼€å¸é™„ï¼šå•å‡»é¡¶éƒ¨èœå•æ çš„ç£é“å›¾æ ‡ï¼Œæˆ–è€…å¿«æ·é”®shift+tab:\nä¸´æ—¶æ‰“å¼€/å…³é—­ï¼šåœ¨ç§»åŠ¨æ¨¡å¼ä¸‹ï¼ŒæŒ‰ä½ctrlï¼Œå°±å¯ä»¥åˆ‡æ¢å¸é™„æ¨¡å¼çš„å¼€å…³ï¼›æ¾å¼€æ¢å¤ã€‚\nå¸é™„é€‰é¡¹ blenderæœ‰å¦‚ä¸‹è‹¥å¹²ä¸ªå¸é™„é€‰é¡¹ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¸é™„è‡³é€‰é¡¹éƒ½æ˜¯é’ˆå¯¹è¢«å¸é™„å¯¹è±¡æ¥è¯´çš„ï¼š\nè€Œå¸é™„åŸºå‡†ç‚¹ï¼Œæ˜¯å¸é™„å¯¹è±¡çš„ç‚¹å¦‚è´¨å¿ƒã€è¾¹ç¼˜ç­‰ã€‚\n","description":"","tags":null,"title":"Haobo's Blog","uri":"/posts/keyboard/blender/"},{"categories":null,"content":"Keeb ä¸€äº› Essentials å¯¹äºé”®ç›˜æ¥è¯´ï¼Œä»ç”¨æˆ·çš„è§’åº¦ï¼Œæ˜¯ç”±æŒ‰é”®ç»„æˆçš„ï¼ˆç¼–ç å™¨/è™šæ‹ŸæŒ‰é”®ç­‰ï¼Œæš‚ä¸è€ƒè™‘ï¼‰ã€‚\nä¸€ä¸ªä¸€ä¸ªçš„æŒ‰é”®ï¼Œç»„æˆäº†é”®ç›˜çš„å¸ƒå±€ï¼Œç”¨æˆ·æ ¹æ®å¸ƒå±€æ“ä½œæ¯ä¸€ä¸ªæŒ‰é”®ã€‚ å› æ­¤ï¼Œlayoutæ˜¯æœ€ä¸Šå±‚çš„æ¦‚å¿µã€‚å¯¹äºè½¯ä»¶æ¥è¯´ï¼ŒlayoutåŒ…å«å¦‚ä¸‹ç‰¹æ€§ï¼š\nlayoutå…±æœ‰å¤šå°‘è¡Œã€åˆ— layoutçš„æ¯ä¸€ä¸ªä½ç½®å’ŒPCBä¸­çš„çŸ©é˜µçš„å¯¹åº”å…³ç³»ï¼Œå“ªäº›ä½ç½®æœ‰æŒ‰é”®ï¼Œå“ªäº›æ²¡æœ‰ã€‚ layoutå­˜çš„æ˜¯é”®ä½çš„è®¾ç½®ï¼Œè€Œæ¯ä¸ªé”®ä½çš„å…·ä½“åŠŸèƒ½ï¼Œåˆ™å­˜åœ¨å’Œlayoutå¯¹åº”çš„keymapä¸­ã€‚ åœ¨Keymapä¸­ï¼Œå­˜å‚¨çš„æ˜¯æ¯ä¸ªæŒ‰é”®çš„æŒ‰ä¸‹åçš„å…·ä½“åŠŸèƒ½ Action ã€‚ä¸€ä¸ªkeymapå¯ä»¥æœ‰å¤šä¸ªlayerï¼Œkeymapå’Œlayerçš„å…³ç³»ï¼Œå¯ä»¥å‚è€ƒ https://docs.qmk.fm/#/keymap ã€‚\nåœ¨å®é™…ç”¨æˆ·ä½¿ç”¨çš„æ—¶å€™ï¼Œé¦–å…ˆæ˜¯è¦è·å–ç”¨æˆ·è§¦å‘çš„é”®ä½ position ï¼Œç„¶ååˆ¤æ–­ç”¨æˆ·çš„ TriggerTypeï¼ˆè§¦å‘æ–¹å¼ï¼‰ã€‚ å¯¹äºé”®ç›˜æ¥è¯´ï¼Œæ¯ä¸€ä¸ªæŒ‰é”®å¯ä»¥æœ‰å¦‚ä¸‹çš„è§¦å‘æ–¹å¼ï¼š\næŒ‰ä¸‹/æŠ¬èµ·ï¼šæœ€æ™®é€šçš„è§¦å‘æ–¹å¼ tapï¼šæŠŠå¿«é€ŸæŒ‰ä¸‹+æŠ¬èµ·ç»„åˆèµ·æ¥ï¼Œçœ‹åšæ˜¯ä¸€ä¸ªåŠ¨ä½œã€‚åªæœ‰å®Œæˆäº†æ•´ä¸ªçš„tapåŠ¨ä½œï¼Œæ‰ä¼šè§¦å‘ã€‚tapä¸€èˆ¬éƒ½æœ‰ä¸€ä¸ªæ—¶é—´ä¸Šé™ï¼Œåœ¨æ—¶é—´ä¸Šé™å†…å®Œæˆ æŒ‰ä¸‹+æŠ¬èµ·ï¼Œå¯ä»¥è¯†åˆ«ä¸ºtap tapNï¼šè¿ç»­Næ¬¡tap holdï¼šé•¿æŒ‰ï¼Œæœ‰ä¸€ä¸ªæœ€ä½æ—¶é—´ã€‚ NOï¼šæ²¡æœ‰åŠ¨ä½œï¼Œé»˜è®¤çš„ ç„¶åï¼Œæ ¹æ®å¯¹åº” keymap + position é‡Œé¢å­˜å‚¨çš„ Actionï¼Œå†åŠ ä¸Š TriggerTypeï¼Œå°±èƒ½å¾—åˆ°é”®ç›˜æœ€ç»ˆæ‰§è¡Œçš„åŠ¨ä½œã€‚\nå³ Position + TriggerType + Action = What's executed by keyboard(aka KeyboardAction).\nç„¶åï¼Œé”®ç›˜ dispatch æ‰€æœ‰çš„ KeyboardActionï¼Œå»æ‰§è¡Œç›¸å…³æ“ä½œã€‚\nDefinitions keycodeï¼šé”®ç \né”®ç åº”è¯¥æœ‰ 2 å¥—ï¼š ç³»ç»Ÿæ”¯æŒçš„é”®ç  å†…éƒ¨çš„é”®ç ï¼ŒåŒ…å«ç³»ç»Ÿæ”¯æŒé”®ç  + å†…éƒ¨åŠŸèƒ½ï¼ˆæ¯”å¦‚åˆ‡å±‚ã€RGBã€éŸ³é¢‘æ§åˆ¶ç­‰ç­‰ï¼‰ layoutï¼šå¸ƒå±€\néœ€è¦æ”¯æŒKLE è¦ç‚¹ï¼šé”®ä½ã€PCBçŸ©é˜µä½ç½®ã€å½¢çŠ¶ \u0026 è§’åº¦ layoutéœ€è¦å’Œå…·ä½“çš„é”®ä½positionç»‘å®šã€‚ç„¶åï¼Œæ¯ä¸ªé”®ä½æœ‰Xç§è§¦å‘æ–¹å¼ï¼Œæ¯ä¸€ç§è§¦å‘æ–¹å¼æœ‰Yç§åŠŸèƒ½ã€‚ matrixï¼šPCBçŸ©é˜µï¼Œå’Œlayoutå­˜åœ¨æœ‰é™çš„å¯¹åº”\nlayerï¼šå±‚ QMKä¸­ï¼Œä¸€å…±æ”¯æŒ32å±‚ï¼Œå¯ä»¥åŒæ—¶æ¿€æ´»å¤šä¸ªå±‚ï¼Œå¤šä¸ªå±‚åŒæ—¶æ¿€æ´»çš„æ—¶å€™ï¼Œä¼šä»é«˜å¾€ä½é€ä¸ªæ‰«æï¼Œå¦‚æœæ˜¯KC_TRANSï¼Œå°±è¿›åˆ°ä½å±‚ï¼Œç›´åˆ°åœ¨æŸå±‚æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æŒ‰é”®ã€‚æ”¯æŒå¦‚ä¸‹åˆ‡å±‚åŠŸèƒ½ï¼š\nDF(layer): è®¾ç½®é»˜è®¤å±‚ï¼Œé»˜è®¤å±‚é»˜è®¤ä¸€ç›´æ˜¯æ¿€æ´»çŠ¶æ€ã€‚ã€‚é»˜è®¤å±‚ä¸€èˆ¬éƒ½æ˜¯ç¬¬0å±‚ï¼Œä¹Ÿå°±æ˜¯æœ€ä¸‹é¢çš„ä¸€å±‚ MO(layer): ä¸´æ—¶æ¿€æ´»æŸä¸€å±‚ï¼Œæ¯”å¦‚MO(1)å°±æ˜¯ä¸´æ—¶æ¿€æ´»ç¬¬1å±‚ï¼Œæ¾å¼€è¿™ä¸ªæŒ‰é”®çš„æ—¶å€™å¤±æ•ˆ LM(layer, mod): ä¹Ÿæ˜¯ä¸´æ—¶æ¿€æ´»æŸå±‚ï¼ŒåŒºåˆ«æ˜¯LMè‡ªå¸¦æŸä¸ªmodifierï¼ˆä¸ç”¨æ‰‹å†å»æŒ‰äº†ï¼‰ LT(layer, kc): åŒåŠŸèƒ½ï¼Œé•¿æŒ‰æ˜¯æ¿€æ´»æŸä¸€å±‚ï¼Œå•å‡»æ˜¯è§¦å‘å¯¹åº”çš„keycode OSL(layer): æŒ‰ä¸€ä¸‹ä¸´æ—¶æ¿€æ´»æŸå±‚ï¼Œæ¿€æ´»çŠ¶æ€åœ¨ä¸‹æ¬¡æŒ‰é”®å¤±æ•ˆã€‚å’ŒMO(layer)çš„åŒºåˆ«å°±æ˜¯ï¼ŒMO(layer)éœ€è¦ä¿æŒæŒ‰ä¸‹æ¿€æ´»æŸä¸€å±‚ï¼Œè€ŒOSL(layer)æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œåªå¯¹ä¸‹ä¸€ä¸ªæŒ‰é”®æœ‰æ•ˆ TG(layer): åˆ‡æ¢æŸå±‚çš„æ¿€æ´»çŠ¶æ€ã€‚ä¸Šé¢çš„éƒ½æ˜¯ä¸´æ—¶æ¿€æ´»å±‚ï¼Œè€ŒTGæ˜¯æ°¸ä¹…åˆ‡æ¢å±‚çš„æ¿€æ´»çŠ¶æ€(å¼€ -\u003e å…³/å…³ -\u003e å¼€) TO(layer): æ¿€æ´»æŸä¸€å±‚ï¼Œå…³é—­å…¶ä»–æ‰€æœ‰å±‚ã€‚è¿™ä¸ªåœ¨æŒ‰ä¸‹çš„é‚£ä¸€åˆ»èµ·å°±ç”Ÿæ•ˆäº†ã€‚ TT(layer): æŒ‰ä¸‹ä¸´æ—¶æ¿€æ´»æŸå±‚ï¼ˆå’ŒMOä¸€æ ·ï¼‰ï¼Œä½†æ˜¯å¢åŠ äº†ä¸€ä¸ªåŠŸèƒ½æ˜¯ï¼Œå¦‚æœè¿ç»­å•å‡»TTï¼Œåˆ™å¯ä»¥æŠŠè¿™ä¸€å±‚æ°¸ä¹…æ¿€æ´»æˆ–å…³é—­ï¼ˆç›¸å½“äºTGï¼‰ã€‚æ¢å¥è¯è¯´ï¼ŒTTæ˜¯åŒåŠŸèƒ½ï¼Œç­‰äºMO(æŒ‰ä¸‹) + TG(å¤šå‡»)ã€‚å¤šå‡»æ¬¡æ•°å¯ä»¥é€šè¿‡ TAPPING_TOGGLEè®¾ç½®ï¼Œå¦‚åœ¨QMKä¸­ï¼Œè®¾ç½®#define TAPPING_TOGGLE 2ï¼Œå°±æ˜¯æŠŠTTè®¾ç½®æˆåŒå‡»æ¿€æ´»ã€‚ macroï¼šå®\nactionï¼šé”®ç›˜çš„åŠ¨ä½œ é™¤äº†åŸºç¡€çš„å‘é€é”®ç ä¹‹å¤–ï¼Œé”®ç›˜çš„æŒ‰é”®è¿˜æœ‰å…¶ä»–å¾ˆå¤šåŠŸèƒ½ï¼Œå¦‚ï¼š\nå±‚æ“ä½œï¼šä¸´æ—¶åˆ‡å±‚/æ¿€æ´»\u0026å¤±æ´»æŸå±‚/å±‚+modifier/å±‚çš„tapè§¦å‘ modifier tap åª’ä½“æ§åˆ¶ï¼ˆæ’­æ”¾ã€æš‚åœã€éŸ³é‡ï¼‰ ç³»ç»Ÿæ§åˆ¶ï¼ˆå…³æœºï¼‰ è¿™äº›åŠŸèƒ½å¹¶ä¸èƒ½è¢«é”®ç›˜çš„keycodeè¦†ç›–ï¼Œç»Ÿç§°ä¸º keyboard action å¦å¤–ï¼Œå†åšä¸€å±‚æŠ½è±¡ï¼šäººæ“ä½œé”®ç›˜æœ‰å‡ ç§æ–¹å¼ï¼š\næŒ‰ä¸‹/æŠ¬èµ·ï¼šæœ€æ­£å¸¸çš„æ–¹å¼ï¼ŒæŒ‰ä¸‹å’ŒæŠ¬èµ·åˆ†åˆ«ç®— tapï¼šä¹Ÿå°±æ˜¯æŒ‰ä¸‹ + æŠ¬èµ·è§¦å‘ holdï¼šé•¿æŒ‰ è¿ç»­tapï¼šqmkä¸­çš„tap dance ç»„åˆé”®ï¼šåŒæ—¶æŒ‰ä¸‹å¤šä¸ªæŒ‰é”®ï¼Œå¯ä»¥æ˜¯ modifier + keyï¼Œä¹Ÿå¯ä»¥æ˜¯key + key åœ¨ä¸Šé¢çš„è¿™äº›ï¼Œå¯ä»¥ç†è§£æˆæ˜¯human action\ndebounce\nåè®®å±‚ï¼šæ”¯æŒviaã€vial\né©±åŠ¨å±‚ï¼štrait for GPIOã€LEDã€RGBã€Encoderç­‰ç­‰\ntoolsï¼šå¿«æ·ç”Ÿæˆã€å¿«æ·æ¥å…¥ç­‰\ncliï¼šå‘½ä»¤è¡Œå·¥å…·\nKeycode System keycode é¦–å…ˆæ˜¯ç³»ç»Ÿæ¥å—çš„é”®ç ï¼Œè¿™äº›é”®ç æ˜¯å›½é™…æ ‡å‡†å®šä¹‰å¥½çš„ï¼Œå¯ä»¥å‚è§QMKçš„æ–‡æ¡£ã€‚\ntap key: æŒ‰ä¸€ä¸‹å°±è§¦å‘ä¸€æ¬¡\nLayer QMKä¸€å…±æ”¯æŒ32å±‚ï¼Œå±‚çš„æ“ä½œä¸Šé¢æœ‰å†™ã€‚åœ¨å…·ä½“å®ç°ä¸Šï¼Œ\nç”±äºæ¯å±‚éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå› æ­¤å±‚çš„å¼€å¯å’Œå…³é—­ï¼Œä¸»è¦ä½¿ç”¨bitwise operationæ¥å®ç°ã€‚ å±‚ + modifieréœ€è¦å•ç‹¬å®ç° å±‚çš„ tap æ“ä½œéœ€è¦å•ç‹¬å®ç° About Rust å˜é‡ rustä¸­å˜é‡é»˜è®¤ä¸å¯å˜ï¼Œè¦å¯å˜éœ€è¦åŠ mut\nrustä¸­ï¼Œè¿˜å¯ä»¥ç”¨ cosnt å»å£°æ˜ä¸€ä¸ªå¸¸é‡ã€‚å£°æ˜constçš„æ—¶å€™ï¼Œå¿…é¡»æŒ‡å®šç±»å‹ã€‚constä¸€èˆ¬ç”¨å¤§å†™å­—æ¯è¡¨ç¤ºã€‚\nåŸºç¡€ç±»å‹ æ•°å­— å¯¹äºæ•°å­—å’ŒåŸºç¡€çš„å˜é‡ï¼Œrustæ”¯æŒå¤šç§è¿›åˆ¶çš„è¡¨ç¤ºã€‚è¿˜å¯ä»¥æ·»åŠ _ä½œä¸ºè™šæ‹Ÿåˆ†éš”ç¬¦ï¼ˆä¸»è¦æ˜¯ä¸ºäº†å¯è¯»æ€§ï¼‰ã€‚\nNumber literals Example Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b'A' æµ®ç‚¹æ•°ã€bool f32 \u0026 f64 \u0026 boolï¼Œè¿™äº›é€šç”¨çš„ï¼ŒåŸºæœ¬éƒ½å·®ä¸å¤š\nTuple Rusté‡Œé¢ä¹Ÿæœ‰tupleï¼Œç”¨ () æ‹¬èµ·æ¥\n1 let tup: (i32, f64, u8) = (500, 6.4, 1); è¿˜èƒ½è§£ç»„\n1 let (x, y, z) = tup; Tupleå–å€¼ï¼Œä½¿ç”¨ .ï¼šlet x = tup.0\narray Array æ˜¯ä¸€ä¸ªåºåˆ—ï¼Œå’Œtupleçš„åŒºåˆ«æ˜¯ï¼ŒArrayä¸­çš„æ•°æ®ç±»å‹å¿…é¡»ä¸€è‡´ã€‚\nArrayè¿˜æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼šå®ƒè¢«åˆ†é…åœ¨stackä¸Šï¼Œå…¶é•¿åº¦æ˜¯å›ºå®šçš„\n1 let a: [i32; 5] = [3; 5]; Arrayçš„å–å€¼ï¼Œå’Œtupleä¹Ÿä¸åŒï¼šlet x = a[0]\nç›´æ¥å–çš„è¯ï¼Œæ•°ç»„è¶Šç•Œä¼šç›´æ¥panicï¼Œéœ€è¦æ³¨æ„\n","description":"","tags":null,"title":"Haobo's Blog","uri":"/posts/keyboard/keeb/"},{"categories":null,"content":"openocdé…ç½® åœ¨openocdé‡Œé¢é…ç½®ospiï¼Œåªèƒ½ç›´æ¥å†™å¯„å­˜å™¨ã€‚å› æ­¤éœ€è¦é¦–å…ˆäº†è§£ä¸€ä¸‹å¯„å­˜å™¨çš„é…ç½®\nospi1çš„èµ·å§‹ä½ç½®æ˜¯ 0x58005000\nOCTOSPI_CRå¯„å­˜å™¨ CRå³control registerã€‚æ˜¯ospiæœ€åŸºç¡€çš„é…ç½®ã€‚\nAddress offset: 0x0000 Reset value: 0x0000 0000\nä¸€å…±32Bit\nå…¶ä¸­æ¯”è¾ƒé‡è¦çš„ï¼š\nFMODEï¼š28-29ï¼Œé…ç½®äº†ospiçš„æ¨¡å¼ï¼Œæœ‰ 00ï¼š Indirect-write mode 01: Indirect-read mode 10: Automatic status-polling mode 11: Memory-mapped mode åœ¨ä½¿ç”¨ospi flashçš„æ—¶å€™ï¼Œä½¿ç”¨11\né…ç½®ï¼š\n1 mww 0x52005000 0x30400003 ;# OCTOSPI_CR: FMODE=0x11, APMS=1, FTHRES=0, FSEL=0, DQM=0, TCEN=1 (OCTOSPI_DCR1 Device configuration register 1ï¼Œè®¾å¤‡é…ç½®å¯„å­˜å™¨1\n1 mww 0x52005008 0x01160100\t;# OCTOSPI_DCR1: MTYP=0x1, FSIZE=0x19, CSHT=0x01, CKMODE=0, DLYBYP=0 MTYP: 001: Macronix mode\nDEVSIZE: Number of bytes in device = 2[DEVSIZE+1]. å› æ­¤ï¼Œåœ¨æˆ‘ä»¬è¿™é‡Œä½¿ç”¨8Mçš„æƒ…å†µä¸‹ï¼Œåº”è¯¥æ˜¯2^23ï¼Œå³devsize=22=0x16\nCTOSPI communication configuration register (OCTOSPI_CCR) DMODE: 011 data 4line mode\n","description":"","tags":null,"title":"Haobo's Blog","uri":"/posts/keyboard/ospi/"},{"categories":null,"content":"RM67162 OLED ä½¿ç”¨RM67162é©±åŠ¨OLEDå±å¹•çš„å„ç§æ–¹æ¡ˆã€‚\n4çº¿SPI é¦–å…ˆï¼Œ4çº¿SPIæ¯”3çº¿å¤šäº†ä¸€ä¸ªD/Cï¼ˆæ•°æ®ã€å‘½ä»¤ï¼‰é€‰æ‹©çº¿ï¼Œå³ä¸€å…±4ä¸ªIO\næ—¶é’ŸSCLK/SCL ä¸»æœºè¾“å‡ºä»æœºè¾“å…¥ MOSIï¼ˆåœ¨ä»æœºç«¯å«SDIï¼‰ ä»æœºè¾“å‡ºä¸»æœºè¾“å…¥ MISOï¼ˆåœ¨ä»æœºç«¯å«SDOï¼‰ å‘½ä»¤ã€æ•°æ®é€‰æ‹©ï¼šDCX å¦å¤–ï¼Œå†åŠ ä¸Šä¸€ä¸ªç‰‡é€‰ä¿¡å·CSï¼ˆæˆ–è€…å«NCSï¼‰ï¼Œä¸€å…±5æ¡æ•°æ®çº¿ã€‚\nåœ¨STM32H7ä¸­ï¼Œå¯ä»¥ä½¿ç”¨OSPIå¤–è®¾ä½œä¸º4çº¿SPIçš„ä¸»æœºã€‚æ— è®ºæ˜¯é€‰æ‹©3çº¿SPIè¿˜æ˜¯4çº¿SPIï¼Œåœ¨CubeMXä¸­éƒ½åº”é€‰æ‹©Single SPIï¼š\nç”±äºæˆ‘ä»¬ä½¿ç”¨äº†OSPIé©±åŠ¨å¤–ç½®Flashï¼Œè€ŒSTM32H7çš„å¤–è®¾ä¸­ï¼Œæ²¡æœ‰åŠæ³•åŒæ—¶ä½¿ç”¨OSPI1å’ŒOSPI2çš„ç‰‡é€‰ã€æ—¶é’Ÿä¸¤æ¡çº¿ï¼Œå› æ­¤ç›´æ¥ä½¿ç”¨æ™®é€šSPIï¼Œç„¶åæ‰‹åŠ¨è®¾ç½®ç‰‡é€‰å’ŒD/Cé€‰æ‹©çº¿æˆä¸ºäº†å”¯ä¸€çš„å¯è¡Œæ–¹å¼ï¼ˆæ™®é€šSPIä¼šè‡ªåŠ¨é…ç½®å¥½SCLKã€MOSIå’ŒMISOï¼‰ã€‚\nTODOï¼šæ™®é€šSPIçš„ç¡¬ä»¶NSSï¼ˆå³ç‰‡é€‰ï¼‰æ˜¯å¦èƒ½ç”¨ï¼Ÿ\n","description":"","tags":null,"title":"Haobo's Blog","uri":"/posts/keyboard/rm67162/"},{"categories":null,"content":"STM32CubeMX é…ç½® STM32CubeMXæ–°å·¥ç¨‹é…ç½®å¤‡å¿˜ã€‚\næ­¥éª¤ æ–°å»ºå·¥ç¨‹ï¼Œé€‰æ‹©MCU\né…ç½®DEBUGç«¯å£\né…ç½®RCCæ™¶æŒ¯\né…ç½®æ—¶é’Ÿæ ‘\né…ç½®USB\né…ç½®å…¶ä»–å¤–è®¾\né…ç½®å·¥ç¨‹ä¿¡æ¯ï¼Œä½¿ç”¨Makefileã€ä¸ºæ¯ä¸ªå¤–è®¾ç”Ÿæˆæºæ–‡ä»¶\nç”Ÿæˆæ•´ä¸ªå·¥ç¨‹\nç„¶åï¼Œå»å…¶ä»–å·¥ç¨‹ä¸‹æŠŠopenocd.cfgã€STM32H7xxxx.svdå¤åˆ¶åˆ°å·¥ç¨‹ç›®å½•ä¸‹ã€‚\nåœ¨VSCodeä¸‹é…ç½®ï¼Œtask.jsonï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"make\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"make all -j 16\", \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": \"autoDetect\", \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } } }, { \"label\": \"make clean\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"make clean\" }, { \"label\": \"flash\", \"group\": \"build\", \"type\": \"shell\", \"command\": \"openocd -f openocd.cfg -c \\\"program build/æ³¨æ„è¿™é‡Œæ˜¯ä½ çš„å·¥ç¨‹å.elf preverify verify reset exit\\\"\" } ] } å’Œlaunch.jsonï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { // ä½¿ç”¨ IntelliSense äº†è§£ç›¸å…³å±æ€§ã€‚ // æ‚¬åœä»¥æŸ¥çœ‹ç°æœ‰å±æ€§çš„æè¿°ã€‚ // æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Cortex Debug\", \"cwd\": \"${workspaceFolder}\", \"executable\": \"./build/f411.elf\", \"request\": \"launch\", \"type\": \"cortex-debug\", \"runToEntryPoint\": \"main\", \"servertype\": \"openocd\", \"showDevDebugOutput\": \"parsed\", \"configFiles\": [ \"openocd.cfg\" ], \"svdFile\": \"è¿™é‡Œæ˜¯ä½ çš„SVDæ–‡ä»¶.svd\", \"device\": \"stlink\", \"preLaunchTask\": \"make all\" } ] } ","description":"","tags":null,"title":"Haobo's Blog","uri":"/posts/keyboard/stm32cubemx/"}]
